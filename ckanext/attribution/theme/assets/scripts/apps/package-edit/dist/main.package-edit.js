(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["package-edit"] = factory();
	else
		root["package-edit"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		2: 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"0":"edit-activity","1":"edit-agent","3":"show-activity","4":"show-agent"}[chunkId]||chunkId) + ".package-edit.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/scripts/apps/package-edit/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonppackage_edit"] = window["webpackJsonppackage_edit"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 41);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _agent__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _activity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _activity__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _affiliation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _affiliation__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "e", function() { return _meta__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony import */ var _citation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _citation__WEBPACK_IMPORTED_MODULE_4__["a"]; });



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = ('__proto__' in {}); // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if (false) { var repeat, classify, classifyRE, hasConsole; }
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (false) {}

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (false) {} // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (false) {}

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     false && false;
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (false) {}

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     false && false;
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if (false) {}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       false && false;
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
     false && false;
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if (false) {}

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if (false) {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if (false) {}

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if (false) {}
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if (false) {}

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (false) {}

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if (false) {}

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (false) {} // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (false) {}
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;

if (false) { var perf; }
/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnReservedPrefix, warnNonPresent, allowedGlobals; }
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
       false && false;
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if (false) { var keyInLowerCase; }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {} else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (false) {}
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (false) {}

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
       false && false;
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       false && false;
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (false) {}
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (false) {}

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if (false) {}

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
     false && false;
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (false) {} // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (false) {}

      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if (false) {} else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (false) {} else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (false) {}

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
       false && false;

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject( false ? undefined : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if (false) { var lowerCaseEvent; }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if (false) {}
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (false) {} else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (false) {} // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {}
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if (false) {}

  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (false) {}
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (false) {}

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false ? undefined : ''; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
       false && false;
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if (false) { var hyphenatedKey; } else {
      defineReactive$$1(props, key, value);
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
     false && false;
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if (false) {}

    if (props && hasOwn(props, key)) {
       false && false;
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (false) {}

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {}
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if (false) {}

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if (false) {}

    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if (false) {}

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (false) {} // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if (false) {} else {
      vm._renderProxy = vm;
    } // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (false) {}

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (false) {}

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (false) {}

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (false) {}

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if (false) {}

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.12';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
       false && false;
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if (false) {}

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {}
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (false) {}

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if (false) {}

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (false) {}

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if (false) {}

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false) {}

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false) {}

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (false) {}
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (false) {} // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (false) {}

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (false) {} // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  if (false) { var binding, typeBinding, value$1; }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if ( // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecessary `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (false) {}

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (false) {}

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
     false && false;
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (false) {}

    var mode = this.mode; // warn invalid mode

    if (false) {}

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (false) { var name, opts; }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (false) {}
    }

    if (false) {}
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (false) { var res; }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    if (false) { var res; }

    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (false) {}

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (false) {}
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (false) {}

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (false) {}

        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (false) {}
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      if (false) {}

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         false && false;
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;

        if (false) {}
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (false) {}

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        if (false) {}

        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (false) {}

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (false) {}

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    if (false) { var parent, iterator; }

    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else if (false) {}
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (false) {}
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (false) {}

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (false) {}

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (false) {}

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        if (false) {}

        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        if (false) {} // add the component's children to its default slot


        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (false) {}
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true
  } // static name
  : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (false) {}
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (false) {}

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (false) {}
      }
    } else {
      // literal attribute
      if (false) { var res; }

      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (false) {}

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (false) {}

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
       false && false;
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (false) {}

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (false) {}

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.

  var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
        needsForceUpdate = true;
        break;
      }

      if (parent.if) {
        needsKey = true;
      }

      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',');
  return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
}

function hash(str) {
  var hash = 5381;
  var i = str.length;

  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }

  return hash >>> 0;
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, name + "=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);

  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}

function checkFunctionParameterExpression(exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn("invalid function parameter expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat$1(str, n) {
  var result = '';

  if (n > 0) {
    while (true) {
      // eslint-disable-line
      if (n & 1) {
        result += str;
      }

      n >>>= 1;

      if (n <= 0) {
        break;
      }

      str += str;
    }
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    if (false) {} // check cache


    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    if (false) {} // turn code into functions


    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    if (false) {}

    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (false) { var leadingSpaceLength; } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);

      if (false) {}

      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
     false && false;
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (false) {}
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (false) {}

        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (false) {}

      var ref = compileToFunctions(template, {
        outputSourceRange: "production" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (false) {}
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;
/* harmony default export */ __webpack_exports__["a"] = (Vue);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11), __webpack_require__(60).setImmediate))

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export Store */
/* unused harmony export createLogger */
/* unused harmony export createNamespacedHelpers */
/* unused harmony export install */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mapActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return mapGetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return mapMutations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return mapState; });
/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({
      beforeCreate: vuexInit
    });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;

    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};
      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;

      _init.call(this, options);
    };
  }
  /**
   * Vuex init hook, injected into each instances init hooks list.
   */


  function vuexInit() {
    var options = this.$options; // store injection

    if (options.store) {
      this.$store = typeof options.store === 'function' ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;
  devtoolHook.emit('vuex:init', store);
  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });
  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  }, {
    prepend: true
  });
  store.subscribeAction(function (action, state) {
    devtoolHook.emit('vuex:action', action, state);
  }, {
    prepend: true
  });
}
/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */


function find(list, f) {
  return list.filter(f)[0];
}
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


function deepCopy(obj, cache) {
  if (cache === void 0) cache = []; // just return if obj is immutable value

  if (obj === null || typeof obj !== 'object') {
    return obj;
  } // if obj is hit, it is in circular structure


  var hit = find(cache, function (c) {
    return c.original === obj;
  });

  if (hit) {
    return hit.copy;
  }

  var copy = Array.isArray(obj) ? [] : {}; // put the copy into cache at first
  // because we want to refer it in recursive deepCopy

  cache.push({
    original: obj,
    copy: copy
  });
  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });
  return copy;
}
/**
 * forEach for object
 */


function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

function partial(fn, arg) {
  return function () {
    return fn(arg);
  };
} // Base data struct for store's module, package with some attribute and method


var Module = function Module(rawModule, runtime) {
  this.runtime = runtime; // Store some children item

  this._children = Object.create(null); // Store the origin module object which passed by programmer

  this._rawModule = rawModule;
  var rawState = rawModule.state; // Store the origin module's state

  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = {
  namespaced: {
    configurable: true
  }
};

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;

  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }

  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }

  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  if (false) {}

  var newModule = new Module(rawModule, runtime);

  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  } // register nested modules


  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if (false) {}

    return;
  }

  if (!child.runtime) {
    return;
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key);
  }

  return false;
};

function update(path, targetModule, newModule) {
  if (false) {} // update target module


  targetModule.update(newModule); // update nested modules

  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (false) {}

        return;
      }

      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var functionAssert = {
  assert: function (value) {
    return typeof value === 'function';
  },
  expected: 'function'
};
var objectAssert = {
  assert: function (value) {
    return typeof value === 'function' || typeof value === 'object' && typeof value.handler === 'function';
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function (value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}

function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";

  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }

  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {}; // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731

  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (false) {}

  var plugins = options.plugins;
  if (plugins === void 0) plugins = [];
  var strict = options.strict;
  if (strict === void 0) strict = false; // store internal state

  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();
  this._makeLocalGettersCache = Object.create(null); // bind commit and dispatch to self

  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;

  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };

  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  }; // strict mode


  this.strict = strict;
  var state = this._modules.root.state; // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters

  installModule(this, state, [], this._modules.root); // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)

  resetStoreVM(this, state); // apply plugins

  plugins.forEach(function (plugin) {
    return plugin(this$1);
  });
  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;

  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = {
  state: {
    configurable: true
  }
};

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors$1.state.set = function (v) {
  if (false) {}
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this; // check object-style commit

  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;
  var mutation = {
    type: type,
    payload: payload
  };
  var entry = this._mutations[type];

  if (!entry) {
    if (false) {}

    return;
  }

  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });

  this._subscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
  .forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if (false) {}
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1 = this; // check object-style dispatch

  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;
  var action = {
    type: type,
    payload: payload
  };
  var entry = this._actions[type];

  if (!entry) {
    if (false) {}

    return;
  }

  try {
    this._actionSubscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .filter(function (sub) {
      return sub.before;
    }).forEach(function (sub) {
      return sub.before(action, this$1.state);
    });
  } catch (e) {
    if (false) {}
  }

  var result = entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1._actionSubscribers.filter(function (sub) {
          return sub.after;
        }).forEach(function (sub) {
          return sub.after(action, this$1.state);
        });
      } catch (e) {
        if (false) {}
      }

      resolve(res);
    }, function (error) {
      try {
        this$1._actionSubscribers.filter(function (sub) {
          return sub.error;
        }).forEach(function (sub) {
          return sub.error(action, this$1.state, error);
        });
      } catch (e) {
        if (false) {}
      }

      reject(error);
    });
  });
};

Store.prototype.subscribe = function subscribe(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
};

Store.prototype.subscribeAction = function subscribeAction(fn, options) {
  var subs = typeof fn === 'function' ? {
    before: fn
  } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  if (false) {}

  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0) options = {};

  if (typeof path === 'string') {
    path = [path];
  }

  if (false) {}

  this._modules.register(path, rawModule);

  installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if (false) {}

  this._modules.unregister(path);

  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });

  resetStore(this);
};

Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === 'string') {
    path = [path];
  }

  if (false) {}

  return this._modules.isRegistered(path);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);

  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors$1);

function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }

  return function () {
    var i = subs.indexOf(fn);

    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state; // init all modules

  installModule(store, state, [], store._modules.root, true); // reset vm

  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm; // bind store public getters

  store.getters = {}; // reset local getters cache

  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () {
        return store._vm[key];
      },
      enumerable: true // for local getters

    });
  }); // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins

  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent; // enable strict mode for new vm

  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }

    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;

  var namespace = store._modules.getNamespace(path); // register in namespace map


  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && "production" !== 'production') {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join('/'));
    }

    store._modulesNamespaceMap[namespace] = module;
  } // set state


  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];

    store._withCommit(function () {
      if (false) {}

      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);
  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */


function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';
  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if (false) {}
      }

      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if (false) {}
      }

      store.commit(type, payload, options);
    }
  }; // getters and state object must be gotten lazily
  // because they will be changed by vm update

  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function () {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}

function makeLocalGetters(store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) {
        return;
      } // extract local getter type


      var localType = type.slice(splitPos); // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.

      Object.defineProperty(gettersProxy, localType, {
        get: function () {
          return store.getters[type];
        },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace];
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);

    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }

    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);

        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (false) {}

    return;
  }

  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    if (false) {}
  }, {
    deep: true,
    sync: true
  });
}

function getNestedState(state, path) {
  return path.reduce(function (state, key) {
    return state[key];
  }, state);
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (false) {}

  return {
    type: type,
    payload: payload,
    options: options
  };
}

function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if (false) {}

    return;
  }

  Vue = _Vue;
  applyMixin(Vue);
}
/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */


var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};

  if (false) {}

  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

        if (!module) {
          return;
        }

        state = module.context.state;
        getters = module.context.getters;
      }

      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};

  if (false) {}

  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // Get the commit method from store


      var commit = this.$store.commit;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

        if (!module) {
          return;
        }

        commit = module.context.commit;
      }

      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};

  if (false) {}

  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val; // The namespace has been mutated by normalizeNamespace

    val = namespace + val;

    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }

      if (false) {}

      return this.$store.getters[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};

  if (false) {}

  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // get dispatch function from store


      var dispatch = this.$store.dispatch;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

        if (!module) {
          return;
        }

        dispatch = module.context.dispatch;
      }

      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */

var createNamespacedHelpers = function (namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};
/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */


function normalizeMap(map) {
  if (!isValidMap(map)) {
    return [];
  }

  return Array.isArray(map) ? map.map(function (key) {
    return {
      key: key,
      val: key
    };
  }) : Object.keys(map).map(function (key) {
    return {
      key: key,
      val: map[key]
    };
  });
}
/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */


function isValidMap(map) {
  return Array.isArray(map) || isObject(map);
}
/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */


function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }

    return fn(namespace, map);
  };
}
/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */


function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];

  if (false) {}

  return module;
} // Credits: borrowed code from fcomb/redux-logger


function createLogger(ref) {
  if (ref === void 0) ref = {};
  var collapsed = ref.collapsed;
  if (collapsed === void 0) collapsed = true;
  var filter = ref.filter;
  if (filter === void 0) filter = function (mutation, stateBefore, stateAfter) {
    return true;
  };
  var transformer = ref.transformer;
  if (transformer === void 0) transformer = function (state) {
    return state;
  };
  var mutationTransformer = ref.mutationTransformer;
  if (mutationTransformer === void 0) mutationTransformer = function (mut) {
    return mut;
  };
  var actionFilter = ref.actionFilter;
  if (actionFilter === void 0) actionFilter = function (action, state) {
    return true;
  };
  var actionTransformer = ref.actionTransformer;
  if (actionTransformer === void 0) actionTransformer = function (act) {
    return act;
  };
  var logMutations = ref.logMutations;
  if (logMutations === void 0) logMutations = true;
  var logActions = ref.logActions;
  if (logActions === void 0) logActions = true;
  var logger = ref.logger;
  if (logger === void 0) logger = console;
  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return;
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + mutation.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + action.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  };
}

function startMessage(logger, message, collapsed) {
  var startMessage = collapsed ? logger.groupCollapsed : logger.group; // render

  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage(logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('—— log end ——');
  }
}

function getFormattedTime() {
  var time = new Date();
  return " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
}

function repeat(str, times) {
  return new Array(times + 1).join(str);
}

function pad(num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num;
}

var index = {
  Store: Store,
  install: install,
  version: '3.6.2',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};
/* harmony default export */ __webpack_exports__["a"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {const logger = {
  _output(level, scope, msg) {
    this._log.push(scope, msg);

    if (this._levels.indexOf(level) < this._levels.indexOf(this.level)) {
      return;
    }

    this._console.log(scope, ...msg);
  },

  _console: null,
  _log: [],
  _levels: ['http', 'debug', 'unmapped', 'info', 'warn', 'error', 'silent'],
  level: 'silent'
};

for (const level of logger._levels) {
  logger[level] = (scope, ...msg) => logger._output(level, scope, msg);
}

if (typeof console.Console === 'function') {
  logger._console = new console.Console(process.stderr);
} else {
  logger._console = console;
}

/* harmony default export */ __webpack_exports__["a"] = (logger);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(26);
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Meta; });
/* harmony import */ var _vuex_orm_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _createSuper(a){var b=_isNativeReflectConstruct();return function(){var c,d=_getPrototypeOf(a);if(b){var e=_getPrototypeOf(this).constructor;c=Reflect.construct(d,arguments,e)}else c=d.apply(this,arguments);return _possibleConstructorReturn(this,c)}}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(a){return!1}}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var Meta=/*#__PURE__*/function(a){function b(){return _classCallCheck(this,b),c.apply(this,arguments)}_inherits(b,a);var c=_createSuper(b);return _createClass(b,null,[{key:"fields",value:function fields(){return{id:this.uid(),item_id:this.attr(null),item_type:this.attr(null),is_hidden:this.boolean(!1),is_editing:this.boolean(!1),to_delete:this.boolean(!1),is_dirty:this.boolean(!1),syncing:this.boolean(!1),is_new:this.boolean(!1)}}}]),b}(_vuex_orm_core__WEBPACK_IMPORTED_MODULE_0__[/* Model */ "a"]);_defineProperty(Meta,"entity","metadata");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cancelAll; });
/* unused harmony export post */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return get; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios_cancel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var axios_cancel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios_cancel__WEBPACK_IMPORTED_MODULE_1__);
var api=axios__WEBPACK_IMPORTED_MODULE_0___default.a.create({baseURL:"/api/3/action/",timeout:6e4,headers:{"Content-Type":"application/json"}});axios_cancel__WEBPACK_IMPORTED_MODULE_1___default()(api,{debug:!1});var cancelAll=api.cancelAll;function post(a,b,c){return api.post(a,b,{requestId:c}).then(function(a){if(a.data&&a.data.success)return a.data.result;throw Error(a.data.error||"Unspecified error")})["catch"](function(){// console.error(e);
})}function get(a,b){return api.get(a,{requestId:b}).then(function(a){if(a.data&&a.data.success)return a.data.result;throw Error(a.data.error||"Unspecified error")})["catch"](function(){// console.error(e);
})}

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Agent; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _activity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _affiliation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony import */ var _citation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _createSuper(a){var b=_isNativeReflectConstruct();return function(){var c,d=_getPrototypeOf(a);if(b){var e=_getPrototypeOf(this).constructor;c=Reflect.construct(d,arguments,e)}else c=d.apply(this,arguments);return _possibleConstructorReturn(this,c)}}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(a){return!1}}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var Agent=/*#__PURE__*/function(a){function b(){return _classCallCheck(this,b),c.apply(this,arguments)}_inherits(b,a);var c=_createSuper(b);return _createClass(b,[{key:"isActive",get:function get(){var a=0<this.activities.length,b=_meta__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].query().where("item_id",this.id).where("item_type","agents").where("is_hidden",!1).where("to_delete",!1).exists();return a&&b}},{key:"citation",get:function get(){return _citation__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].query()["with"]("meta").where("agent_id",this.id).first()}},{key:"citeable",get:function get(){return _citation__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].query().where("agent_id",this.id).whereHas("meta",function(a){a.where("to_delete",!1)}).exists()}},{key:"standardisedName",get:function get(){// should be the same as in model/agent.py
return"person"===this.agent_type?[this.family_name,this.given_names].join(", "):this.displayName}},{key:"displayName",get:function get(){// should be the same as in model/agent.py
if("person"===this.agent_type){var a=[this.given_names,this.family_name];return(this.given_names_first?a:a.reverse()).join(" ")}if("org"===this.agent_type){var b=this.name;return this.location&&(b+=" (".concat(this.location,")")),b}return this.name}},{key:"citationName",get:function get(){if("person"===this.agent_type){var a=this.given_names.split(" ").map(function(a){return a.slice(0,1)[0]+"."}).join(" ");return[this.family_name,a].join(", ")}return this.name}},{key:"activities",get:function get(){// get only unhidden activities
// makes it easier to query agents based on activities
return _activity__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].query()["with"]("meta").where("agent_id",this.id).whereHas("meta",function(a){a.where("is_hidden",!1)}).get()}}],[{key:"fields",value:function fields(){return{id:this.attr(null),agent_type:this.attr("person"),family_name:this.attr(null),given_names:this.attr(null),given_names_first:this.attr(!0),name:this.attr(null),location:this.attr(null),external_id:this.attr(null),external_id_scheme:this.attr(null),user_id:this.attr(null),meta:this.morphOne(_meta__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],"item_id","item_type"),affiliations:this.hasMany(_affiliation__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],"agent_id"),_activities:this.hasMany(_activity__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],"agent_id"),_citation:this.hasOne(_citation__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"],"agent_id")}}}]),b}(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);_defineProperty(Agent,"entity","agents");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ lib_mjs_Cite; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ plugins_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ util_namespaceObject; });

// UNUSED EXPORTS: logger, version

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/Cite/log.js
var log_namespaceObject = {};
__webpack_require__.r(log_namespaceObject);
__webpack_require__.d(log_namespaceObject, "currentVersion", function() { return currentVersion; });
__webpack_require__.d(log_namespaceObject, "retrieveVersion", function() { return retrieveVersion; });
__webpack_require__.d(log_namespaceObject, "retrieveLastVersion", function() { return retrieveLastVersion; });
__webpack_require__.d(log_namespaceObject, "undo", function() { return undo; });
__webpack_require__.d(log_namespaceObject, "save", function() { return save; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/Cite/options.js
var options_namespaceObject = {};
__webpack_require__.r(options_namespaceObject);
__webpack_require__.d(options_namespaceObject, "options", function() { return options_options; });
__webpack_require__.d(options_namespaceObject, "defaultOptions", function() { return defaultOptions; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/input/dataType.js
var dataType_namespaceObject = {};
__webpack_require__.r(dataType_namespaceObject);
__webpack_require__.d(dataType_namespaceObject, "typeOf", function() { return typeOf; });
__webpack_require__.d(dataType_namespaceObject, "dataTypeOf", function() { return dataTypeOf; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/input/graph.js
var graph_namespaceObject = {};
__webpack_require__.r(graph_namespaceObject);
__webpack_require__.d(graph_namespaceObject, "applyGraph", function() { return applyGraph; });
__webpack_require__.d(graph_namespaceObject, "removeGraph", function() { return removeGraph; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/input/parser.js
var parser_namespaceObject = {};
__webpack_require__.r(parser_namespaceObject);
__webpack_require__.d(parser_namespaceObject, "TypeParser", function() { return parser_TypeParser; });
__webpack_require__.d(parser_namespaceObject, "DataParser", function() { return DataParser; });
__webpack_require__.d(parser_namespaceObject, "FormatParser", function() { return parser_FormatParser; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/input/csl.js
var csl_namespaceObject = {};
__webpack_require__.r(csl_namespaceObject);
__webpack_require__.d(csl_namespaceObject, "clean", function() { return parseCsl; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/input/index.js
var input_namespaceObject = {};
__webpack_require__.r(input_namespaceObject);
__webpack_require__.d(input_namespaceObject, "util", function() { return util; });
__webpack_require__.d(input_namespaceObject, "add", function() { return add; });
__webpack_require__.d(input_namespaceObject, "get", function() { return get; });
__webpack_require__.d(input_namespaceObject, "remove", function() { return remove; });
__webpack_require__.d(input_namespaceObject, "has", function() { return has; });
__webpack_require__.d(input_namespaceObject, "list", function() { return list; });
__webpack_require__.d(input_namespaceObject, "chain", function() { return chain_chain; });
__webpack_require__.d(input_namespaceObject, "chainLink", function() { return chainLink; });
__webpack_require__.d(input_namespaceObject, "chainAsync", function() { return chainAsync; });
__webpack_require__.d(input_namespaceObject, "chainLinkAsync", function() { return chainLinkAsync; });
__webpack_require__.d(input_namespaceObject, "type", function() { return type_type; });
__webpack_require__.d(input_namespaceObject, "addTypeParser", function() { return addTypeParser; });
__webpack_require__.d(input_namespaceObject, "hasTypeParser", function() { return hasTypeParser; });
__webpack_require__.d(input_namespaceObject, "removeTypeParser", function() { return removeTypeParser; });
__webpack_require__.d(input_namespaceObject, "listTypeParser", function() { return listTypeParser; });
__webpack_require__.d(input_namespaceObject, "treeTypeParser", function() { return treeTypeParser; });
__webpack_require__.d(input_namespaceObject, "typeMatcher", function() { return typeMatcher; });
__webpack_require__.d(input_namespaceObject, "data", function() { return data_data; });
__webpack_require__.d(input_namespaceObject, "dataAsync", function() { return dataAsync; });
__webpack_require__.d(input_namespaceObject, "addDataParser", function() { return addDataParser; });
__webpack_require__.d(input_namespaceObject, "hasDataParser", function() { return hasDataParser; });
__webpack_require__.d(input_namespaceObject, "removeDataParser", function() { return removeDataParser; });
__webpack_require__.d(input_namespaceObject, "listDataParser", function() { return listDataParser; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/Cite/set.js
var set_namespaceObject = {};
__webpack_require__.r(set_namespaceObject);
__webpack_require__.d(set_namespaceObject, "add", function() { return set_add; });
__webpack_require__.d(set_namespaceObject, "addAsync", function() { return addAsync; });
__webpack_require__.d(set_namespaceObject, "set", function() { return set; });
__webpack_require__.d(set_namespaceObject, "setAsync", function() { return setAsync; });
__webpack_require__.d(set_namespaceObject, "reset", function() { return set_reset; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/Cite/sort.js
var sort_namespaceObject = {};
__webpack_require__.r(sort_namespaceObject);
__webpack_require__.d(sort_namespaceObject, "sort", function() { return sort; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/Cite/static.js
var static_namespaceObject = {};
__webpack_require__.r(static_namespaceObject);
__webpack_require__.d(static_namespaceObject, "async", function() { return Cite_async; });
__webpack_require__.d(static_namespaceObject, "validateOutputOptions", function() { return validateOutputOptions; });
__webpack_require__.d(static_namespaceObject, "validateOptions", function() { return validateOptions; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/output.js
var output_namespaceObject = {};
__webpack_require__.r(output_namespaceObject);
__webpack_require__.d(output_namespaceObject, "register", function() { return output_register; });
__webpack_require__.d(output_namespaceObject, "add", function() { return output_add; });
__webpack_require__.d(output_namespaceObject, "remove", function() { return output_remove; });
__webpack_require__.d(output_namespaceObject, "has", function() { return output_has; });
__webpack_require__.d(output_namespaceObject, "list", function() { return output_list; });
__webpack_require__.d(output_namespaceObject, "format", function() { return output_format; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/Cite/get.js
var get_namespaceObject = {};
__webpack_require__.r(get_namespaceObject);
__webpack_require__.d(get_namespaceObject, "getIds", function() { return getIds; });
__webpack_require__.d(get_namespaceObject, "format", function() { return get_format; });
__webpack_require__.d(get_namespaceObject, "get", function() { return get_get; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/dict.js
var dict_namespaceObject = {};
__webpack_require__.r(dict_namespaceObject);
__webpack_require__.d(dict_namespaceObject, "register", function() { return dict_register; });
__webpack_require__.d(dict_namespaceObject, "add", function() { return dict_add; });
__webpack_require__.d(dict_namespaceObject, "remove", function() { return dict_remove; });
__webpack_require__.d(dict_namespaceObject, "has", function() { return dict_has; });
__webpack_require__.d(dict_namespaceObject, "list", function() { return dict_list; });
__webpack_require__.d(dict_namespaceObject, "get", function() { return dict_get; });
__webpack_require__.d(dict_namespaceObject, "htmlDict", function() { return htmlDict; });
__webpack_require__.d(dict_namespaceObject, "textDict", function() { return textDict; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/config.js
var config_namespaceObject = {};
__webpack_require__.r(config_namespaceObject);
__webpack_require__.d(config_namespaceObject, "add", function() { return config_add; });
__webpack_require__.d(config_namespaceObject, "get", function() { return config_get; });
__webpack_require__.d(config_namespaceObject, "has", function() { return config_has; });
__webpack_require__.d(config_namespaceObject, "remove", function() { return config_remove; });
__webpack_require__.d(config_namespaceObject, "list", function() { return config_list; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugins/index.js
var plugins_namespaceObject = {};
__webpack_require__.r(plugins_namespaceObject);
__webpack_require__.d(plugins_namespaceObject, "add", function() { return plugins_add; });
__webpack_require__.d(plugins_namespaceObject, "remove", function() { return plugins_remove; });
__webpack_require__.d(plugins_namespaceObject, "has", function() { return plugins_has; });
__webpack_require__.d(plugins_namespaceObject, "list", function() { return plugins_list; });
__webpack_require__.d(plugins_namespaceObject, "input", function() { return input_namespaceObject; });
__webpack_require__.d(plugins_namespaceObject, "output", function() { return output_namespaceObject; });
__webpack_require__.d(plugins_namespaceObject, "dict", function() { return dict_namespaceObject; });
__webpack_require__.d(plugins_namespaceObject, "config", function() { return config_namespaceObject; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/util/index.js
var util_namespaceObject = {};
__webpack_require__.r(util_namespaceObject);
__webpack_require__.d(util_namespaceObject, "deepCopy", function() { return util_deepCopy; });
__webpack_require__.d(util_namespaceObject, "fetchFile", function() { return fetchFile["a" /* fetchFile */]; });
__webpack_require__.d(util_namespaceObject, "fetchFileAsync", function() { return fetchFile["b" /* fetchFileAsync */]; });
__webpack_require__.d(util_namespaceObject, "setUserAgent", function() { return fetchFile["c" /* setUserAgent */]; });
__webpack_require__.d(util_namespaceObject, "fetchId", function() { return util_fetchId; });
__webpack_require__.d(util_namespaceObject, "TokenStack", function() { return stack; });
__webpack_require__.d(util_namespaceObject, "Register", function() { return register; });
__webpack_require__.d(util_namespaceObject, "Grammar", function() { return grammar_Grammar; });
__webpack_require__.d(util_namespaceObject, "Translator", function() { return Translator; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/empty.js
var empty_namespaceObject = {};
__webpack_require__.r(empty_namespaceObject);
__webpack_require__.d(empty_namespaceObject, "parse", function() { return parse; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/url.js
var url_namespaceObject = {};
__webpack_require__.r(url_namespaceObject);
__webpack_require__.d(url_namespaceObject, "parse", function() { return fetchFile["a" /* fetchFile */]; });
__webpack_require__.d(url_namespaceObject, "parseAsync", function() { return fetchFile["b" /* fetchFileAsync */]; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/json.js
var json_namespaceObject = {};
__webpack_require__.r(json_namespaceObject);
__webpack_require__.d(json_namespaceObject, "parse", function() { return parseJSON; });
__webpack_require__.d(json_namespaceObject, "default", function() { return parseJSON; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/jquery.js
var jquery_namespaceObject = {};
__webpack_require__.r(jquery_namespaceObject);
__webpack_require__.d(jquery_namespaceObject, "parse", function() { return jquery_parse; });

// NAMESPACE OBJECT: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/html.js
var html_namespaceObject = {};
__webpack_require__.r(html_namespaceObject);
__webpack_require__.d(html_namespaceObject, "parse", function() { return html_parse; });

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/log.js


const currentVersion = function () {
  return this.log.length;
};

const retrieveVersion = function (versnum = 1) {
  if (versnum <= 0 || versnum > this.currentVersion()) {
    return null;
  } else {
    const [data, options] = this.log[versnum - 1];
    const image = new lib_mjs_Cite(JSON.parse(data), JSON.parse(options));
    image.log = this.log.slice(0, versnum);
    return image;
  }
};

const undo = function (number = 1) {
  return this.retrieveVersion(this.currentVersion() - number);
};

const retrieveLastVersion = function () {
  return this.retrieveVersion(this.currentVersion());
};

const save = function () {
  this.log.push([JSON.stringify(this.data), JSON.stringify(this._options)]);
  return this;
};


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/validate.js
const formats = ['real', 'string'];
const types = ['json', 'html', 'string', 'rtf'];
const styles = ['csl', 'bibtex', 'bibtxt', 'citation-*', 'ris', 'ndjson'];
const wrapperTypes = ['string', 'function'];
function validateOutputOptions(options) {
  if (typeof options !== 'object') {
    throw new TypeError('Options not an object!');
  }

  const {
    format,
    type,
    style,
    lang,
    append,
    prepend
  } = options;

  if (format && !formats.includes(format)) {
    throw new TypeError(`Option format ("${format}") should be one of: ${formats}`);
  } else if (type && !types.includes(type)) {
    throw new TypeError(`Option type ("${type}") should be one of: ${types}`);
  } else if (style && !styles.includes(style) && !/^citation/.test(style)) {
    throw new TypeError(`Option style ("${style}") should be one of: ${styles}`);
  } else if (lang && typeof lang !== 'string') {
    throw new TypeError(`Option lang should be a string, but is a ${typeof lang}`);
  } else if (prepend && !wrapperTypes.includes(typeof prepend)) {
    throw new TypeError(`Option prepend should be a string or a function, but is a ${typeof prepend}`);
  } else if (append && !wrapperTypes.includes(typeof append)) {
    throw new TypeError(`Option append should be a string or a function, but is a ${typeof append}`);
  }

  if (/^citation/.test(style) && type === 'json') {
    throw new Error(`Combination type/style of json/citation-* is not valid: ${type}/${style}`);
  }

  return true;
}
function validateOptions(options) {
  if (typeof options !== 'object') {
    throw new TypeError('Options should be an object');
  }

  if (options.output) {
    validateOutputOptions(options.output);
  } else if (options.maxChainLength && typeof options.maxChainLength !== 'number') {
    throw new TypeError('Option maxChainLength should be a number');
  } else if (options.forceType && typeof options.forceType !== 'string') {
    throw new TypeError('Option forceType should be a string');
  } else if (options.generateGraph != null && typeof options.generateGraph !== 'boolean') {
    throw new TypeError('Option generateGraph should be a boolean');
  } else if (options.strict != null && typeof options.strict !== 'boolean') {
    throw new TypeError('Option strict should be a boolean');
  } else if (options.target != null && typeof options.target !== 'string') {
    throw new TypeError('Option target should be a boolean');
  }

  return true;
}
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/options.js

const defaultOptions = {
  format: 'real',
  type: 'json',
  style: 'csl',
  lang: 'en-US'
};

const options_options = function (options, log) {
  validateOutputOptions(options);

  if (log) {
    this.save();
  }

  Object.assign(this._options, options);
  return this;
};


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/dataType.js
const typeOf = thing => {
  switch (thing) {
    case undefined:
      return 'Undefined';

    case null:
      return 'Null';

    default:
      return thing.constructor.name;
  }
};
const dataTypeOf = thing => {
  switch (typeof thing) {
    case 'string':
      return 'String';

    case 'object':
      if (Array.isArray(thing)) {
        return 'Array';
      } else if (typeOf(thing) === 'Object') {
        return 'SimpleObject';
      } else if (typeOf(thing) !== 'Null') {
        return 'ComplexObject';
      }

    default:
      return 'Primitive';
  }
};
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/graph.js
const applyGraph = (entry, graph) => {
  if (entry._graph) {
    const index = graph.findIndex(({
      type
    }) => type === '@else/list+object');

    if (index !== -1) {
      graph.splice(index + 1, 0, ...entry._graph.slice(0, -1));
    }
  }

  entry._graph = graph;
  return entry;
};
const removeGraph = entry => {
  delete entry._graph;
  return entry;
};
// EXTERNAL MODULE: ./node_modules/@citation-js/core/lib-mjs/logger.js
var logger = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/type.js


const type_types = {};
const dataTypes = {};
const unregExts = {};

const parseNativeTypes = (input, dataType) => {
  switch (dataType) {
    case 'Array':
      if (input.length === 0 || input.every(entry => type_type(entry) === '@csl/object')) {
        return '@csl/list+object';
      } else {
        return '@else/list+object';
      }

    case 'SimpleObject':
    case 'ComplexObject':
      return '@csl/object';

    default:
      return '@invalid';
  }
};

const matchType = (typeList = [], data) => {
  for (const type of typeList) {
    if (type_types[type].predicate(data)) {
      return matchType(type_types[type].extensions, data) || type;
    }
  }
};

const type_type = input => {
  const dataType = dataTypeOf(input);

  if (dataType === 'Array' && input.length === 0) {
    return parseNativeTypes(input, dataType);
  }

  const match = matchType(dataTypes[dataType], input);
  return match || parseNativeTypes(input, dataType);
};
const addTypeParser = (format, {
  dataType,
  predicate,
  extends: extend
}) => {
  let extensions = [];

  if (format in unregExts) {
    extensions = unregExts[format];
    delete unregExts[format];
    logger["a" /* default */].debug('[core]', `Subclasses "${extensions}" finally registered to parent type "${format}"`);
  }

  const object = {
    predicate,
    extensions
  };
  type_types[format] = object;

  if (extend) {
    const parentTypeParser = type_types[extend];

    if (parentTypeParser) {
      parentTypeParser.extensions.push(format);
    } else {
      if (!unregExts[extend]) {
        unregExts[extend] = [];
      }

      unregExts[extend].push(format);
      logger["a" /* default */].debug('[core]', `Subclass "${format}" is waiting on parent type "${extend}"`);
    }
  } else {
    const typeList = dataTypes[dataType] || (dataTypes[dataType] = []);
    typeList.push(format);
  }
};
const hasTypeParser = type => Object.prototype.hasOwnProperty.call(type_types, type);
const removeTypeParser = type => {
  delete type_types[type];
  const typeLists = [...Object.keys(dataTypes).map(key => dataTypes[key]), ...Object.keys(type_types).map(type => type_types[type].extensions).filter(list => list.length > 0)];
  typeLists.forEach(typeList => {
    const index = typeList.indexOf(type);

    if (index > -1) {
      typeList.splice(index, 1);
    }
  });
};
const listTypeParser = () => Object.keys(type_types);
const treeTypeParser = () => {
  const attachNode = name => ({
    name,
    children: type_types[name].extensions.map(attachNode)
  });

  return {
    name: 'Type tree',
    children: Object.keys(dataTypes).map(name => ({
      name,
      children: dataTypes[name].map(attachNode)
    }))
  };
};
const typeMatcher = /^(?:@(.+?))(?:\/(?:(.+?)\+)?(?:(.+)))?$/;
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/parser.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



class parser_TypeParser {
  constructor(data) {
    _defineProperty(this, "validDataTypes", ['String', 'Array', 'SimpleObject', 'ComplexObject', 'Primitive']);

    this.data = data;
  }

  validateDataType() {
    const dataType = this.data.dataType;

    if (dataType && !this.validDataTypes.includes(dataType)) {
      throw new RangeError(`dataType was ${dataType}; expected one of ${this.validDataTypes}`);
    }
  }

  validateParseType() {
    const predicate = this.data.predicate;

    if (predicate && !(predicate instanceof RegExp || typeof predicate === 'function')) {
      throw new TypeError(`predicate was ${typeof predicate}; expected RegExp or function`);
    }
  }

  validateTokenList() {
    const tokenList = this.data.tokenList;

    if (tokenList && typeof tokenList !== 'object') {
      throw new TypeError(`tokenList was ${typeof tokenList}; expected object or RegExp`);
    }
  }

  validatePropertyConstraint() {
    const propertyConstraint = this.data.propertyConstraint;

    if (propertyConstraint && typeof propertyConstraint !== 'object') {
      throw new TypeError(`propertyConstraint was ${typeof propertyConstraint}; expected array or object`);
    }
  }

  validateElementConstraint() {
    const elementConstraint = this.data.elementConstraint;

    if (elementConstraint && typeof elementConstraint !== 'string') {
      throw new TypeError(`elementConstraint was ${typeof elementConstraint}; expected string`);
    }
  }

  validateExtends() {
    const extend = this.data.extends;

    if (extend && typeof extend !== 'string') {
      throw new TypeError(`extends was ${typeof extend}; expected string`);
    }
  }

  validate() {
    if (this.data === null || typeof this.data !== 'object') {
      throw new TypeError(`typeParser was ${typeof this.data}; expected object`);
    }

    this.validateDataType();
    this.validateParseType();
    this.validateTokenList();
    this.validatePropertyConstraint();
    this.validateElementConstraint();
    this.validateExtends();
  }

  parseTokenList() {
    let tokenList = this.data.tokenList;

    if (!tokenList) {
      return [];
    } else if (tokenList instanceof RegExp) {
      tokenList = {
        token: tokenList
      };
    }

    const {
      token,
      split = /\s+/,
      trim = true,
      every = true
    } = tokenList;

    const trimInput = input => trim ? input.trim() : input;

    const testTokens = every ? 'every' : 'some';

    const predicate = input => trimInput(input).split(split)[testTokens](part => token.test(part));

    return [predicate];
  }

  parsePropertyConstraint() {
    const constraints = [].concat(this.data.propertyConstraint || []);
    return constraints.map(({
      props,
      match = 'every',
      value
    }) => {
      props = [].concat(props);

      switch (match) {
        case 'every':
          return input => props.every(prop => prop in input && (!value || value(input[prop])));

        case 'any':
        case 'some':
          return input => props.some(prop => prop in input && (!value || value(input[prop])));

        case 'none':
          return input => !props.some(prop => prop in input && (!value || value(input[prop])));
      }
    });
  }

  parseElementConstraint() {
    const constraint = this.data.elementConstraint;
    return !constraint ? [] : [input => input.every(entry => type_type(entry) === constraint)];
  }

  parsePredicate() {
    if (this.data.predicate instanceof RegExp) {
      return [this.data.predicate.test.bind(this.data.predicate)];
    } else if (this.data.predicate) {
      return [this.data.predicate];
    } else {
      return [];
    }
  }

  getCombinedPredicate() {
    const predicates = [...this.parsePredicate(), ...this.parseTokenList(), ...this.parsePropertyConstraint(), ...this.parseElementConstraint()];

    if (predicates.length === 0) {
      return () => true;
    } else if (predicates.length === 1) {
      return predicates[0];
    } else {
      return input => predicates.every(predicate => predicate(input));
    }
  }

  getDataType() {
    if (this.data.dataType) {
      return this.data.dataType;
    } else if (this.data.predicate instanceof RegExp) {
      return 'String';
    } else if (this.data.tokenList) {
      return 'String';
    } else if (this.data.elementConstraint) {
      return 'Array';
    } else {
      return 'Primitive';
    }
  }

  get dataType() {
    return this.getDataType();
  }

  get predicate() {
    return this.getCombinedPredicate();
  }

  get extends() {
    return this.data.extends;
  }

}

class DataParser {
  constructor(parser, {
    async
  } = {}) {
    this.parser = parser;
    this.async = async;
  }

  validate() {
    const parser = this.parser;

    if (typeof parser !== 'function') {
      throw new TypeError(`parser was ${typeof parser}; expected function`);
    }
  }

}

class parser_FormatParser {
  constructor(format, parsers = {}) {
    this.format = format;

    if (parsers.parseType) {
      this.typeParser = new parser_TypeParser(parsers.parseType);
    }

    if (parsers.parse) {
      this.dataParser = new DataParser(parsers.parse, {
        async: false
      });
    }

    if (parsers.parseAsync) {
      this.asyncDataParser = new DataParser(parsers.parseAsync, {
        async: true
      });
    }
  }

  validateFormat() {
    const format = this.format;

    if (!typeMatcher.test(format)) {
      throw new TypeError(`format name was "${format}"; didn't match expected pattern`);
    }
  }

  validate() {
    this.validateFormat();

    if (this.typeParser) {
      this.typeParser.validate();
    }

    if (this.dataParser) {
      this.dataParser.validate();
    }

    if (this.asyncDataParser) {
      this.asyncDataParser.validate();
    }
  }

}


// EXTERNAL MODULE: ./node_modules/@citation-js/name/lib/index.js
var lib = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/csl.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        csl_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function csl_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


const NAME = 1;
const NAME_LIST = 2;
const DATE = 3;
const TYPE = 4;
const entryTypes = {
  article: true,
  'article-journal': true,
  'article-magazine': true,
  'article-newspaper': true,
  bill: true,
  book: true,
  broadcast: true,
  chapter: true,
  classic: true,
  collection: true,
  dataset: true,
  document: true,
  entry: true,
  'entry-dictionary': true,
  'entry-encyclopedia': true,
  event: true,
  figure: true,
  graphic: true,
  hearing: true,
  interview: true,
  legal_case: true,
  legislation: true,
  manuscript: true,
  map: true,
  motion_picture: true,
  musical_score: true,
  pamphlet: true,
  'paper-conference': true,
  patent: true,
  performance: true,
  periodical: true,
  personal_communication: true,
  post: true,
  'post-weblog': true,
  regulation: true,
  report: true,
  review: true,
  'review-book': true,
  software: true,
  song: true,
  speech: true,
  standard: true,
  thesis: true,
  treaty: true,
  webpage: true,
  'journal-article': 'article-journal',
  'book-chapter': 'chapter',
  'posted-content': 'manuscript',
  'proceedings-article': 'paper-conference'
};
const fieldTypes = {
  author: NAME_LIST,
  'collection-editor': NAME_LIST,
  composer: NAME_LIST,
  'container-author': NAME_LIST,
  editor: NAME_LIST,
  'editorial-director': NAME_LIST,
  director: NAME_LIST,
  interviewer: NAME_LIST,
  illustrator: NAME_LIST,
  'original-author': NAME_LIST,
  'reviewed-author': NAME_LIST,
  recipient: NAME_LIST,
  translator: NAME_LIST,
  accessed: DATE,
  container: DATE,
  'event-date': DATE,
  issued: DATE,
  'original-date': DATE,
  submitted: DATE,
  type: TYPE,
  categories: 'object',
  id: ['string', 'number'],
  language: 'string',
  journalAbbreviation: 'string',
  shortTitle: 'string',
  abstract: 'string',
  annote: 'string',
  archive: 'string',
  archive_location: 'string',
  'archive-place': 'string',
  authority: 'string',
  'call-number': 'string',
  'chapter-number': 'string',
  'citation-number': 'string',
  'citation-label': 'string',
  'collection-number': 'string',
  'collection-title': 'string',
  'container-title': 'string',
  'container-title-short': 'string',
  dimensions: 'string',
  DOI: 'string',
  edition: ['string', 'number'],
  event: 'string',
  'event-place': 'string',
  'first-reference-note-number': 'string',
  genre: 'string',
  ISBN: 'string',
  ISSN: 'string',
  issue: ['string', 'number'],
  jurisdiction: 'string',
  keyword: 'string',
  locator: 'string',
  medium: 'string',
  note: 'string',
  number: ['string', 'number'],
  'number-of-pages': 'string',
  'number-of-volumes': ['string', 'number'],
  'original-publisher': 'string',
  'original-publisher-place': 'string',
  'original-title': 'string',
  page: 'string',
  'page-first': 'string',
  PMCID: 'string',
  PMID: 'string',
  publisher: 'string',
  'publisher-place': 'string',
  references: 'string',
  'reviewed-title': 'string',
  scale: 'string',
  section: 'string',
  source: 'string',
  status: 'string',
  title: 'string',
  'title-short': 'string',
  URL: 'string',
  version: 'string',
  volume: ['string', 'number'],
  'year-suffix': 'string'
};

const correctName = function (name, bestGuessConversions) {
  if (typeof name === 'object' && name !== null && (name.literal || name.given || name.family)) {
    return name;
  } else if (!bestGuessConversions) {
    return undefined;
  } else if (typeof name === 'string') {
    return Object(lib["parse"])(name);
  }
};

const correctNameList = function (nameList, bestGuessConversions) {
  if (nameList instanceof Array) {
    const names = nameList.map(name => correctName(name, bestGuessConversions)).filter(Boolean);
    return names.length ? names : undefined;
  }
};

const correctDateParts = function (dateParts, bestGuessConversions) {
  if (dateParts.every(part => typeof part === 'number')) {
    return dateParts;
  } else if (!bestGuessConversions || dateParts.some(part => isNaN(parseInt(part)))) {
    return undefined;
  } else {
    return dateParts.map(part => parseInt(part));
  }
};

const correctDate = function (date, bestGuessConversions) {
  const dp = 'date-parts';

  if (typeof date !== 'object' || date === null) {
    return undefined;
  } else if (date[dp] instanceof Array && date[dp].every(part => part instanceof Array)) {
    const range = date[dp].map(dateParts => correctDateParts(dateParts, bestGuessConversions)).filter(Boolean);
    return range.length ? _objectSpread(_objectSpread({}, date), {}, {
      'date-parts': range
    }) : undefined;
  } else if (date instanceof Array && date.every(part => part[dp] instanceof Array)) {
    const range = date.map(dateParts => correctDateParts(dateParts[dp], bestGuessConversions)).filter(Boolean);
    return range.length ? {
      'date-parts': range
    } : undefined;
  } else if (date[dp] instanceof Array) {
    const dateParts = correctDateParts(date[dp], bestGuessConversions);
    return dateParts && {
      'date-parts': [dateParts]
    };
  } else if ('literal' in date || 'raw' in date) {
    return date;
  }
};

const correctType = function (type, bestGuessConversions) {
  type = correctField('language', type, bestGuessConversions);

  if (entryTypes[type] === true) {
    return type;
  } else if (bestGuessConversions && type in entryTypes) {
    return entryTypes[type];
  } else {
    return undefined;
  }
};

const correctField = function (fieldName, value, bestGuessConversions) {
  const fieldType = [].concat(fieldTypes[fieldName]);

  switch (fieldTypes[fieldName]) {
    case NAME:
      return correctName(value, bestGuessConversions);

    case NAME_LIST:
      return correctNameList(value, bestGuessConversions);

    case DATE:
      return correctDate(value, bestGuessConversions);

    case TYPE:
      return correctType(value, bestGuessConversions);
  }

  if (/^_/.test(fieldName)) {
    return value;
  } else if (bestGuessConversions) {
    if (typeof value === 'string' && fieldType.includes('number') && !isNaN(+value)) {
      return parseFloat(value);
    } else if (typeof value === 'number' && fieldType.includes('string') && !fieldType.includes('number')) {
      return value.toString();
    } else if (Array.isArray(value) && value.length) {
      return correctField(fieldName, value[0], bestGuessConversions);
    }
  }

  if (fieldType.includes(typeof value)) {
    return value;
  }
};

const parseCsl = function (data, bestGuessConversions = true) {
  return data.map(function (entry) {
    const clean = {};

    for (const field in entry) {
      const correction = correctField(field, entry[field], bestGuessConversions);

      if (correction !== undefined) {
        clean[field] = correction;
      }
    }

    return clean;
  });
};


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/deepCopy.js
function deepCopy(value, seen = new Set()) {
  if (typeof value !== 'object' || value === null || value.constructor !== Object && value.constructor !== Array) {
    return value;
  }

  if (seen.has(value)) {
    throw new TypeError('Recursively copying circular structure');
  }

  seen.add(value);
  let copy;

  if (value.constructor === Array) {
    copy = value.map(value => deepCopy(value, seen));
  } else {
    const object = {};

    for (const key in value) {
      object[key] = deepCopy(value[key], seen);
    }

    copy = object;
  }

  seen.delete(value);
  return copy;
}
/* harmony default export */ var util_deepCopy = (deepCopy);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/chain.js







function prepareParseGraph(graph) {
  return graph.reduce((array, next) => {
    const last = array[array.length - 1];

    if (last && last.type === next.type) {
      last.count = last.count + 1 || 2;
    } else {
      array.push(next);
    }

    return array;
  }, []).map(element => (element.count > 1 ? element.count + 'x ' : '') + element.type).join(' -> ');
}

class chain_ChainParser {
  constructor(input, options = {}) {
    this.options = Object.assign({
      generateGraph: true,
      forceType: type_type(input),
      maxChainLength: 10,
      strict: true,
      target: '@csl/list+object'
    }, options);
    this.type = this.options.forceType;
    this.data = typeof input === 'object' ? util_deepCopy(input) : input;
    this.graph = [{
      type: this.type,
      data: input
    }];
    this.iteration = 0;
  }

  iterate() {
    if (this.iteration !== 0) {
      const typeInfo = get(this.type);

      if (typeInfo && typeInfo.outputs) {
        this.type = typeInfo.outputs;
      } else {
        this.type = type_type(this.data);
      }

      this.graph.push({
        type: this.type
      });
    }

    if (this.error || this.type === this.options.target) {
      return false;
    } else if (this.iteration >= this.options.maxChainLength) {
      this.error = new RangeError(`Max. number of parsing iterations reached (${prepareParseGraph(this.graph)})`);
      return false;
    } else {
      this.iteration++;
      return true;
    }
  }

  end() {
    if (this.error) {
      logger["a" /* default */].error('[core]', this.error.message);

      if (this.options.strict !== false) {
        throw this.error;
      } else {
        return [];
      }
    } else if (this.options.target === '@csl/list+object') {
      return this.data.map(this.options.generateGraph ? entry => applyGraph(entry, this.graph) : removeGraph);
    } else {
      return this.data;
    }
  }

}

const chain_chain = (...args) => {
  const chain = new chain_ChainParser(...args);

  while (chain.iterate()) {
    try {
      chain.data = data_data(chain.data, chain.type);
    } catch (e) {
      chain.error = e;
    }
  }

  return chain.end();
};
const chainLink = input => {
  const type = type_type(input);
  const output = type.match(/array|object/) ? util_deepCopy(input) : input;
  return data_data(output, type);
};
const chainAsync = async (...args) => {
  const chain = new chain_ChainParser(...args);

  while (chain.iterate()) {
    chain.data = await dataAsync(chain.data, chain.type).catch(e => {
      chain.error = e;
    });
  }

  return chain.end();
};
const chainLinkAsync = async input => {
  const type = type_type(input);
  const output = type.match(/array|object/) ? util_deepCopy(input) : input;
  return dataAsync(output, type);
};
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/data.js


const flatten = array => [].concat(...array);

const data_parsers = {};
const asyncParsers = {};
const nativeParsers = {
  '@csl/object': input => [input],
  '@csl/list+object': input => input,
  '@else/list+object': input => flatten(input.map(chain_chain)),
  '@invalid': () => {
    throw new Error('This format is not supported or recognized');
  }
};
const nativeAsyncParsers = {
  '@else/list+object': async input => flatten(await Promise.all(input.map(chainAsync)))
};
const data_data = (input, type) => {
  if (typeof data_parsers[type] === 'function') {
    return data_parsers[type](input);
  } else if (typeof nativeParsers[type] === 'function') {
    return nativeParsers[type](input);
  } else {
    throw new TypeError(`No synchronous parser found for ${type}`);
  }
};
const dataAsync = async (input, type) => {
  if (typeof asyncParsers[type] === 'function') {
    return asyncParsers[type](input);
  } else if (typeof nativeAsyncParsers[type] === 'function') {
    return nativeAsyncParsers[type](input);
  } else if (hasDataParser(type, false)) {
    return data_data(input, type);
  } else {
    throw new TypeError(`No parser found for ${type}`);
  }
};
const addDataParser = (format, {
  parser,
  async
}) => {
  if (async) {
    asyncParsers[format] = parser;
  } else {
    data_parsers[format] = parser;
  }
};
const hasDataParser = (type, async) => async ? asyncParsers[type] || nativeAsyncParsers[type] : data_parsers[type] || nativeParsers[type];
const removeDataParser = (type, async) => {
  delete (async ? asyncParsers : data_parsers)[type];
};
const listDataParser = async => Object.keys(async ? asyncParsers : data_parsers);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/register.js



const register_formats = {};
const add = (format, parsers) => {
  const formatParser = new parser_FormatParser(format, parsers);
  formatParser.validate();
  const index = register_formats[format] || (register_formats[format] = {});

  if (formatParser.typeParser) {
    addTypeParser(format, formatParser.typeParser);
    index.type = true;
  }

  if (formatParser.dataParser) {
    addDataParser(format, formatParser.dataParser);
    index.data = true;
  }

  if (formatParser.asyncDataParser) {
    addDataParser(format, formatParser.asyncDataParser);
    index.asyncData = true;
  }

  if (parsers.outputs) {
    index.outputs = parsers.outputs;
  }
};
const get = format => {
  return register_formats[format];
};
const remove = format => {
  const index = register_formats[format];

  if (!index) {
    return;
  }

  if (index.type) {
    removeTypeParser(format);
  }

  if (index.data) {
    removeDataParser(format);
  }

  if (index.asyncData) {
    removeDataParser(format, true);
  }

  delete register_formats[format];
};
const has = format => format in register_formats;
const list = () => Object.keys(register_formats);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/input/index.js




const util = Object.assign({}, dataType_namespaceObject, graph_namespaceObject, parser_namespaceObject, csl_namespaceObject);




// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/fetchId.js
const fetchId = function (list, prefix) {
  let id;

  while (id === undefined || list.includes(id)) {
    id = `${prefix}${Math.random().toString().slice(2)}`;
  }

  return id;
};

/* harmony default export */ var util_fetchId = (fetchId);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/set.js



const set_add = function (data, options = {}, log = false) {
  if (options === true || log === true) {
    this.save();
  }

  this.data.push(...chain_chain(data, options));
  this.data.filter(entry => !Object.prototype.hasOwnProperty.call(entry, 'id')).forEach(entry => {
    entry.id = util_fetchId(this.getIds(), 'temp_id_');
  });
  return this;
};

const addAsync = async function (data, options = {}, log = false) {
  if (options === true || log === true) {
    this.save();
  }

  this.data.push(...(await chainAsync(data, options)));
  this.data.filter(entry => !Object.prototype.hasOwnProperty.call(entry, 'id')).forEach(entry => {
    entry.id = util_fetchId(this.getIds(), 'temp_id_');
  });
  return this;
};

const set = function (data, options = {}, log = false) {
  if (options === true || log === true) {
    this.save();
  }

  this.data = [];
  return typeof options !== 'boolean' ? this.add(data, options) : this.add(data);
};

const setAsync = async function (data, options = {}, log = false) {
  if (options === true || log === true) {
    this.save();
  }

  this.data = [];
  return typeof options !== 'boolean' ? this.addAsync(data, options) : this.addAsync(data);
};

const set_reset = function (log) {
  if (log) {
    this.save();
  }

  this.data = [];
  this._options = {};
  return this;
};


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/output/label.js
const getLabel = entry => {
  if ('citation-label' in entry) {
    return entry['citation-label'];
  }

  let res = '';

  if (entry.author) {
    res += entry.author[0].family || entry.author[0].literal;
  }

  if (entry.issued && entry.issued['date-parts'] && entry.issued['date-parts'][0]) {
    res += entry.issued['date-parts'][0][0];
  }

  if (entry['year-suffix']) {
    res += entry['year-suffix'];
  } else if (entry.title) {
    res += entry.title.replace(/<\/?.*?>/g, '').match(/^(?:(?:the|a|an)\s+)?(\S+)/i)[1];
  }

  return res;
};


/* harmony default export */ var output_label = ({
  label(data) {
    return data.reduce((object, entry) => {
      object[entry.id] = getLabel(entry);
      return object;
    }, {});
  }

});
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/sort.js



const getComparisonValue = function (obj, prop, label = prop === 'label') {
  let value = label ? getLabel(obj) : obj[prop];

  switch (prop) {
    case 'author':
    case 'editor':
      return value.map(name => name.literal || name.family || Object(lib["format"])(name));

    case 'accessed':
    case 'issued':
      return value['date-parts'][0];

    case 'page':
      return value.split('-').map(num => parseInt(num));

    case 'edition':
    case 'issue':
    case 'volume':
      value = parseInt(value);
      return !isNaN(value) ? value : -Infinity;

    default:
      return value || -Infinity;
  }
};

const compareProp = function (entryA, entryB, prop, flip = /^!/.test(prop)) {
  prop = prop.replace(/^!/, '');
  const a = getComparisonValue(entryA, prop);
  const b = getComparisonValue(entryB, prop);
  return (flip ? -1 : 1) * (a > b ? 1 : a < b ? -1 : 0);
};

const getSortCallback = function (...props) {
  return (a, b) => {
    const keys = props.slice();
    let output = 0;

    while (!output && keys.length) {
      output = compareProp(a, b, keys.shift());
    }

    return output;
  };
};

const sort = function (method = [], log) {
  if (log) {
    this.save();
  }

  this.data.sort(typeof method === 'function' ? method : getSortCallback(...method, 'label'));
  return this;
};


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/async.js


const async_async = function (data, options, callback) {
  if (typeof options === 'function' && !callback) {
    callback = options;
    options = undefined;
  }

  const promise = lib_mjs_Cite().setAsync(data, options);

  if (typeof callback === 'function') {
    promise.then(callback);
    return undefined;
  } else {
    return promise;
  }
};

/* harmony default export */ var Cite_async = (async_async);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/static.js


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/register.js
class Register {
  constructor(data = {}) {
    this.data = data;
  }

  set(key, value) {
    this.data[key] = value;
    return this;
  }

  add(...args) {
    return this.set(...args);
  }

  delete(key) {
    delete this.data[key];
    return this;
  }

  remove(...args) {
    return this.delete(...args);
  }

  get(key) {
    return this.data[key];
  }

  has(key) {
    return Object.prototype.hasOwnProperty.call(this.data, key);
  }

  list() {
    return Object.keys(this.data);
  }

}

/* harmony default export */ var register = (Register);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/output.js


const validate = (name, formatter) => {
  if (typeof name !== 'string') {
    throw new TypeError(`Invalid output format name, expected string, got ${typeof name}`);
  } else if (typeof formatter !== 'function') {
    throw new TypeError(`Invalid formatter, expected function, got ${typeof formatter}`);
  }
};

const output_register = new register();
const output_add = (name, formatter) => {
  validate(name, formatter);
  output_register.set(name, formatter);
};
const output_remove = name => {
  output_register.remove(name);
};
const output_has = name => {
  return output_register.has(name);
};
const output_list = () => {
  return output_register.list();
};
const output_format = (name, data, ...options) => {
  if (!output_register.has(name)) {
    throw new Error(`Output format "${name}" unavailable`);
  }

  return output_register.get(name)(data, ...options);
};
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/get.js



function getIds() {
  return this.data.map(entry => entry.id);
}
function get_format(format, ...options) {
  return output_format(format, parseCsl(this.data), ...options);
}
function get_get(options = {}) {
  validateOutputOptions(options);
  const parsedOptions = Object.assign({}, this.defaultOptions, this._options.output, options);
  const {
    type,
    style
  } = parsedOptions;
  const [styleType, styleFormat] = style.split('-');
  const newStyle = styleType === 'citation' ? 'bibliography' : styleType === 'csl' ? 'data' : styleType;
  const newType = type === 'string' ? 'text' : type === 'json' ? 'object' : type;
  let formatOptions;

  switch (newStyle) {
    case 'bibliography':
      {
        const {
          lang,
          append,
          prepend
        } = parsedOptions;
        formatOptions = {
          template: styleFormat,
          lang,
          format: newType,
          append,
          prepend
        };
        break;
      }

    case 'data':
    case 'bibtex':
    case 'bibtxt':
    case 'ndjson':
    case 'ris':
      formatOptions = {
        type: newType
      };
      break;

    default:
      throw new Error(`Invalid style "${newStyle}"`);
  }

  const result = this.format(newStyle, Object.assign(formatOptions, options._newOptions));
  const {
    format
  } = parsedOptions;

  if (format === 'real' && newType === 'html' && typeof document !== 'undefined' && typeof document.createElement === 'function') {
    const tmp = document.createElement('div');
    tmp.innerHTML = result;
    return tmp.firstChild;
  } else if (format === 'string' && typeof result === 'object') {
    return JSON.stringify(result);
  } else {
    return result;
  }
}
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/Cite/index.js







function Cite(data, options = {}) {
  if (!(this instanceof Cite)) {
    return new Cite(data, options);
  }

  this._options = options;
  this.log = [];
  this.data = [];
  this.set(data, options);
  this.options(options);
  return this;
}

Object.assign(Cite.prototype, log_namespaceObject, options_namespaceObject, set_namespaceObject, sort_namespaceObject, get_namespaceObject);

Cite.prototype[Symbol.iterator] = function* () {
  yield* this.data;
};

Object.assign(Cite, static_namespaceObject);
/* harmony default export */ var lib_mjs_Cite = (Cite);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/dict.js


const dict_validate = (name, dict) => {
  if (typeof name !== 'string') {
    throw new TypeError(`Invalid dict name, expected string, got ${typeof name}`);
  } else if (typeof dict !== 'object') {
    throw new TypeError(`Invalid dict, expected object, got ${typeof dict}`);
  }

  for (const entryName in dict) {
    const entry = dict[entryName];

    if (!Array.isArray(entry) || entry.some(part => typeof part !== 'string')) {
      throw new TypeError(`Invalid dict entry "${entryName}", expected array of strings`);
    }
  }
};

const dict_register = new register({
  html: {
    bibliographyContainer: ['<div class="csl-bib-body">', '</div>'],
    entry: ['<div class="csl-entry">', '</div>'],
    list: ['<ul style="list-style-type:none">', '</ul>'],
    listItem: ['<li>', '</li>']
  },
  text: {
    bibliographyContainer: ['', '\n'],
    entry: ['', '\n'],
    list: ['\n', ''],
    listItem: ['\t', '\n']
  }
});
const dict_add = (name, dict) => {
  dict_validate(name, dict);
  dict_register.set(name, dict);
};
const dict_remove = name => {
  dict_register.remove(name);
};
const dict_has = name => {
  return dict_register.has(name);
};
const dict_list = () => {
  return dict_register.list();
};
const dict_get = name => {
  if (!dict_register.has(name)) {
    throw new Error(`Dict "${name}" unavailable`);
  }

  return dict_register.get(name);
};
const htmlDict = {
  wr_start: '<div class="csl-bib-body">',
  wr_end: '</div>',
  en_start: '<div class="csl-entry">',
  en_end: '</div>',
  ul_start: '<ul style="list-style-type:none">',
  ul_end: '</ul>',
  li_start: '<li>',
  li_end: '</li>'
};
const textDict = {
  wr_start: '',
  wr_end: '\n',
  en_start: '',
  en_end: '\n',
  ul_start: '\n',
  ul_end: '',
  li_start: '\t',
  li_end: '\n'
};
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/config.js
const configs = {};
const config_add = (ref, config) => {
  configs[ref] = config;
};
const config_get = ref => configs[ref];
const config_has = ref => Object.prototype.hasOwnProperty.call(configs, ref);
const config_remove = ref => {
  delete configs[ref];
};
const config_list = () => Object.keys(configs);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugins/index.js




const registers = {
  input: input_namespaceObject,
  output: output_namespaceObject,
  dict: dict_namespaceObject,
  config: config_namespaceObject
};
const indices = {};
const plugins_add = (ref, plugins = {}) => {
  const mainIndex = indices[ref] = {};

  for (const type in plugins) {
    if (type === 'config') {
      mainIndex.config = {
        [ref]: plugins.config
      };
      registers.config.add(ref, plugins.config);
      continue;
    }

    const typeIndex = mainIndex[type] = {};
    const typePlugins = plugins[type];

    for (const name in typePlugins) {
      const typePlugin = typePlugins[name];
      typeIndex[name] = true;
      registers[type].add(name, typePlugin);
    }
  }
};
const plugins_remove = ref => {
  const mainIndex = indices[ref];

  for (const type in mainIndex) {
    const typeIndex = mainIndex[type];

    for (const name in typeIndex) {
      registers[type].remove(name);
    }
  }

  delete indices[ref];
};
const plugins_has = ref => ref in indices;
const plugins_list = () => Object.keys(indices);

// EXTERNAL MODULE: ./node_modules/@citation-js/core/lib-mjs/util/fetchFile.js
var fetchFile = __webpack_require__(19);

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/stack.js
class TokenStack {
  constructor(array) {
    this.stack = array;
    this.index = 0;
    this.current = this.stack[this.index];
  }

  static getPatternText(pattern) {
    return `"${pattern instanceof RegExp ? pattern.source : pattern}"`;
  }

  static getMatchCallback(pattern) {
    if (Array.isArray(pattern)) {
      const matches = pattern.map(TokenStack.getMatchCallback);
      return token => matches.some(matchCallback => matchCallback(token));
    } else if (pattern instanceof Function) {
      return pattern;
    } else if (pattern instanceof RegExp) {
      return token => pattern.test(token);
    } else {
      return token => pattern === token;
    }
  }

  tokensLeft() {
    return this.stack.length - this.index;
  }

  matches(pattern) {
    return TokenStack.getMatchCallback(pattern)(this.current, this.index, this.stack);
  }

  matchesSequence(sequence) {
    const part = this.stack.slice(this.index, this.index + sequence.length).join('');
    return typeof sequence === 'string' ? part === sequence : sequence.every((pattern, index) => TokenStack.getMatchCallback(pattern)(part[index]));
  }

  consumeToken(pattern = /^[\s\S]$/, {
    inverse = false,
    spaced = true
  } = {}) {
    if (spaced) {
      this.consumeWhitespace();
    }

    const token = this.current;
    const match = TokenStack.getMatchCallback(pattern)(token, this.index, this.stack);

    if (match) {
      this.current = this.stack[++this.index];
    } else {
      throw new SyntaxError(`Unexpected token at index ${this.index}: Expected ${TokenStack.getPatternText(pattern)}, got "${token}"`);
    }

    if (spaced) {
      this.consumeWhitespace();
    }

    return token;
  }

  consumeWhitespace(pattern = /^\s$/, {
    optional = true
  } = {}) {
    return this.consume(pattern, {
      min: +!optional
    });
  }

  consumeN(length) {
    if (this.tokensLeft() < length) {
      throw new SyntaxError('Not enough tokens left');
    }

    const start = this.index;

    while (length--) {
      this.current = this.stack[++this.index];
    }

    return this.stack.slice(start, this.index).join('');
  }

  consumeSequence(sequence) {
    if (this.matchesSequence(sequence)) {
      return this.consumeN(sequence.length);
    } else {
      throw new SyntaxError(`Expected "${sequence}", got "${this.consumeN(sequence.length)}"`);
    }
  }

  consume(pattern = /^[\s\S]$/, {
    min = 0,
    max = Infinity,
    inverse = false,
    tokenMap,
    tokenFilter
  } = {}) {
    const start = this.index;
    const match = TokenStack.getMatchCallback(pattern);

    while (match(this.current, this.index, this.stack) !== inverse) {
      this.current = this.stack[++this.index];
    }

    let consumed = this.stack.slice(start, this.index);

    if (consumed.length < min) {
      throw new SyntaxError(`Not enough ${TokenStack.getPatternText(pattern)}`);
    } else if (consumed.length > max) {
      throw new SyntaxError(`Too many ${TokenStack.getPatternText(pattern)}`);
    }

    if (tokenMap) {
      consumed = consumed.map(tokenMap);
    }

    if (tokenFilter) {
      consumed = consumed.filter(tokenFilter);
    }

    return consumed.join('');
  }

}

/* harmony default export */ var stack = (TokenStack);
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/grammar.js


class grammar_Grammar {
  constructor(rules, state) {
    this.rules = rules;
    this.defaultState = state;
    this.mainRule = Object.keys(rules)[0];
    this.log = [];
  }

  parse(iterator, mainRule) {
    this.lexer = iterator;
    this.token = this.lexer.next();
    this.state = deepCopy(this.defaultState);
    this.log = [];
    return this.consumeRule(mainRule || this.mainRule);
  }

  matchEndOfFile() {
    return !this.token;
  }

  matchToken(type) {
    return this.token && type === this.token.type;
  }

  consumeToken(type, optional) {
    const token = this.token;

    if (!type || token && token.type === type) {
      this.token = this.lexer.next();
      return token;
    } else if (optional) {
      return undefined;
    } else {
      const got = token ? `"${token.type}"` : 'EOF';
      const error = new SyntaxError(this.lexer.formatError(token, `expected "${type}", got ${got}`));
      error.message += ` (${this.log.join('->')})`;
      throw error;
    }
  }

  consumeRule(rule) {
    this.log.push(rule);
    const result = this.rules[rule].call(this);
    this.log.pop();
    return result;
  }

}


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/translator.js
function createConditionEval(condition) {
  return function conditionEval(input) {
    if (typeof condition === 'boolean') {
      return condition;
    }

    return Object.keys(condition).every(prop => {
      const value = condition[prop];

      if (value === true) {
        return prop in input;
      } else if (value === false) {
        return !(prop in input);
      } else if (typeof value === 'function') {
        return value(input[prop]);
      } else if (Array.isArray(value)) {
        return value.includes(input[prop]);
      } else {
        return input[prop] === value;
      }
    });
  };
}

function parsePropStatement(prop, toSource) {
  let inputProp;
  let outputProp;
  let convert;
  let condition;

  if (typeof prop === 'string') {
    inputProp = outputProp = prop;
  } else if (prop) {
    inputProp = toSource ? prop.target : prop.source;
    outputProp = toSource ? prop.source : prop.target;

    if (prop.convert) {
      convert = toSource ? prop.convert.toSource : prop.convert.toTarget;
    }

    if (prop.when) {
      condition = toSource ? prop.when.target : prop.when.source;

      if (condition != null) {
        condition = createConditionEval(condition);
      }
    }
  } else {
    return null;
  }

  inputProp = [].concat(inputProp).filter(Boolean);
  outputProp = [].concat(outputProp).filter(Boolean);
  return {
    inputProp,
    outputProp,
    convert,
    condition
  };
}

function createConverter(props, toSource) {
  toSource = toSource === Translator.CONVERT_TO_SOURCE;
  props = props.map(prop => parsePropStatement(prop, toSource)).filter(Boolean);
  return function converter(input) {
    const output = {};

    for (const {
      inputProp,
      outputProp,
      convert,
      condition
    } of props) {
      if (outputProp.length === 0) {
        continue;
      } else if (condition && !condition(input)) {
        continue;
      } else if (inputProp.length !== 0 && inputProp.every(prop => !(prop in input))) {
        continue;
      }

      let outputData = inputProp.map(prop => input[prop]);

      if (convert) {
        const converted = convert.apply(input, outputData);
        outputData = outputProp.length === 1 ? [converted] : converted;
      }

      outputProp.forEach((prop, index) => {
        const value = outputData[index];

        if (value !== undefined) {
          output[prop] = value;
        }
      });
    }

    return output;
  };
}

class Translator {
  constructor(props) {
    this.convertToSource = createConverter(props, Translator.CONVERT_TO_SOURCE);
    this.convertToTarget = createConverter(props, Translator.CONVERT_TO_TARGET);
  }

}

Translator.CONVERT_TO_SOURCE = Symbol('convert to source');
Translator.CONVERT_TO_TARGET = Symbol('convert to target');

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/util/index.js








// EXTERNAL MODULE: ./node_modules/@citation-js/core/package.json
var core_package = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/empty.js
const parse = () => [];
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/url.js

// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/json.js

const substituters = [[/((?:\[|:|,)\s*)'((?:\\'|[^'])*?[^\\])?'(?=\s*(?:\]|}|,))/g, '$1"$2"'], [/((?:(?:"|]|}|\/[gmiuys]|\.|(?:\d|\.|-)*\d)\s*,|{)\s*)(?:"([^":\n]+?)"|'([^":\n]+?)'|([^":\n]+?))(\s*):/g, '$1"$2$3$4"$5:']];

const parseJSON = function (str) {
  if (typeof str !== 'string') {
    return JSON.parse(str);
  }

  try {
    return JSON.parse(str);
  } catch (e) {
    logger["a" /* default */].debug('[plugin-common]', 'Invalid JSON, switching to experimental parser');
    substituters.forEach(([regex, subst]) => {
      str = str.replace(regex, subst);
    });
    return JSON.parse(str);
  }
};


// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/jquery.js
function jquery_parse(input) {
  return input.val() || input.text() || input.html();
}
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/html.js
function html_parse(input) {
  return input.value || input.textContent;
}
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/input/index.js





const ref = '@else';
const input_parsers = {
  empty: empty_namespaceObject,
  url: url_namespaceObject,
  json: json_namespaceObject,
  jquery: jquery_namespaceObject,
  html: html_namespaceObject
};
const input_formats = {
  '@empty/text': {
    parse: parse,
    parseType: {
      dataType: 'String',
      predicate: input => input === ''
    }
  },
  '@empty/whitespace+text': {
    parse: parse,
    parseType: {
      dataType: 'String',
      predicate: /^\s+$/
    }
  },
  '@empty': {
    parse: parse,
    parseType: {
      dataType: 'Primitive',
      predicate: input => input == null
    }
  },
  '@else/json': {
    parse: parseJSON,
    parseType: {
      dataType: 'String',
      predicate: /^\s*(\{[\S\s]*\}|\[[\S\s]*\])\s*$/
    }
  },
  '@else/url': {
    parse: fetchFile["a" /* fetchFile */],
    parseAsync: fetchFile["b" /* fetchFileAsync */],
    parseType: {
      dataType: 'String',
      predicate: /^https?:\/\/(([\w-]+\.)*[\w-]+)(:\d+)?(\/[^?/]*)*(\?[^#]*)?(#.*)?$/i
    }
  },
  '@else/jquery': {
    parse: jquery_parse,
    parseType: {
      dataType: 'ComplexObject',

      predicate(input) {
        return typeof jQuery !== 'undefined' && input instanceof jQuery;
      }

    }
  },
  '@else/html': {
    parse: html_parse,
    parseType: {
      dataType: 'ComplexObject',

      predicate(input) {
        return typeof HTMLElement !== 'undefined' && input instanceof HTMLElement;
      }

    }
  }
};
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/output/json.js




const appendCommas = (string, index, array) => string + (index < array.length - 1 ? ',' : '');

const getJsonObject = function (src, dict) {
  const isArray = Array.isArray(src);
  let entries;

  if (isArray) {
    entries = src.map(entry => getJsonValue(entry, dict));
  } else {
    entries = Object.keys(src).filter(prop => JSON.stringify(src[prop])).map(prop => `"${prop}": ${getJsonValue(src[prop], dict)}`);
  }

  entries = entries.map(appendCommas).map(entry => dict.listItem.join(entry));
  entries = dict.list.join(entries.join(''));
  return isArray ? `[${entries}]` : `{${entries}}`;
};

const getJsonValue = function (src, dict) {
  if (typeof src === 'object' && src !== null) {
    if (src.length === 0) {
      return '[]';
    } else if (Object.keys(src).length === 0) {
      return '{}';
    } else {
      return getJsonObject(src, dict);
    }
  } else {
    return JSON.stringify(src);
  }
};

const getJson = function (src, dict) {
  let entries = src.map(entry => getJsonObject(entry, dict));
  entries = entries.map(appendCommas).map(entry => dict.entry.join(entry));
  entries = entries.join('');
  return dict.bibliographyContainer.join(`[${entries}]`);
};

function getJsonWrapper(src) {
  return getJson(src, dict_namespaceObject.get('html'));
}
/* harmony default export */ var json = ({
  data(data, {
    type,
    format = type || 'text'
  } = {}) {
    if (format === 'object') {
      return util_deepCopy(data);
    } else if (format === 'text') {
      return JSON.stringify(data, null, 2);
    } else {
      logger["a" /* default */].warn('[core]', 'This feature (JSON output with special formatting) is unstable. See https://github.com/larsgw/citation.js/issues/144');
      return getJson(data, dict_namespaceObject.get(format));
    }
  },

  ndjson(data) {
    return data.map(entry => JSON.stringify(entry)).join('\n');
  }

});
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/output/index.js


/* harmony default export */ var plugin_common_output = (Object.assign({}, json, output_label));
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/plugin-common/index.js



plugins_add(ref, {
  input: input_formats,
  output: plugin_common_output
});
// CONCATENATED MODULE: ./node_modules/@citation-js/core/lib-mjs/index.js








/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Actions */
/* unused harmony export Attr */
/* unused harmony export Attribute */
/* unused harmony export BelongsTo */
/* unused harmony export BelongsToMany */
/* unused harmony export Boolean */
/* unused harmony export Container */
/* unused harmony export Database */
/* unused harmony export Getters */
/* unused harmony export HasMany */
/* unused harmony export HasManyBy */
/* unused harmony export HasManyThrough */
/* unused harmony export HasOne */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Model; });
/* unused harmony export MorphMany */
/* unused harmony export MorphOne */
/* unused harmony export MorphTo */
/* unused harmony export MorphToMany */
/* unused harmony export MorphedByMany */
/* unused harmony export Number */
/* unused harmony export Query */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Relation; });
/* unused harmony export RootActions */
/* unused harmony export RootGetters */
/* unused harmony export RootMutations */
/* unused harmony export String */
/* unused harmony export Type */
/* unused harmony export Uid */
/* unused harmony export install */
/* unused harmony export use */
function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
  : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = {
    version: '2.6.11'
  };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _core_1 = _core.version;

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
}; // Thank's IE8 for his funny defineProperty


var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var document = _global.document; // typeof document.createElement is 'object' in old IE

var is = _isObject(document) && _isObject(document.createElement);

var _domCreate = function (it) {
  return is ? document.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
}); // 7.1.1 ToPrimitive(input [, PreferredType])
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;
var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);

  P = _toPrimitive(P, true);

  _anObject(Attributes);

  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var _objectDp = {
  f: f
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;

var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();

var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode: 'global',
    copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
  });
});

var _functionToString = _shared('native-function-to-string', Function.toString);

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');

  var TO_STRING = 'toString';

  var TPL = ('' + _functionToString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return _functionToString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];

      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || _functionToString.call(this);
  });
});

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
}; // optional / simple context binding


var _ctx = function (fn, that, length) {
  _aFunction(fn);

  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global

    if (target) _redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

_global.core = _core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

var _export = $export;
var toString = {}.toString;

var _cof = function (it) {
  return toString.call(it).slice(8, -1);
}; // fallback for non-array-like ES3 and non-enumerable old V8 strings
// eslint-disable-next-line no-prototype-builtins


var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
}; // 7.2.1 RequireObjectCoercible(argument)


var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
}; // to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function (it) {
  return _iobject(_defined(it));
}; // 7.1.4 ToInteger


var ceil = Math.ceil;
var floor = Math.floor;

var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}; // 7.1.15 ToLength


var min = Math.min;

var _toLength = function (it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;

var _toAbsoluteIndex = function (index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
}; // false -> Array#indexOf
// true  -> Array#includes


var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);

    var length = _toLength(O.length);

    var index = _toAbsoluteIndex(fromIndex, length);

    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
}); // 22.1.3.31 Array.prototype[@@unscopables]


var UNSCOPABLES = _wks('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});

var _addToUnscopables = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
}; // https://github.com/tc39/Array.prototype.includes


var $includes = _arrayIncludes(true);

_export(_export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

_addToUnscopables('includes');

var includes = _core.Array.includes;

var shared = _shared('keys');

var _sharedKey = function (key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);

var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = _toIobject(object);

  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (_has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
}; // IE 8- don't enum bug keys


var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(','); // 19.1.2.14 / 15.2.3.14 Object.keys(O)


var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var f$1 = Object.getOwnPropertySymbols;
var _objectGops = {
  f: f$1
};
var f$2 = {}.propertyIsEnumerable;
var _objectPie = {
  f: f$2
}; // 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
}; // 19.1.2.1 Object.assign(target, source, ...)


var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = _toObject(target);

  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;

  while (aLen > index) {
    var S = _iobject(arguments[index++]);

    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign; // 19.1.3.1 Object.assign(target, source)


_export(_export.S + _export.F, 'Object', {
  assign: _objectAssign
});

var assign = _core.Object.assign;
var isEnum = _objectPie.f;

var _objectToArray = function (isEntries) {
  return function (it) {
    var O = _toIobject(it);

    var keys = _objectKeys(O);

    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!_descriptors || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
}; // https://github.com/tc39/proposal-object-values-entries


var $entries = _objectToArray(true);

_export(_export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

var entries = _core.Object.entries; // https://github.com/tc39/proposal-object-values-entries

var $values = _objectToArray(false);

_export(_export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

var values = _core.Object.values; // 7.2.8 IsRegExp(argument)

var MATCH = _wks('match');

var _isRegexp = function (it) {
  var isRegExp;
  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
}; // helper for String#{startsWith, endsWith, includes}


var _stringContext = function (that, searchString, NAME) {
  if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(_defined(that));
};

var MATCH$1 = _wks('match');

var _failsIsRegexp = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH$1] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

_export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = _stringContext(this, searchString, STARTS_WITH);

    var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));

    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

var startsWith = _core.String.startsWith; // true  -> String#at
// false -> String#codePointAt

var _stringAt = function (TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));

    var i = _toInteger(pos);

    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _iterators = {};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);

  var keys = _objectKeys(Properties);

  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);

  return O;
};

var document$1 = _global.document;

var _html = document$1 && document$1.documentElement; // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


var IE_PROTO$1 = _sharedKey('IE_PROTO');

var Empty = function () {
  /* empty */
};

var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');

  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  _html.appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];

  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO$1] = O;
  } else result = createDict();

  return Properties === undefined ? result : _objectDps(result, Properties);
};

var def = _objectDp.f;

var TAG = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

_hide(IteratorPrototype, _wks('iterator'), function () {
  return this;
});

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, {
    next: _propertyDesc(1, next)
  });

  _setToStringTag(Constructor, NAME + ' Iterator');
}; // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');

var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

var ITERATOR = _wks('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);

  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines


      if (typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if (BUGGY || VALUES_BUG || !proto[ITERATOR]) {
    _hide(proto, ITERATOR, $default);
  } // Plug for library


  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

var $at = _stringAt(true); // 21.1.3.27 String.prototype[@@iterator]()


_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
}); // call something on iterator step with safe closing on error


var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
}; // check on default Array iterator


var ITERATOR$1 = _wks('iterator');

var ArrayProto$1 = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$1] === it);
};

var _createProperty = function (object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
}; // getting tag from 19.1.3.6 Object.prototype.toString()


var TAG$1 = _wks('toStringTag'); // ES3 wrong here


var ARG = _cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T // builtinTag case
  : ARG ? _cof(O) // ES3 arguments fallback
  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var ITERATOR$2 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || _iterators[_classof(it)];
};

var ITERATOR$3 = _wks('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$3]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR$3]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR$3] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = _toObject(arrayLike);

    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);

      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

var from_1 = _core.Array.from;

var Container =
/** @class */
function () {
  function Container() {}
  /**
   * Register the store instance.
   */


  Container.register = function (store) {
    this.store = store;
  };

  return Container;
}();

var install = function (database, options) {
  if (options === void 0) {
    options = {};
  }

  var namespace = options.namespace || 'entities';
  return function (store) {
    database.start(store, namespace);
    Container.register(store);
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */


var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}
/**
 * Check if the given value is the type of array.
 */


function isArray(value) {
  return Array.isArray(value);
}
/**
 * Gets the size of collection by returning its length for array-like values
 * or the number of own enumerable string keyed properties for objects.
 */


function size(collection) {
  return isArray(collection) ? collection.length : Object.keys(collection).length;
}
/**
 * Check if the given array or object is empty.
 */


function isEmpty(collection) {
  return size(collection) === 0;
}
/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property.
 */


function forOwn(object, iteratee) {
  Object.keys(object).forEach(function (key) {
    return iteratee(object[key], key, object);
  });
}
/**
 * Creates an array of values by running each element in collection thru
 * iteratee. The iteratee is invoked with three arguments:
 * (value, key, collection).
 */


function map(object, iteratee) {
  var result = [];

  for (var key in object) {
    result.push(iteratee(object[key], key, object));
  }

  return result;
}
/**
 * Creates an object with the same keys as object and values generated by
 * running each own enumerable string keyed property of object thru
 * iteratee. The iteratee is invoked with three arguments:
 * (value, key, object).
 */


function mapValues(object, iteratee) {
  var newObject = Object.assign({}, object);
  return Object.keys(object).reduce(function (records, key) {
    records[key] = iteratee(object[key], key, object);
    return records;
  }, newObject);
}
/**
 * Creates an object composed of keys generated from the results of running
 * each element of collection by the given key.
 */


function keyBy(collection, key) {
  var o = {};
  collection.forEach(function (item) {
    o[item[key]] = item;
  });
  return o;
}
/**
 * Creates an array of elements, sorted in specified order by the results
 * of running each element in a collection thru each iteratee.
 */


function orderBy(collection, iteratees, directions) {
  var index = -1;
  var result = collection.map(function (value) {
    var criteria = iteratees.map(function (iteratee) {
      return typeof iteratee === 'function' ? iteratee(value) : value[iteratee];
    });
    return {
      criteria: criteria,
      index: ++index,
      value: value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, directions);
  });
}
/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order
 * of equal elements.
 */


function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  var newArray = [];

  while (length--) {
    newArray[length] = array[length].value;
  }

  return newArray;
}
/**
 * Used by `orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order.
 * Otherwise, specify an order of "desc" for descending or "asc" for
 * ascending sort order of corresponding values.
 */


function compareMultiple(object, other, orders) {
  var index = -1;
  var objCriteria = object.criteria;
  var othCriteria = other.criteria;
  var length = objCriteria.length;
  var ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order === 'desc' ? -1 : 1);
    }
  }

  return object.index - other.index;
}
/**
 * Compares values to sort them in ascending order.
 */


function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined;
    var valIsNull = value === null;
    var valIsReflexive = value === value;
    var othIsDefined = other !== undefined;
    var othIsNull = other === null;
    var othIsReflexive = other === other;

    if (typeof value !== 'number' || typeof other !== 'number') {
      value = String(value);
      other = String(other);
    }

    if (!othIsNull && value > other || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && value < other || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}
/**
 * Creates an object composed of keys generated from the results of running
 * each element of collection thru iteratee.
 */


function groupBy(collection, iteratee) {
  return collection.reduce(function (records, record) {
    var key = iteratee(record);

    if (records[key] === undefined) {
      records[key] = [];
    }

    records[key].push(record);
    return records;
  }, {});
}
/**
 * Deep clone the given target object.
 */


function cloneDeep(target) {
  if (target === null) {
    return target;
  }

  if (isArray(target)) {
    var cp_1 = [];
    target.forEach(function (v) {
      return cp_1.push(v);
    });
    return cp_1.map(function (n) {
      return cloneDeep(n);
    });
  }

  if (typeof target === 'object' && target !== {}) {
    var cp_2 = __assign({}, target);

    Object.keys(cp_2).forEach(function (k) {
      return cp_2[k] = cloneDeep(cp_2[k]);
    });
    return cp_2;
  }

  return target;
}

var Utils = {
  isArray: isArray,
  size: size,
  isEmpty: isEmpty,
  forOwn: forOwn,
  map: map,
  mapValues: mapValues,
  keyBy: keyBy,
  orderBy: orderBy,
  groupBy: groupBy,
  cloneDeep: cloneDeep
};

var Uid =
/** @class */
function () {
  function Uid() {}
  /**
   * Generate an UUID.
   */


  Uid.make = function () {
    this.count++;
    return "" + this.prefix + this.count;
  };
  /**
   * Reset the count to 0.
   */


  Uid.reset = function () {
    this.count = 0;
  };
  /**
   * Count to create a unique id.
   */


  Uid.count = 0;
  /**
   * Prefix string to be used for the id.
   */

  Uid.prefix = '$uid';
  return Uid;
}();

var Attribute =
/** @class */
function () {
  /**
   * Create a new attribute instance.
   */
  function Attribute(model) {
    this.model = model;
  }

  return Attribute;
}();

var Type =
/** @class */
function (_super) {
  __extends(Type, _super);
  /**
   * Create a new type instance.
   */


  function Type(model, value, mutator) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;
    /**
     * Whether if the attribute can accept `null` as a value.
     */


    _this.isNullable = false;
    _this.value = value;
    _this.mutator = mutator;
    return _this;
  }
  /**
   * Set `isNullable` to be `true`.
   */


  Type.prototype.nullable = function () {
    this.isNullable = true;
    return this;
  };
  /**
   * Mutate the given value by mutator.
   */


  Type.prototype.mutate = function (value, key) {
    var mutator = this.mutator || this.model.mutators()[key];
    return mutator ? mutator(value) : value;
  };

  return Type;
}(Attribute);

var Attr =
/** @class */
function (_super) {
  __extends(Attr, _super);
  /**
   * Create a new attr instance.
   */


  function Attr(model, value, mutator) {
    /* istanbul ignore next */
    return _super.call(this, model, value, mutator) || this;
  }
  /**
   * Make value to be set to model property. This method is used when
   * instantiating a model or creating a plain object from a model.
   */


  Attr.prototype.make = function (value, _parent, key) {
    value = value !== undefined ? value : this.value; // Default Value might be a function (taking no parameter).

    var localValue = value;

    if (typeof value === 'function') {
      localValue = value();
    }

    return this.mutate(localValue, key);
  };

  return Attr;
}(Type);

var String$1 =
/** @class */
function (_super) {
  __extends(String, _super);
  /**
   * Create a new string instance.
   */


  function String(model, value, mutator) {
    /* istanbul ignore next */
    return _super.call(this, model, value, mutator) || this;
  }
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  String.prototype.make = function (value, _parent, key) {
    return this.mutate(this.fix(value), key);
  };
  /**
   * Convert given value to the string.
   */


  String.prototype.fix = function (value) {
    if (value === undefined) {
      return this.value;
    }

    if (typeof value === 'string') {
      return value;
    }

    if (value === null && this.isNullable) {
      return value;
    }

    return value + '';
  };

  return String;
}(Type);

var Number =
/** @class */
function (_super) {
  __extends(Number, _super);
  /**
   * Create a new number instance.
   */


  function Number(model, value, mutator) {
    /* istanbul ignore next */
    return _super.call(this, model, value, mutator) || this;
  }
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  Number.prototype.make = function (value, _parent, key) {
    return this.mutate(this.fix(value), key);
  };
  /**
   * Transform given data to the number.
   */


  Number.prototype.fix = function (value) {
    if (value === undefined) {
      return this.value;
    }

    if (typeof value === 'number') {
      return value;
    }

    if (typeof value === 'string') {
      return parseFloat(value);
    }

    if (typeof value === 'boolean') {
      return value ? 1 : 0;
    }

    if (value === null && this.isNullable) {
      return value;
    }

    return 0;
  };

  return Number;
}(Type);

var Boolean =
/** @class */
function (_super) {
  __extends(Boolean, _super);
  /**
   * Create a new number instance.
   */


  function Boolean(model, value, mutator) {
    /* istanbul ignore next */
    return _super.call(this, model, value, mutator) || this;
  }
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  Boolean.prototype.make = function (value, _parent, key) {
    return this.mutate(this.fix(value), key);
  };
  /**
   * Transform given data to the boolean.
   */


  Boolean.prototype.fix = function (value) {
    if (value === undefined) {
      return this.value;
    }

    if (typeof value === 'boolean') {
      return value;
    }

    if (typeof value === 'string') {
      if (value.length === 0) {
        return false;
      }

      var int = parseInt(value, 0);
      return isNaN(int) ? true : !!int;
    }

    if (typeof value === 'number') {
      return !!value;
    }

    if (value === null && this.isNullable) {
      return value;
    }

    return false;
  };

  return Boolean;
}(Type);

var Uid$1 =
/** @class */
function (_super) {
  __extends(Uid$1, _super);
  /**
   * Create a new uid instance.
   */


  function Uid$1(model, value) {
    /* istanbul ignore next */
    return _super.call(this, model, value) || this;
  }
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  Uid$1.prototype.make = function (value) {
    if (typeof value === 'number' || typeof value === 'string') {
      return value;
    }

    if (typeof this.value === 'function') {
      return this.value();
    }

    return Uid.make();
  };

  return Uid$1;
}(Type);

var Relation =
/** @class */
function (_super) {
  __extends(Relation, _super);

  function Relation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * Get relation query instance with constraint attached.
   */


  Relation.prototype.getRelation = function (query, name, constraints) {
    var relation = query.newQuery(name);
    constraints.forEach(function (constraint) {
      constraint(relation);
    });
    return relation;
  };
  /**
   * Get specified keys from the given collection.
   */


  Relation.prototype.getKeys = function (collection, key) {
    return collection.reduce(function (models, model) {
      if (model[key] === null || model[key] === undefined) {
        return models;
      }

      models.push(model[key]);
      return models;
    }, []);
  };
  /**
   * Create a new indexed map for the single relation by specified key.
   */


  Relation.prototype.mapSingleRelations = function (collection, key) {
    var relations = new Map();
    collection.forEach(function (record) {
      var id = record[key];
      !relations.get(id) && relations.set(id, record);
    });
    return relations;
  };
  /**
   * Create a new indexed map for the many relation by specified key.
   */


  Relation.prototype.mapManyRelations = function (collection, key) {
    var relations = new Map();
    collection.forEach(function (record) {
      var id = record[key];
      var ownerKeys = relations.get(id);

      if (!ownerKeys) {
        ownerKeys = [];
        relations.set(id, ownerKeys);
      }

      ownerKeys.push(record);
    });
    return relations;
  };
  /**
   * Create a new indexed map for relations with order constraints.
   */


  Relation.prototype.mapRelationsByOrders = function (collection, relations, ownerKey, relationKey) {
    var records = {};
    relations.forEach(function (related, id) {
      collection.filter(function (record) {
        return record[relationKey] === id;
      }).forEach(function (record) {
        var id = record[ownerKey];

        if (!records[id]) {
          records[id] = [];
        }

        records[id] = records[id].concat(related);
      });
    });
    return records;
  };
  /**
   * Check if the given record is a single relation, which is an object.
   */


  Relation.prototype.isOneRelation = function (record) {
    if (!isArray(record) && record !== null && typeof record === 'object') {
      return true;
    }

    return false;
  };
  /**
   * Check if the given records is a many relation, which is an array
   * of object.
   */


  Relation.prototype.isManyRelation = function (records) {
    if (!isArray(records)) {
      return false;
    }

    if (records.length < 1) {
      return false;
    }

    return true;
  };
  /**
   * Wrap the given object into a model instance.
   */


  Relation.prototype.makeOneRelation = function (record, model) {
    if (!this.isOneRelation(record)) {
      return null;
    }

    var relatedModel = model.getModelFromRecord(record) || model;
    return new relatedModel(record);
  };
  /**
   * Wrap the given records into a collection of model instances.
   */


  Relation.prototype.makeManyRelation = function (records, model) {
    var _this = this;

    if (!this.isManyRelation(records)) {
      return [];
    }

    return records.filter(function (record) {
      return _this.isOneRelation(record);
    }).map(function (record) {
      var relatedModel = model.getModelFromRecord(record) || model;
      return new relatedModel(record);
    });
  };

  return Relation;
}(Attribute);

var HasOne =
/** @class */
function (_super) {
  __extends(HasOne, _super);
  /**
   * Create a new has one instance.
   */


  function HasOne(model, related, foreignKey, localKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.related = _this.model.relation(related);
    _this.foreignKey = foreignKey;
    _this.localKey = localKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  HasOne.prototype.define = function (schema) {
    return schema.one(this.related);
  };
  /**
   * Attach the relational key to the related data. For example,
   * when User has one Phone, it will attach value to the
   * `user_id` field of Phone record.
   */


  HasOne.prototype.attach = function (key, record, data) {
    // Check if the record has local key set. If not, set the local key to be
    // the id value. This happens if the user defines the custom local key
    // and didn't include it in the data being normalized.
    if (!record[this.localKey]) {
      record[this.localKey] = this.model.getIndexIdFromRecord(record);
    } // Then set the foreign key of the related record if it exists to be the
    // local key of this record.


    var related = data[this.related.entity] && data[this.related.entity][key];

    if (related) {
      related[this.foreignKey] = record[this.localKey];
    }
  };
  /**
   * Make value to be set to model property. This method is used when
   * instantiating a model or creating a plain object from a model.
   */


  HasOne.prototype.make = function (value, _parent, _key) {
    return this.makeOneRelation(value, this.related);
  };
  /**
   * Load the has one relationship for the collection.
   */


  HasOne.prototype.load = function (query, collection, name, constraints) {
    var relation = this.getRelation(query, this.related.entity, constraints);
    this.addEagerConstraints(relation, collection);
    this.match(collection, relation.get(), name);
  };
  /**
   * Set the constraints for an eager load of the relation.
   */


  HasOne.prototype.addEagerConstraints = function (relation, collection) {
    relation.whereFk(this.foreignKey, this.getKeys(collection, this.localKey));
  };
  /**
   * Match the eagerly loaded results to their parents.
   */


  HasOne.prototype.match = function (collection, relations, name) {
    var _this = this;

    var dictionary = this.buildDictionary(relations);
    collection.forEach(function (model) {
      var id = model[_this.localKey];
      var relation = dictionary[id];
      model[name] = relation || null;
    });
  };
  /**
   * Build model dictionary keyed by the relation's foreign key.
   */


  HasOne.prototype.buildDictionary = function (relations) {
    var _this = this;

    return relations.reduce(function (dictionary, relation) {
      var key = relation[_this.foreignKey];
      dictionary[key] = relation;
      return dictionary;
    }, {});
  };

  return HasOne;
}(Relation);

var BelongsTo =
/** @class */
function (_super) {
  __extends(BelongsTo, _super);
  /**
   * Create a new belongs to instance.
   */


  function BelongsTo(model, parent, foreignKey, ownerKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.parent = _this.model.relation(parent);
    _this.foreignKey = foreignKey;
    _this.ownerKey = ownerKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  BelongsTo.prototype.define = function (schema) {
    return schema.one(this.parent);
  };
  /**
   * Attach the relational key to the given data. For example, when Post
   * belongs to User, it will attach value to the `user_id` field of
   * Post record.
   */


  BelongsTo.prototype.attach = function (key, record, data) {
    // See if the record has the foreign key, if yes, it means the user has
    // provided the key explicitly so do nothing and return.
    if (record[this.foreignKey] !== undefined) {
      return;
    } // If there is no foreign key, let's set it here.


    record[this.foreignKey] = data[this.parent.entity] && data[this.parent.entity][key] ? data[this.parent.entity][key][this.ownerKey] : key;
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  BelongsTo.prototype.make = function (value, _parent, _key) {
    return this.makeOneRelation(value, this.parent);
  };
  /**
   * Load the belongs to relationship for the collection.
   */


  BelongsTo.prototype.load = function (query, collection, name, constraints) {
    var relation = this.getRelation(query, this.parent.entity, constraints);
    this.addEagerConstraints(relation, collection);
    this.match(collection, relation.get(), name);
  };
  /**
   * Set the constraints for an eager load of the relation.
   */


  BelongsTo.prototype.addEagerConstraints = function (relation, collection) {
    relation.whereFk(this.ownerKey, this.getKeys(collection, this.foreignKey));
  };
  /**
   * Match the eagerly loaded results to their parents.
   */


  BelongsTo.prototype.match = function (collection, relations, name) {
    var _this = this;

    var dictionary = this.buildDictionary(relations);
    collection.forEach(function (model) {
      var id = model[_this.foreignKey];
      var relation = id !== null ? dictionary[id] : null;
      model[name] = relation || null;
    });
  };
  /**
   * Build model dictionary keyed by the relation's foreign key.
   */


  BelongsTo.prototype.buildDictionary = function (relations) {
    var _this = this;

    return relations.reduce(function (dictionary, relation) {
      var key = relation[_this.ownerKey];
      dictionary[key] = relation;
      return dictionary;
    }, {});
  };

  return BelongsTo;
}(Relation);

var HasMany =
/** @class */
function (_super) {
  __extends(HasMany, _super);
  /**
   * Create a new has many instance.
   */


  function HasMany(model, related, foreignKey, localKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.related = _this.model.relation(related);
    _this.foreignKey = foreignKey;
    _this.localKey = localKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  HasMany.prototype.define = function (schema) {
    return schema.many(this.related);
  };
  /**
   * Attach the relational key to the given data.
   */


  HasMany.prototype.attach = function (key, record, data) {
    var _this = this;

    key.forEach(function (index) {
      var related = data[_this.related.entity];

      if (!related || !related[index] || related[index][_this.foreignKey] !== undefined) {
        return;
      }

      related[index][_this.foreignKey] = record[_this.localKey];
    });
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  HasMany.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.related);
  };
  /**
   * Load the has many relationship for the collection.
   */


  HasMany.prototype.load = function (query, collection, name, constraints) {
    var relation = this.getRelation(query, this.related.entity, constraints);
    this.addEagerConstraints(relation, collection);
    this.match(collection, relation.get(), name);
  };
  /**
   * Set the constraints for an eager load of the relation.
   */


  HasMany.prototype.addEagerConstraints = function (relation, collection) {
    relation.whereFk(this.foreignKey, this.getKeys(collection, this.localKey));
  };
  /**
   * Match the eagerly loaded results to their parents.
   */


  HasMany.prototype.match = function (collection, relations, name) {
    var _this = this;

    var dictionary = this.buildDictionary(relations);
    collection.forEach(function (model) {
      var id = model[_this.localKey];
      var relation = dictionary[id];
      model[name] = relation || [];
    });
  };
  /**
   * Build model dictionary keyed by the relation's foreign key.
   */


  HasMany.prototype.buildDictionary = function (relations) {
    var _this = this;

    return relations.reduce(function (dictionary, relation) {
      var key = relation[_this.foreignKey];

      if (!dictionary[key]) {
        dictionary[key] = [];
      }

      dictionary[key].push(relation);
      return dictionary;
    }, {});
  };

  return HasMany;
}(Relation);

var HasManyBy =
/** @class */
function (_super) {
  __extends(HasManyBy, _super);
  /**
   * Create a new has many by instance.
   */


  function HasManyBy(model, parent, foreignKey, ownerKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.parent = _this.model.relation(parent);
    _this.foreignKey = foreignKey;
    _this.ownerKey = ownerKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  HasManyBy.prototype.define = function (schema) {
    return schema.many(this.parent);
  };
  /**
   * Attach the relational key to the given data.
   */


  HasManyBy.prototype.attach = function (key, record, _data) {
    var _this = this;

    if (key.length === 0) {
      return;
    }

    record[this.foreignKey] = key.map(function (parentId) {
      return _this.parent.getIdFromRecord(_data[_this.parent.entity][parentId]);
    });
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  HasManyBy.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.parent);
  };
  /**
   * Load the has many by relationship for the collection.
   */


  HasManyBy.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.parent.entity, constraints);
    this.addConstraintForHasManyBy(relatedQuery, collection);
    var relations = this.mapSingleRelations(relatedQuery.get(), this.ownerKey);
    collection.forEach(function (item) {
      var related = _this.getRelatedRecords(relations, item[_this.foreignKey]);

      item[name] = related;
    });
  };
  /**
   * Set the constraints for an eager load of the relation.
   */


  HasManyBy.prototype.addConstraintForHasManyBy = function (query, collection) {
    var _this = this;

    var keys = collection.reduce(function (keys, item) {
      return keys.concat(item[_this.foreignKey]);
    }, []);
    query.where(this.ownerKey, keys);
  };
  /**
   * Get related records.
   */


  HasManyBy.prototype.getRelatedRecords = function (relations, keys) {
    var records = [];
    relations.forEach(function (record, id) {
      if (keys.indexOf(id) !== -1) {
        records.push(record);
      }
    });
    return records;
  };

  return HasManyBy;
}(Relation);

var HasManyThrough =
/** @class */
function (_super) {
  __extends(HasManyThrough, _super);
  /**
   * Create a new has many through instance.
   */


  function HasManyThrough(model, related, through, firstKey, secondKey, localKey, secondLocalKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.related = _this.model.relation(related);
    _this.through = _this.model.relation(through);
    _this.firstKey = firstKey;
    _this.secondKey = secondKey;
    _this.localKey = localKey;
    _this.secondLocalKey = secondLocalKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  HasManyThrough.prototype.define = function (schema) {
    return schema.many(this.related);
  };
  /**
   * Attach the relational key to the given data. Since has many through
   * relationship doesn't have any foreign key, it would do nothing.
   */


  HasManyThrough.prototype.attach = function (_key, _record, _data) {
    return;
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  HasManyThrough.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.related);
  };
  /**
   * Load the has many through relationship for the collection.
   */


  HasManyThrough.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.related.entity, constraints);
    var throughQuery = query.newQuery(this.through.entity);
    this.addEagerConstraintForThrough(throughQuery, collection);
    var throughs = throughQuery.get();
    this.addEagerConstraintForRelated(relatedQuery, throughs);
    var relateds = this.mapThroughRelations(throughs, relatedQuery);
    collection.forEach(function (item) {
      var related = relateds[item[_this.localKey]];
      item[name] = related || [];
    });
  };
  /**
   * Set the constraints for the through relation.
   */


  HasManyThrough.prototype.addEagerConstraintForThrough = function (query, collection) {
    query.where(this.firstKey, this.getKeys(collection, this.localKey));
  };
  /**
   * Set the constraints for the related relation.
   */


  HasManyThrough.prototype.addEagerConstraintForRelated = function (query, collection) {
    query.where(this.secondKey, this.getKeys(collection, this.secondLocalKey));
  };
  /**
   * Create a new indexed map for the through relation.
   */


  HasManyThrough.prototype.mapThroughRelations = function (throughs, relatedQuery) {
    var _this = this;

    var relations = this.mapManyRelations(relatedQuery.get(), this.secondKey);
    return throughs.reduce(function (records, record) {
      var id = record[_this.firstKey];

      if (!records[id]) {
        records[id] = [];
      }

      var related = relations.get(record[_this.secondLocalKey]);

      if (related === undefined) {
        return records;
      }

      records[id] = records[id].concat(related);
      return records;
    }, {});
  };

  return HasManyThrough;
}(Relation);

var BelongsToMany =
/** @class */
function (_super) {
  __extends(BelongsToMany, _super);
  /**
   * Create a new belongs to instance.
   */


  function BelongsToMany(model, related, pivot, foreignPivotKey, relatedPivotKey, parentKey, relatedKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;
    /**
     * The key name of the pivot data.
     */


    _this.pivotKey = 'pivot';
    _this.related = _this.model.relation(related);
    _this.pivot = _this.model.relation(pivot);
    _this.foreignPivotKey = foreignPivotKey;
    _this.relatedPivotKey = relatedPivotKey;
    _this.parentKey = parentKey;
    _this.relatedKey = relatedKey;
    return _this;
  }
  /**
   * Specify the custom pivot accessor to use for the relationship.
   */


  BelongsToMany.prototype.as = function (accessor) {
    this.pivotKey = accessor;
    return this;
  };
  /**
   * Define the normalizr schema for the relationship.
   */


  BelongsToMany.prototype.define = function (schema) {
    return schema.many(this.related);
  };
  /**
   * Attach the relational key to the given data. Since belongs to many
   * relationship doesn't have any foreign key, it would do nothing.
   */


  BelongsToMany.prototype.attach = function (_key, _record, _data) {
    return;
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  BelongsToMany.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.related);
  };
  /**
   * Load the belongs to relationship for the record.
   */


  BelongsToMany.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.related.entity, constraints);
    var pivotQuery = query.newQuery(this.pivot.entity);
    this.addEagerConstraintForPivot(pivotQuery, collection);
    var pivots = pivotQuery.get();
    this.addEagerConstraintForRelated(relatedQuery, pivots);
    var relateds = this.mapPivotRelations(pivots, relatedQuery);
    collection.forEach(function (item) {
      var related = relateds[item[_this.parentKey]];
      item[name] = related || [];
    });
  };
  /**
   * Set the constraints for the pivot relation.
   */


  BelongsToMany.prototype.addEagerConstraintForPivot = function (query, collection) {
    query.whereFk(this.foreignPivotKey, this.getKeys(collection, this.parentKey));
  };
  /**
   * Set the constraints for the related relation.
   */


  BelongsToMany.prototype.addEagerConstraintForRelated = function (query, collection) {
    query.whereFk(this.relatedKey, this.getKeys(collection, this.relatedPivotKey));
  };
  /**
   * Create a new indexed map for the pivot relation.
   */


  BelongsToMany.prototype.mapPivotRelations = function (pivots, relatedQuery) {
    var _this = this;

    var relations = this.mapManyRelations(relatedQuery.get(), this.relatedKey);

    if (relatedQuery.orders.length) {
      return this.mapRelationsByOrders(pivots, relations, this.foreignPivotKey, this.relatedPivotKey);
    }

    return pivots.reduce(function (records, record) {
      var id = record[_this.foreignPivotKey];

      if (!records[id]) {
        records[id] = [];
      }

      var related = relations.get(record[_this.relatedPivotKey]);

      if (related) {
        records[id] = records[id].concat(related.map(function (model) {
          model[_this.pivotKey] = record;
          return model;
        }));
      }

      return records;
    }, {});
  };
  /**
   * Create pivot records for the given records if needed.
   */


  BelongsToMany.prototype.createPivots = function (parent, data, key) {
    var _this = this;

    if (!Utils.isArray(this.pivot.primaryKey)) return data;
    Utils.forOwn(data[parent.entity], function (record) {
      var related = record[key];

      if (related === undefined || related.length === 0) {
        return;
      }

      _this.createPivotRecord(data, record, related);
    });
    return data;
  };
  /**
   * Create a pivot record.
   */


  BelongsToMany.prototype.createPivotRecord = function (data, record, related) {
    var _this = this;

    related.forEach(function (id) {
      var _a, _b;

      var parentId = record[_this.parentKey];
      var relatedId = data[_this.related.entity][id][_this.relatedKey];
      var pivotKey = JSON.stringify([_this.pivot.primaryKey[0] === _this.foreignPivotKey ? parentId : relatedId, _this.pivot.primaryKey[1] === _this.foreignPivotKey ? parentId : relatedId]);
      var pivotRecord = data[_this.pivot.entity] ? data[_this.pivot.entity][pivotKey] : {};
      var pivotData = data[_this.related.entity][id][_this.pivotKey] || {};
      data[_this.pivot.entity] = __assign(__assign({}, data[_this.pivot.entity]), (_a = {}, _a[pivotKey] = __assign(__assign(__assign({}, pivotRecord), pivotData), (_b = {
        $id: pivotKey
      }, _b[_this.foreignPivotKey] = parentId, _b[_this.relatedPivotKey] = relatedId, _b)), _a));
    });
  };

  return BelongsToMany;
}(Relation);

var MorphTo =
/** @class */
function (_super) {
  __extends(MorphTo, _super);
  /**
   * Create a new morph to instance.
   */


  function MorphTo(model, id, type) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.id = id;
    _this.type = type;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  MorphTo.prototype.define = function (schema) {
    var _this = this;

    return schema.union(function (_value, parentValue) {
      return parentValue[_this.type];
    });
  };
  /**
   * Attach the relational key to the given record. Since morph to
   * relationship doesn't have any foreign key, it would do nothing.
   */


  MorphTo.prototype.attach = function (_key, _record, _data) {
    return;
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  MorphTo.prototype.make = function (value, parent, _key) {
    var related = parent[this.type];

    try {
      var model = this.model.relation(related);
      return this.makeOneRelation(value, model);
    } catch (_a) {
      return null;
    }
  };
  /**
   * Load the morph to relationship for the collection.
   */


  MorphTo.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var types = this.getTypes(collection);
    var relations = types.reduce(function (related, type) {
      var relatedQuery = _this.getRelation(query, type, constraints);

      related[type] = _this.mapSingleRelations(relatedQuery.get(), '$id');
      return related;
    }, {});
    collection.forEach(function (item) {
      var id = item[_this.id];
      var type = item[_this.type];
      var related = relations[type].get(String(id));
      item[name] = related || null;
    });
  };
  /**
   * Get all types from the collection.
   */


  MorphTo.prototype.getTypes = function (collection) {
    var _this = this;

    return collection.reduce(function (types, item) {
      var type = item[_this.type];
      !types.includes(type) && types.push(type);
      return types;
    }, []);
  };

  return MorphTo;
}(Relation);

var MorphOne =
/** @class */
function (_super) {
  __extends(MorphOne, _super);
  /**
   * Create a new belongs to instance.
   */


  function MorphOne(model, related, id, type, localKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.related = _this.model.relation(related);
    _this.id = id;
    _this.type = type;
    _this.localKey = localKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  MorphOne.prototype.define = function (schema) {
    return schema.one(this.related);
  };
  /**
   * Attach the relational key to the given data.
   */


  MorphOne.prototype.attach = function (key, record, data) {
    var relatedRecord = data[this.related.entity][key];
    relatedRecord[this.id] = relatedRecord[this.id] || this.related.getIdFromRecord(record);
    relatedRecord[this.type] = relatedRecord[this.type] || this.model.entity;
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  MorphOne.prototype.make = function (value, _parent, _key) {
    return this.makeOneRelation(value, this.related);
  };
  /**
   * Load the morph many relationship for the record.
   */


  MorphOne.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.related.entity, constraints);
    this.addEagerConstraintForMorphOne(relatedQuery, collection, query.entity);
    var relations = this.mapSingleRelations(relatedQuery.get(), this.id);
    collection.forEach(function (item) {
      var related = relations.get(item[_this.localKey]);
      item[name] = related || null;
    });
  };
  /**
   * Set the constraints for an eager load of the relation.
   */


  MorphOne.prototype.addEagerConstraintForMorphOne = function (query, collection, type) {
    query.whereFk(this.type, type).whereFk(this.id, this.getKeys(collection, this.localKey));
  };

  return MorphOne;
}(Relation);

var MorphMany =
/** @class */
function (_super) {
  __extends(MorphMany, _super);
  /**
   * Create a new belongs to instance.
   */


  function MorphMany(model, related, id, type, localKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;

    _this.related = _this.model.relation(related);
    _this.id = id;
    _this.type = type;
    _this.localKey = localKey;
    return _this;
  }
  /**
   * Define the normalizr schema for the relationship.
   */


  MorphMany.prototype.define = function (schema) {
    return schema.many(this.related);
  };
  /**
   * Attach the relational key to the given data.
   */


  MorphMany.prototype.attach = function (key, record, data) {
    var _this = this;

    var relatedItems = data[this.related.entity];
    key.forEach(function (id) {
      var relatedItem = relatedItems[id];
      relatedItem[_this.id] = relatedItem[_this.id] || _this.related.getIdFromRecord(record);
      relatedItem[_this.type] = relatedItem[_this.type] || _this.model.entity;
    });
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  MorphMany.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.related);
  };
  /**
   * Load the morph many relationship for the record.
   */


  MorphMany.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.related.entity, constraints);
    this.addEagerConstraintForMorphMany(relatedQuery, collection, query.entity);
    var relations = this.mapManyRelations(relatedQuery.get(), this.id);
    collection.forEach(function (item) {
      var related = relations.get(item[_this.localKey]);
      item[name] = related || [];
    });
  };
  /**
   * Set the constraints for an eager load of the relation.
   */


  MorphMany.prototype.addEagerConstraintForMorphMany = function (query, collection, type) {
    query.whereFk(this.type, type).whereFk(this.id, this.getKeys(collection, this.localKey));
  };

  return MorphMany;
}(Relation);

var MorphToMany =
/** @class */
function (_super) {
  __extends(MorphToMany, _super);
  /**
   * Create a new belongs to instance.
   */


  function MorphToMany(model, related, pivot, relatedId, id, type, parentKey, relatedKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;
    /**
     * The key name of the pivot data.
     */


    _this.pivotKey = 'pivot';
    _this.related = _this.model.relation(related);
    _this.pivot = _this.model.relation(pivot);
    _this.relatedId = relatedId;
    _this.id = id;
    _this.type = type;
    _this.parentKey = parentKey;
    _this.relatedKey = relatedKey;
    return _this;
  }
  /**
   * Specify the custom pivot accessor to use for the relationship.
   */


  MorphToMany.prototype.as = function (accessor) {
    this.pivotKey = accessor;
    return this;
  };
  /**
   * Define the normalizr schema for the relationship.
   */


  MorphToMany.prototype.define = function (schema) {
    return schema.many(this.related);
  };
  /**
   * Attach the relational key to the given record. Since morph to many
   * relationship doesn't have any foreign key, it would do nothing.
   */


  MorphToMany.prototype.attach = function (_key, _record, _data) {
    return;
  };
  /**
   * Convert given value to the appropriate value for the attribute.
   */


  MorphToMany.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.related);
  };
  /**
   * Load the morph to many relationship for the collection.
   */


  MorphToMany.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.related.entity, constraints);
    var pivotQuery = query.newQuery(this.pivot.entity);
    this.addEagerConstraintForPivot(pivotQuery, collection, query.entity);
    var pivots = pivotQuery.get();
    this.addEagerConstraintForRelated(relatedQuery, pivots);
    var relateds = this.mapPivotRelations(pivots, relatedQuery);
    collection.forEach(function (item) {
      var related = relateds[item[_this.parentKey]];
      item[name] = related || [];
    });
  };
  /**
   * Set the constraints for the pivot relation.
   */


  MorphToMany.prototype.addEagerConstraintForPivot = function (query, collection, type) {
    query.whereFk(this.type, type).whereFk(this.id, this.getKeys(collection, this.parentKey));
  };
  /**
   * Set the constraints for the related relation.
   */


  MorphToMany.prototype.addEagerConstraintForRelated = function (query, collection) {
    query.whereFk(this.relatedKey, this.getKeys(collection, this.relatedId));
  };
  /**
   * Create a new indexed map for the pivot relation.
   */


  MorphToMany.prototype.mapPivotRelations = function (pivots, relatedQuery) {
    var _this = this;

    var relations = this.mapManyRelations(relatedQuery.get(), this.relatedKey);

    if (relatedQuery.orders.length) {
      return this.mapRelationsByOrders(pivots, relations, this.id, this.relatedId);
    }

    return pivots.reduce(function (records, record) {
      var id = record[_this.id];

      if (!records[id]) {
        records[id] = [];
      }

      var related = relations.get(record[_this.relatedId]);
      /* istanbul ignore if */

      if (related === undefined || related.length === 0) {
        return records;
      }

      records[id] = records[id].concat(related.map(function (model) {
        model[_this.pivotKey] = record;
        return model;
      }));
      return records;
    }, {});
  };
  /**
   * Create pivot records for the given records if needed.
   */


  MorphToMany.prototype.createPivots = function (parent, data, key) {
    var _this = this;

    Utils.forOwn(data[parent.entity], function (record) {
      var relatedIds = parent.query().newQuery(_this.pivot.entity).where(_this.id, record[_this.parentKey]).where(_this.type, parent.entity).get();
      var relateds = (record[key] || []).filter(function (relatedId) {
        return !relatedIds.includes(relatedId);
      });

      if (!Utils.isArray(relateds) || relateds.length === 0) {
        return;
      }

      _this.createPivotRecord(parent, data, record, relateds);
    });
    return data;
  };
  /**
   * Create a pivot record.
   */


  MorphToMany.prototype.createPivotRecord = function (parent, data, record, related) {
    var _this = this;

    related.forEach(function (id) {
      var _a, _b;

      var parentId = record[_this.parentKey];
      var relatedId = data[_this.related.entity][id][_this.relatedKey];
      var pivotKey = parentId + "_" + id + "_" + parent.entity;
      var pivotData = data[_this.related.entity][id][_this.pivotKey] || {};
      data[_this.pivot.entity] = __assign(__assign({}, data[_this.pivot.entity]), (_a = {}, _a[pivotKey] = __assign(__assign({}, pivotData), (_b = {
        $id: pivotKey
      }, _b[_this.relatedId] = relatedId, _b[_this.id] = parentId, _b[_this.type] = parent.entity, _b)), _a));
    });
  };

  return MorphToMany;
}(Relation);

var MorphedByMany =
/** @class */
function (_super) {
  __extends(MorphedByMany, _super);
  /**
   * Create a new belongs to instance.
   */


  function MorphedByMany(model, related, pivot, relatedId, id, type, parentKey, relatedKey) {
    var _this = _super.call(this, model)
    /* istanbul ignore next */
    || this;
    /**
     * The key name of the pivot data.
     */


    _this.pivotKey = 'pivot';
    _this.related = _this.model.relation(related);
    _this.pivot = _this.model.relation(pivot);
    _this.relatedId = relatedId;
    _this.id = id;
    _this.type = type;
    _this.parentKey = parentKey;
    _this.relatedKey = relatedKey;
    return _this;
  }
  /**
   * Specify the custom pivot accessor to use for the relationship.
   */


  MorphedByMany.prototype.as = function (accessor) {
    this.pivotKey = accessor;
    return this;
  };
  /**
   * Define the normalizr schema for the relationship.
   */


  MorphedByMany.prototype.define = function (schema) {
    return schema.many(this.related);
  };
  /**
   * Attach the relational key to the given data. Since morphed by many
   * relationship doesn't have any foreign key, it would do nothing.
   */


  MorphedByMany.prototype.attach = function (_key, _record, _data) {
    return;
  };
  /**
   * Make value to be set to model property. This method is used when
   * instantiating a model or creating a plain object from a model.
   */


  MorphedByMany.prototype.make = function (value, _parent, _key) {
    return this.makeManyRelation(value, this.related);
  };
  /**
   * Load the morph many relationship for the record.
   */


  MorphedByMany.prototype.load = function (query, collection, name, constraints) {
    var _this = this;

    var relatedQuery = this.getRelation(query, this.related.entity, constraints);
    var pivotQuery = query.newQuery(this.pivot.entity);
    this.addEagerConstraintForPivot(pivotQuery, collection, this.related.entity);
    var pivots = pivotQuery.get();
    this.addEagerConstraintForRelated(relatedQuery, pivots);
    var relateds = this.mapPivotRelations(pivots, relatedQuery);
    collection.forEach(function (item) {
      var related = relateds[item[_this.parentKey]];
      item[name] = related || [];
    });
  };
  /**
   * Set the constraints for the pivot relation.
   */


  MorphedByMany.prototype.addEagerConstraintForPivot = function (query, collection, type) {
    query.whereFk(this.type, type).whereFk(this.relatedId, this.getKeys(collection, this.parentKey));
  };
  /**
   * Set the constraints for the related relation.
   */


  MorphedByMany.prototype.addEagerConstraintForRelated = function (query, collection) {
    query.whereFk(this.relatedKey, this.getKeys(collection, this.id));
  };
  /**
   * Create a new indexed map for the pivot relation.
   */


  MorphedByMany.prototype.mapPivotRelations = function (pivots, relatedQuery) {
    var _this = this;

    var relations = this.mapManyRelations(relatedQuery.get(), this.relatedKey);

    if (relatedQuery.orders.length) {
      return this.mapRelationsByOrders(pivots, relations, this.relatedId, this.id);
    }

    return pivots.reduce(function (records, record) {
      var id = record[_this.relatedId];

      if (!records[id]) {
        records[id] = [];
      }

      var related = relations.get(record[_this.id]);
      /* istanbul ignore if */

      if (related === undefined || related.length === 0) {
        return records;
      }

      records[id] = records[id].concat(related.map(function (model) {
        model[_this.pivotKey] = record;
        return model;
      }));
      return records;
    }, {});
  };
  /**
   * Create pivot records for the given records if needed.
   */


  MorphedByMany.prototype.createPivots = function (parent, data, key) {
    var _this = this;

    Utils.forOwn(data[parent.entity], function (record) {
      var related = record[key];

      if (!Utils.isArray(related)) {
        return;
      }

      _this.createPivotRecord(data, record, related);
    });
    return data;
  };
  /**
   * Create a pivot record.
   */


  MorphedByMany.prototype.createPivotRecord = function (data, record, related) {
    var _this = this;

    related.forEach(function (id) {
      var _a, _b;

      var parentId = record[_this.parentKey];
      var pivotKey = id + "_" + parentId + "_" + _this.related.entity;
      var pivotData = data[_this.related.entity][id][_this.pivotKey] || {};
      data[_this.pivot.entity] = __assign(__assign({}, data[_this.pivot.entity]), (_a = {}, _a[pivotKey] = __assign(__assign({}, pivotData), (_b = {
        $id: pivotKey
      }, _b[_this.relatedId] = parentId, _b[_this.id] = _this.model.getIdFromRecord(data[_this.related.entity][id]), _b[_this.type] = _this.related.entity, _b)), _a));
    });
  };

  return MorphedByMany;
}(Relation);

var defaultOption = {
  relations: true
};
/**
 * Serialize the given model to attributes. This method will ignore
 * relationships, and it includes the index id.
 */

function toAttributes(model) {
  var record = toJson(model, {
    relations: false
  });
  record.$id = model.$id;
  return record;
}
/**
 * Serialize given model POJO.
 */


function toJson(model, option) {
  if (option === void 0) {
    option = {};
  }

  option = __assign(__assign({}, defaultOption), option);
  var record = {};
  var fields = model.$fields();

  for (var key in fields) {
    var f = fields[key];
    var v = model[key];

    if (f instanceof Relation) {
      record[key] = option.relations ? relation(v) : emptyRelation(v);
      continue;
    }

    record[key] = value(model[key]);
  }

  return record;
}
/**
 * Serialize given value.
 */


function value(v) {
  if (v === null) {
    return null;
  }

  if (isArray(v)) {
    return array(v);
  }

  if (typeof v === 'object') {
    return object(v);
  }

  return v;
}
/**
 * Serialize an array into json.
 */


function array(a) {
  return a.map(function (v) {
    return value(v);
  });
}
/**
 * Serialize an object into json.
 */


function object(o) {
  var obj = {};

  for (var key in o) {
    obj[key] = value(o[key]);
  }

  return obj;
}

function relation(relation) {
  if (relation === null) {
    return null;
  }

  if (isArray(relation)) {
    return relation.map(function (model) {
      return model.$toJson();
    });
  }

  return relation.$toJson();
}

function emptyRelation(relation) {
  return isArray(relation) ? [] : null;
}

var Model =
/** @class */
function () {
  /**
   * Create a new model instance.
   */
  function Model(record) {
    /**
     * The index ID for the model.
     */
    this.$id = null;
    this.$fill(record);
  }
  /**
   * The definition of the fields of the model and its relations.
   */


  Model.fields = function () {
    return {};
  };
  /**
   * Create an attr attribute.
   */


  Model.attr = function (value, mutator) {
    return new Attr(this, value, mutator);
  };
  /**
   * Create a string attribute.
   */


  Model.string = function (value, mutator) {
    return new String$1(this, value, mutator);
  };
  /**
   * Create a number attribute.
   */


  Model.number = function (value, mutator) {
    return new Number(this, value, mutator);
  };
  /**
   * Create a boolean attribute.
   */


  Model.boolean = function (value, mutator) {
    return new Boolean(this, value, mutator);
  };
  /**
   * Create an uid attribute.
   */


  Model.uid = function (value) {
    return new Uid$1(this, value);
  };
  /**
   * @deprecated Use `uid` attribute instead.
   */


  Model.increment = function () {
    /* istanbul ignore next */
    if (false) {}

    return this.uid();
  };
  /**
   * Create a has one relationship.
   */


  Model.hasOne = function (related, foreignKey, localKey) {
    return new HasOne(this, related, foreignKey, this.localKey(localKey));
  };
  /**
   * Create a belongs to relationship.
   */


  Model.belongsTo = function (parent, foreignKey, ownerKey) {
    return new BelongsTo(this, parent, foreignKey, this.relation(parent).localKey(ownerKey));
  };
  /**
   * Create a has many relationship.
   */


  Model.hasMany = function (related, foreignKey, localKey) {
    return new HasMany(this, related, foreignKey, this.localKey(localKey));
  };
  /**
   * Create a has many by relationship.
   */


  Model.hasManyBy = function (parent, foreignKey, ownerKey) {
    return new HasManyBy(this, parent, foreignKey, this.relation(parent).localKey(ownerKey));
  };
  /**
   * Create a has many through relationship.
   */


  Model.hasManyThrough = function (related, through, firstKey, secondKey, localKey, secondLocalKey) {
    return new HasManyThrough(this, related, through, firstKey, secondKey, this.localKey(localKey), this.relation(through).localKey(secondLocalKey));
  };
  /**
   * Create a belongs to many relationship.
   */


  Model.belongsToMany = function (related, pivot, foreignPivotKey, relatedPivotKey, parentKey, relatedKey) {
    return new BelongsToMany(this, related, pivot, foreignPivotKey, relatedPivotKey, this.localKey(parentKey), this.relation(related).localKey(relatedKey));
  };
  /**
   * Create a morph to relationship.
   */


  Model.morphTo = function (id, type) {
    return new MorphTo(this, id, type);
  };
  /**
   * Create a morph one relationship.
   */


  Model.morphOne = function (related, id, type, localKey) {
    return new MorphOne(this, related, id, type, this.localKey(localKey));
  };
  /**
   * Create a morph many relationship.
   */


  Model.morphMany = function (related, id, type, localKey) {
    return new MorphMany(this, related, id, type, this.localKey(localKey));
  };
  /**
   * Create a morph to many relationship.
   */


  Model.morphToMany = function (related, pivot, relatedId, id, type, parentKey, relatedKey) {
    return new MorphToMany(this, related, pivot, relatedId, id, type, this.localKey(parentKey), this.relation(related).localKey(relatedKey));
  };
  /**
   * Create a morphed by many relationship.
   */


  Model.morphedByMany = function (related, pivot, relatedId, id, type, parentKey, relatedKey) {
    return new MorphedByMany(this, related, pivot, relatedId, id, type, this.localKey(parentKey), this.relation(related).localKey(relatedKey));
  };
  /**
   * Mutators to mutate matching fields when instantiating the model.
   */


  Model.mutators = function () {
    return {};
  };
  /**
   * Types mapping used to dispatch entities based on their discriminator field
   */


  Model.types = function () {
    return {};
  };
  /**
   * Get the store instance from the container.
   */


  Model.store = function () {
    return Container.store;
  };
  /**
   * Get the database instance from store.
   */


  Model.database = function () {
    return this.store().$db();
  };
  /**
   * Create a namespaced method name for Vuex Module from the given
   * method name.
   */


  Model.namespace = function (method) {
    return this.database().namespace + "/" + this.entity + "/" + method;
  };
  /**
   * Call Vuex Getters.
   */


  Model.getters = function (method) {
    return this.store().getters[this.namespace(method)];
  };
  /**
   * Dispatch Vuex Action.
   */


  Model.dispatch = function (method, payload) {
    return this.store().dispatch(this.namespace(method), payload);
  };
  /**
   * Commit Vuex Mutation.
   */


  Model.commit = function (callback) {
    this.store().commit(this.database().namespace + "/$mutate", {
      entity: this.entity,
      callback: callback
    });
  };
  /**
   * Get the Model schema definition from the cache.
   */


  Model.getFields = function () {
    if (!this.cachedFields) {
      this.cachedFields = {};
    }

    if (this.cachedFields[this.entity]) {
      return this.cachedFields[this.entity];
    }

    this.cachedFields[this.entity] = this.fields();
    return this.cachedFields[this.entity];
  };
  /**
   * Get all records.
   */


  Model.all = function () {
    return this.getters('all')();
  };
  /**
   * Find a record.
   */


  Model.find = function (id) {
    return this.getters('find')(id);
  };
  /**
   * Get the record of the given array of ids.
   */


  Model.findIn = function (idList) {
    return this.getters('findIn')(idList);
  };
  /**
   * Get query instance.
   */


  Model.query = function () {
    return this.getters('query')();
  };
  /**
   * Check wether the associated database contains data.
   */


  Model.exists = function () {
    return this.query().exists();
  };
  /**
   * Create new data with all fields filled by default values.
   */


  Model.new = function () {
    return this.dispatch('new');
  };
  /**
   * Save given data to the store by replacing all existing records in the
   * store. If you want to save data without replacing existing records,
   * use the `insert` method instead.
   */


  Model.create = function (payload) {
    return this.dispatch('create', payload);
  };
  /**
   * Insert records.
   */


  Model.insert = function (payload) {
    return this.dispatch('insert', payload);
  };
  /**
   * Update records.
   */


  Model.update = function (payload) {
    return this.dispatch('update', payload);
  };
  /**
   * Insert or update records.
   */


  Model.insertOrUpdate = function (payload) {
    return this.dispatch('insertOrUpdate', payload);
  };

  Model.delete = function (payload) {
    return this.dispatch('delete', payload);
  };
  /**
   * Delete all records from the store.
   */


  Model.deleteAll = function () {
    return this.dispatch('deleteAll');
  };
  /**
   * Check if the given key is the primary key. If the model has composite
   * primary key, this method is going to check if the given key is included
   * in the composite key.
   */


  Model.isPrimaryKey = function (key) {
    if (!Utils.isArray(this.primaryKey)) {
      return this.primaryKey === key;
    }

    return this.primaryKey.includes(key);
  };
  /**
   * Check if the primary key is a composite key.
   */


  Model.isCompositePrimaryKey = function () {
    return Utils.isArray(this.primaryKey);
  };
  /**
   * Get the id (value of primary key) from teh given record. If primary key is
   * not present, or it is invalid primary key value, which is other than
   * `string` or `number`, it's going to return `null`.
   *
   * If the model has composite key, it's going to return array of ids. If any
   * composite key missing, it will return `null`.
   */


  Model.getIdFromRecord = function (record) {
    var _this = this;

    var key = this.primaryKey;

    if (typeof key === 'string') {
      return this.getIdFromValue(record[key]);
    }

    var ids = key.reduce(function (keys, k) {
      var id = _this.getIdFromValue(record[k]);

      id !== null && keys.push(id);
      return keys;
    }, []);
    return ids.length === key.length ? ids : null;
  };
  /**
   * Get correct index id, which is `string` | `number`, from the given value.
   */


  Model.getIdFromValue = function (value) {
    if (typeof value === 'string' && value !== '') {
      return value;
    }

    if (typeof value === 'number') {
      return value;
    }

    return null;
  };
  /**
   * Get the index ID value from the given record. An index ID is a value that
   * used as a key for records within the Vuex Store.
   *
   * Most of the time, it's same as the value for the Model's primary key but
   * it's always `string`, even if the primary key value is `number`.
   *
   * If the Model has a composite primary key, each value corresponding to
   * those primary key will be stringified and become a single string value
   * such as `'[1,2]'`.
   *
   * If the primary key is not present at the given record, it returns `null`.
   * For the composite primary key, every key must exist at a given record,
   * or it will return `null`.
   */


  Model.getIndexIdFromRecord = function (record) {
    var id = this.getIdFromRecord(record);

    if (id === null) {
      return null;
    }

    if (Utils.isArray(id)) {
      return JSON.stringify(id);
    }

    return String(id);
  };
  /**
   * Get local key to pass to the attributes.
   */


  Model.localKey = function (key) {
    if (key) {
      return key;
    }

    return typeof this.primaryKey === 'string' ? this.primaryKey : 'id';
  };
  /**
   * Get the model object that matches the given record type. The method is for
   * getting the correct model object when the model has any inheritance
   * children model.
   *
   * For example, if a User Model have `static types()` declared, and if you
   * pass record with `{ type: 'admin' }`, then the method will likely to
   * return SuperUser class.
   */


  Model.getModelFromRecord = function (record) {
    // If the given record is already a model instance, return the
    // model object.
    if (record instanceof this) {
      return record.$self();
    } // Else, get the corresponding model for the type value if there's any.


    return this.getTypeModel(record[this.typeKey]);
  };
  /**
   * Get a model from the container.
   */


  Model.relation = function (model) {
    if (typeof model !== 'string') {
      return model;
    }

    return this.database().model(model);
  };
  /**
   * Get all `belongsToMany` fields from the schema.
   */


  Model.pivotFields = function () {
    var fields = [];
    Utils.forOwn(this.getFields(), function (field, key) {
      var _a;

      if (field instanceof BelongsToMany || field instanceof MorphToMany || field instanceof MorphedByMany) {
        fields.push((_a = {}, _a[key] = field, _a));
      }
    });
    return fields;
  };
  /**
   * Check if fields contains the `belongsToMany` field type.
   */


  Model.hasPivotFields = function () {
    return this.pivotFields().length > 0;
  };
  /**
   * Check if the current model has a type definition
   */


  Model.hasTypes = function () {
    return Object.keys(this.types()).length > 0;
  };
  /**
   * Get the model corresponding to the given type name. If it can't be found,
   * it'll return `null`.
   */


  Model.getTypeModel = function (name) {
    var model = this.types()[name];

    if (!model) {
      return null;
    }

    return model;
  };
  /**
   * Given a Model, this returns the corresponding key in the InheritanceTypes mapping
   */


  Model.getTypeKeyValueFromModel = function (model) {
    var modelToCheck = model || this;
    var types = this.types();

    for (var type in types) {
      if (types[type].entity === modelToCheck.entity) {
        return type;
      }
    }

    return null;
  };
  /**
   * Tries to find a Relation field in all types defined in the InheritanceTypes mapping
   */


  Model.findRelationInSubTypes = function (relationName) {
    var types = this.types();

    for (var type in types) {
      var fields = types[type].getFields();

      for (var fieldName in fields) {
        if (fieldName === relationName && fields[fieldName] instanceof Relation) {
          return fields[fieldName];
        }
      }
    }

    return null;
  };
  /**
   * Fill any missing fields in the given record with the default value defined
   * in the model schema.
   */


  Model.hydrate = function (record) {
    return new this(record).$getAttributes();
  };
  /**
   * Get the constructor of this model.
   */


  Model.prototype.$self = function () {
    return this.constructor;
  };
  /**
   * Get the primary key for the model.
   */


  Model.prototype.$primaryKey = function () {
    return this.$self().primaryKey;
  };
  /**
   * The definition of the fields of the model and its relations.
   */


  Model.prototype.$fields = function () {
    return this.$self().getFields();
  };
  /**
   * Set index id.
   */


  Model.prototype.$setIndexId = function (id) {
    this.$id = id;
    return this;
  };
  /**
   * Get the store instance from the container.
   */


  Model.prototype.$store = function () {
    return this.$self().store();
  };
  /**
   * Create a namespaced method name for Vuex Module from the given
   * method name.
   */


  Model.prototype.$namespace = function (method) {
    return this.$self().namespace(method);
  };
  /**
   * Call Vuex Getetrs.
   */


  Model.prototype.$getters = function (method) {
    return this.$self().getters(method);
  };
  /**
   * Dispatch Vuex Action.
   */


  Model.prototype.$dispatch = function (method, payload) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , this.$self().dispatch(method, payload)];
      });
    });
  };
  /**
   * Get all records.
   */


  Model.prototype.$all = function () {
    return this.$getters('all')();
  };
  /**
   * Find a record.
   */


  Model.prototype.$find = function (id) {
    return this.$getters('find')(id);
  };
  /**
   * Find record of the given array of ids.
   */


  Model.prototype.$findIn = function (idList) {
    return this.$getters('findIn')(idList);
  };
  /**
   * Get query instance.
   */


  Model.prototype.$query = function () {
    return this.$getters('query')();
  };
  /**
   * Create records.
   */


  Model.prototype.$create = function (payload) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , this.$dispatch('create', payload)];
      });
    });
  };
  /**
   * Create records.
   */


  Model.prototype.$insert = function (payload) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , this.$dispatch('insert', payload)];
      });
    });
  };
  /**
   * Update records.
   */


  Model.prototype.$update = function (payload) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        if (Utils.isArray(payload)) {
          return [2
          /*return*/
          , this.$dispatch('update', payload)];
        }

        if (payload.where !== undefined) {
          return [2
          /*return*/
          , this.$dispatch('update', payload)];
        }

        if (this.$self().getIndexIdFromRecord(payload) === null) {
          return [2
          /*return*/
          , this.$dispatch('update', {
            where: this.$self().getIdFromRecord(this),
            data: payload
          })];
        }

        return [2
        /*return*/
        , this.$dispatch('update', payload)];
      });
    });
  };
  /**
   * Insert or update records.
   */


  Model.prototype.$insertOrUpdate = function (payload) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , this.$dispatch('insertOrUpdate', payload)];
      });
    });
  };
  /**
   * Save record.
   */


  Model.prototype.$save = function () {
    return __awaiter(this, void 0, void 0, function () {
      var fields, record, records;

      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            fields = this.$self().getFields();
            record = Object.keys(fields).reduce(function (record, key) {
              if (fields[key] instanceof Type) {
                record[key] = _this[key];
              }

              return record;
            }, {});
            return [4
            /*yield*/
            , this.$dispatch('insertOrUpdate', {
              data: record
            })];

          case 1:
            records = _a.sent();
            this.$fill(records[this.$self().entity][0]);
            return [2
            /*return*/
            , this];
        }
      });
    });
  };
  /**
   * Delete records that matches the given condition.
   */


  Model.prototype.$delete = function () {
    return __awaiter(this, void 0, void 0, function () {
      var primaryKey;

      var _this = this;

      return __generator(this, function (_a) {
        primaryKey = this.$primaryKey();

        if (!Utils.isArray(primaryKey)) {
          return [2
          /*return*/
          , this.$dispatch('delete', this[primaryKey])];
        }

        return [2
        /*return*/
        , this.$dispatch('delete', function (model) {
          return primaryKey.every(function (id) {
            return model[id] === _this[id];
          });
        })];
      });
    });
  };
  /**
   * Delete all records.
   */


  Model.prototype.$deleteAll = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , this.$dispatch('deleteAll')];
      });
    });
  };
  /**
   * Fill the model instance with the given record. If no record were passed,
   * or if the record has any missing fields, each value of the fields will
   * be filled with its default value defined at model fields definition.
   */


  Model.prototype.$fill = function (record) {
    if (record === void 0) {
      record = {};
    }

    var fields = this.$fields();

    for (var key in fields) {
      var field = fields[key];
      var value = record[key];
      this[key] = field.make(value, record, key);
    } // If the record contains index id, set it to the model.


    record.$id !== undefined && this.$setIndexId(record.$id);
  };
  /**
   * Generate missing primary ids and index id.
   */


  Model.prototype.$generateId = function () {
    return this.$generatePrimaryId().$generateIndexId();
  };
  /**
   * Generate any missing primary ids.
   */


  Model.prototype.$generatePrimaryId = function () {
    var _this = this;

    var key = this.$self().primaryKey;
    var keys = Utils.isArray(key) ? key : [key];
    keys.forEach(function (k) {
      if (_this[k] === undefined || _this[k] === null) {
        _this[k] = Uid.make();
      }
    });
    return this;
  };
  /**
   * Generate index id from current model attributes.
   */


  Model.prototype.$generateIndexId = function () {
    return this.$setIndexId(this.$getIndexIdFromAttributes());
  };
  /**
   * Get index id based on current model attributes.
   */


  Model.prototype.$getIndexIdFromAttributes = function () {
    return this.$self().getIndexIdFromRecord(this);
  };
  /**
   * Get all of the current attributes on the model. It includes index id
   * value as well. This method is mainly used when saving a model to
   * the store.
   */


  Model.prototype.$getAttributes = function () {
    return toAttributes(this);
  };
  /**
   * Serialize field values into json.
   */


  Model.prototype.$toJson = function () {
    return toJson(this);
  };
  /**
   * The primary key to be used for the model.
   */


  Model.primaryKey = 'id';
  /**
   * The discriminator key to be used for the model when inheritance is used
   */

  Model.typeKey = 'type';
  /**
   * Vuex Store state definition.
   */

  Model.state = {};
  return Model;
}();
/**
 * Create a new Query instance.
 */


var query = function (state, _getters, _rootState, rootGetters) {
  return function () {
    return rootGetters[state.$connection + "/query"](state.$name);
  };
};
/**
 * Get all data of given entity.
 */


var all = function (state, _getters, _rootState, rootGetters) {
  return function () {
    return rootGetters[state.$connection + "/all"](state.$name);
  };
};
/**
 * Find a data of the given entity by given id.
 */


var find = function (state, _getters, _rootState, rootGetters) {
  return function (id) {
    return rootGetters[state.$connection + "/find"](state.$name, id);
  };
};
/**
 * Find array of data of the given entity by given ids.
 */


var findIn = function (state, _getters, _rootState, rootGetters) {
  return function (idList) {
    return rootGetters[state.$connection + "/findIn"](state.$name, idList);
  };
};

var Getters = {
  query: query,
  all: all,
  find: find,
  findIn: findIn
};
/**
 * Create new data with all fields filled by default values.
 */

function newRecord(context) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name;
      return [2
      /*return*/
      , context.dispatch(state.$connection + "/new", {
        entity: entity
      }, {
        root: true
      })];
    });
  });
}
/**
 * Save given data to the store by replacing all existing records in the
 * store. If you want to save data without replacing existing records,
 * use the `insert` method instead.
 */


function create(context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name;
      return [2
      /*return*/
      , context.dispatch(state.$connection + "/create", __assign(__assign({}, payload), {
        entity: entity
      }), {
        root: true
      })];
    });
  });
}
/**
 * Insert given data to the state. Unlike `create`, this method will not
 * remove existing data within the state, but it will update the data
 * with the same primary key.
 */


function insert(context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name;
      return [2
      /*return*/
      , context.dispatch(state.$connection + "/insert", __assign(__assign({}, payload), {
        entity: entity
      }), {
        root: true
      })];
    });
  });
}
/**
 * Update data in the store.
 */


function update(context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name; // If the payload is an array, then the payload should be an array of
      // data so let's pass the whole payload as data.

      if (isArray(payload)) {
        return [2
        /*return*/
        , context.dispatch(state.$connection + "/update", {
          entity: entity,
          data: payload
        }, {
          root: true
        })];
      } // If the payload doesn't have `data` property, we'll assume that
      // the user has passed the object as the payload so let's define
      // the whole payload as a data.


      if (payload.data === undefined) {
        return [2
        /*return*/
        , context.dispatch(state.$connection + "/update", {
          entity: entity,
          data: payload
        }, {
          root: true
        })];
      } // Else destructure the payload and let root action handle it.


      return [2
      /*return*/
      , context.dispatch(state.$connection + "/update", __assign({
        entity: entity
      }, payload), {
        root: true
      })];
    });
  });
}
/**
 * Insert or update given data to the state. Unlike `insert`, this method
 * will not replace existing data within the state, but it will update only
 * the submitted data with the same primary key.
 */


function insertOrUpdate(context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name;
      return [2
      /*return*/
      , context.dispatch(state.$connection + "/insertOrUpdate", __assign({
        entity: entity
      }, payload), {
        root: true
      })];
    });
  });
}

function destroy(context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity, where;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name;
      where = payload;
      return [2
      /*return*/
      , context.dispatch(state.$connection + "/delete", {
        entity: entity,
        where: where
      }, {
        root: true
      })];
    });
  });
}
/**
 * Delete all data from the store.
 */


function deleteAll(context) {
  return __awaiter(this, void 0, void 0, function () {
    var state, entity;
    return __generator(this, function (_a) {
      state = context.state;
      entity = state.$name;
      return [2
      /*return*/
      , context.dispatch(state.$connection + "/deleteAll", {
        entity: entity
      }, {
        root: true
      })];
    });
  });
}

var Actions = {
  new: newRecord,
  create: create,
  insert: insert,
  update: update,
  insertOrUpdate: insertOrUpdate,
  delete: destroy,
  deleteAll: deleteAll
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/**
 * Helpers to enable Immutable compatibility *without* bringing in
 * the 'immutable' package as a dependency.
 */

/**
 * Check if an object is immutable by checking if it has a key specific
 * to the immutable library.
 *
 * @param  {any} object
 * @return {bool}
 */


function isImmutable(object) {
  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map
  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record
}
/**
 * Denormalize an immutable entity.
 *
 * @param  {Schema} schema
 * @param  {Immutable.Map|Immutable.Record} input
 * @param  {function} unvisit
 * @param  {function} getDenormalizedEntity
 * @return {Immutable.Map|Immutable.Record}
 */


function denormalizeImmutable(schema, input, unvisit) {
  return Object.keys(schema).reduce(function (object, key) {
    // Immutable maps cast keys to strings on write so we need to ensure
    // we're accessing them using string keys.
    var stringKey = "" + key;

    if (object.has(stringKey)) {
      return object.set(stringKey, unvisit(object.get(stringKey), schema[stringKey]));
    } else {
      return object;
    }
  }, input);
}

var getDefaultGetId = function getDefaultGetId(idAttribute) {
  return function (input) {
    return isImmutable(input) ? input.get(idAttribute) : input[idAttribute];
  };
};

var EntitySchema = /*#__PURE__*/function () {
  function EntitySchema(key, definition, options) {
    if (definition === void 0) {
      definition = {};
    }

    if (options === void 0) {
      options = {};
    }

    if (!key || typeof key !== 'string') {
      throw new Error("Expected a string key for Entity, but found " + key + ".");
    }

    var _options = options,
        _options$idAttribute = _options.idAttribute,
        idAttribute = _options$idAttribute === void 0 ? 'id' : _options$idAttribute,
        _options$mergeStrateg = _options.mergeStrategy,
        mergeStrategy = _options$mergeStrateg === void 0 ? function (entityA, entityB) {
      return _extends({}, entityA, entityB);
    } : _options$mergeStrateg,
        _options$processStrat = _options.processStrategy,
        processStrategy = _options$processStrat === void 0 ? function (input) {
      return _extends({}, input);
    } : _options$processStrat,
        _options$fallbackStra = _options.fallbackStrategy,
        fallbackStrategy = _options$fallbackStra === void 0 ? function (key, schema) {
      return undefined;
    } : _options$fallbackStra;
    this._key = key;
    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);
    this._idAttribute = idAttribute;
    this._mergeStrategy = mergeStrategy;
    this._processStrategy = processStrategy;
    this._fallbackStrategy = fallbackStrategy;
    this.define(definition);
  }

  var _proto = EntitySchema.prototype;

  _proto.define = function define(definition) {
    this.schema = Object.keys(definition).reduce(function (entitySchema, key) {
      var _extends2;

      var schema = definition[key];
      return _extends({}, entitySchema, (_extends2 = {}, _extends2[key] = schema, _extends2));
    }, this.schema || {});
  };

  _proto.getId = function getId(input, parent, key) {
    return this._getId(input, parent, key);
  };

  _proto.merge = function merge(entityA, entityB) {
    return this._mergeStrategy(entityA, entityB);
  };

  _proto.fallback = function fallback(id, schema) {
    return this._fallbackStrategy(id, schema);
  };

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    var _this = this;

    var id = this.getId(input, parent, key);
    var entityType = this.key;

    if (!(entityType in visitedEntities)) {
      visitedEntities[entityType] = {};
    }

    if (!(id in visitedEntities[entityType])) {
      visitedEntities[entityType][id] = [];
    }

    if (visitedEntities[entityType][id].some(function (entity) {
      return entity === input;
    })) {
      return id;
    }

    visitedEntities[entityType][id].push(input);

    var processedEntity = this._processStrategy(input, parent, key);

    Object.keys(this.schema).forEach(function (key) {
      if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {
        var schema = _this.schema[key];
        var resolvedSchema = typeof schema === 'function' ? schema(input) : schema;
        processedEntity[key] = visit(processedEntity[key], processedEntity, key, resolvedSchema, addEntity, visitedEntities);
      }
    });
    addEntity(this, processedEntity, input, parent, key);
    return id;
  };

  _proto.denormalize = function denormalize(entity, unvisit) {
    var _this2 = this;

    if (isImmutable(entity)) {
      return denormalizeImmutable(this.schema, entity, unvisit);
    }

    Object.keys(this.schema).forEach(function (key) {
      if (entity.hasOwnProperty(key)) {
        var schema = _this2.schema[key];
        entity[key] = unvisit(entity[key], schema);
      }
    });
    return entity;
  };

  _createClass(EntitySchema, [{
    key: "key",
    get: function get() {
      return this._key;
    }
  }, {
    key: "idAttribute",
    get: function get() {
      return this._idAttribute;
    }
  }]);

  return EntitySchema;
}();

var PolymorphicSchema = /*#__PURE__*/function () {
  function PolymorphicSchema(definition, schemaAttribute) {
    if (schemaAttribute) {
      this._schemaAttribute = typeof schemaAttribute === 'string' ? function (input) {
        return input[schemaAttribute];
      } : schemaAttribute;
    }

    this.define(definition);
  }

  var _proto = PolymorphicSchema.prototype;

  _proto.define = function define(definition) {
    this.schema = definition;
  };

  _proto.getSchemaAttribute = function getSchemaAttribute(input, parent, key) {
    return !this.isSingleSchema && this._schemaAttribute(input, parent, key);
  };

  _proto.inferSchema = function inferSchema(input, parent, key) {
    if (this.isSingleSchema) {
      return this.schema;
    }

    var attr = this.getSchemaAttribute(input, parent, key);
    return this.schema[attr];
  };

  _proto.normalizeValue = function normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {
    var schema = this.inferSchema(value, parent, key);

    if (!schema) {
      return value;
    }

    var normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);
    return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {
      id: normalizedValue,
      schema: this.getSchemaAttribute(value, parent, key)
    };
  };

  _proto.denormalizeValue = function denormalizeValue(value, unvisit) {
    var schemaKey = isImmutable(value) ? value.get('schema') : value.schema;

    if (!this.isSingleSchema && !schemaKey) {
      return value;
    }

    var id = this.isSingleSchema ? undefined : isImmutable(value) ? value.get('id') : value.id;
    var schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];
    return unvisit(id || value, schema);
  };

  _createClass(PolymorphicSchema, [{
    key: "isSingleSchema",
    get: function get() {
      return !this._schemaAttribute;
    }
  }]);

  return PolymorphicSchema;
}();

var UnionSchema = /*#__PURE__*/function (_PolymorphicSchema) {
  _inheritsLoose(UnionSchema, _PolymorphicSchema);

  function UnionSchema(definition, schemaAttribute) {
    if (!schemaAttribute) {
      throw new Error('Expected option "schemaAttribute" not found on UnionSchema.');
    }

    return _PolymorphicSchema.call(this, definition, schemaAttribute) || this;
  }

  var _proto = UnionSchema.prototype;

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);
  };

  _proto.denormalize = function denormalize(input, unvisit) {
    return this.denormalizeValue(input, unvisit);
  };

  return UnionSchema;
}(PolymorphicSchema);

var ValuesSchema = /*#__PURE__*/function (_PolymorphicSchema) {
  _inheritsLoose(ValuesSchema, _PolymorphicSchema);

  function ValuesSchema() {
    return _PolymorphicSchema.apply(this, arguments) || this;
  }

  var _proto = ValuesSchema.prototype;

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    var _this = this;

    return Object.keys(input).reduce(function (output, key, index) {
      var _extends2;

      var value = input[key];
      return value !== undefined && value !== null ? _extends({}, output, (_extends2 = {}, _extends2[key] = _this.normalizeValue(value, input, key, visit, addEntity, visitedEntities), _extends2)) : output;
    }, {});
  };

  _proto.denormalize = function denormalize(input, unvisit) {
    var _this2 = this;

    return Object.keys(input).reduce(function (output, key) {
      var _extends3;

      var entityOrId = input[key];
      return _extends({}, output, (_extends3 = {}, _extends3[key] = _this2.denormalizeValue(entityOrId, unvisit), _extends3));
    }, {});
  };

  return ValuesSchema;
}(PolymorphicSchema);

var validateSchema = function validateSchema(definition) {
  var isArray = Array.isArray(definition);

  if (isArray && definition.length > 1) {
    throw new Error("Expected schema definition to be a single schema, but found " + definition.length + ".");
  }

  return definition[0];
};

var getValues = function getValues(input) {
  return Array.isArray(input) ? input : Object.keys(input).map(function (key) {
    return input[key];
  });
};

var normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {
  schema = validateSchema(schema);
  var values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there
  // is not any special information that can be gathered from themselves directly

  return values.map(function (value, index) {
    return visit(value, parent, key, schema, addEntity, visitedEntities);
  });
};

var ArraySchema = /*#__PURE__*/function (_PolymorphicSchema) {
  _inheritsLoose(ArraySchema, _PolymorphicSchema);

  function ArraySchema() {
    return _PolymorphicSchema.apply(this, arguments) || this;
  }

  var _proto = ArraySchema.prototype;

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    var _this = this;

    var values = getValues(input);
    return values.map(function (value, index) {
      return _this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities);
    }).filter(function (value) {
      return value !== undefined && value !== null;
    });
  };

  _proto.denormalize = function denormalize(input, unvisit) {
    var _this2 = this;

    return input && input.map ? input.map(function (value) {
      return _this2.denormalizeValue(value, unvisit);
    }) : input;
  };

  return ArraySchema;
}(PolymorphicSchema);

var _normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {
  var object = _extends({}, input);

  Object.keys(schema).forEach(function (key) {
    var localSchema = schema[key];
    var resolvedLocalSchema = typeof localSchema === 'function' ? localSchema(input) : localSchema;
    var value = visit(input[key], input, key, resolvedLocalSchema, addEntity, visitedEntities);

    if (value === undefined || value === null) {
      delete object[key];
    } else {
      object[key] = value;
    }
  });
  return object;
};

var _denormalize = function denormalize(schema, input, unvisit) {
  if (isImmutable(input)) {
    return denormalizeImmutable(schema, input, unvisit);
  }

  var object = _extends({}, input);

  Object.keys(schema).forEach(function (key) {
    if (object[key] != null) {
      object[key] = unvisit(object[key], schema[key]);
    }
  });
  return object;
};

var ObjectSchema = /*#__PURE__*/function () {
  function ObjectSchema(definition) {
    this.define(definition);
  }

  var _proto = ObjectSchema.prototype;

  _proto.define = function define(definition) {
    this.schema = Object.keys(definition).reduce(function (entitySchema, key) {
      var _extends2;

      var schema = definition[key];
      return _extends({}, entitySchema, (_extends2 = {}, _extends2[key] = schema, _extends2));
    }, this.schema || {});
  };

  _proto.normalize = function normalize() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _normalize.apply(void 0, [this.schema].concat(args));
  };

  _proto.denormalize = function denormalize() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _denormalize.apply(void 0, [this.schema].concat(args));
  };

  return ObjectSchema;
}();

var visit = function visit(value, parent, key, schema, addEntity, visitedEntities) {
  if (typeof value !== 'object' || !value) {
    return value;
  }

  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {
    var method = Array.isArray(schema) ? normalize : _normalize;
    return method(schema, value, parent, key, visit, addEntity, visitedEntities);
  }

  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);
};

var addEntities = function addEntities(entities) {
  return function (schema, processedEntity, value, parent, key) {
    var schemaKey = schema.key;
    var id = schema.getId(value, parent, key);

    if (!(schemaKey in entities)) {
      entities[schemaKey] = {};
    }

    var existingEntity = entities[schemaKey][id];

    if (existingEntity) {
      entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);
    } else {
      entities[schemaKey][id] = processedEntity;
    }
  };
};

var schema = {
  Array: ArraySchema,
  Entity: EntitySchema,
  Object: ObjectSchema,
  Union: UnionSchema,
  Values: ValuesSchema
};

var normalize$1 = function normalize(input, schema) {
  if (!input || typeof input !== 'object') {
    throw new Error("Unexpected input given to normalize. Expected type to be \"object\", found \"" + (input === null ? 'null' : typeof input) + "\".");
  }

  var entities = {};
  var addEntity = addEntities(entities);
  var visitedEntities = {};
  var result = visit(input, input, null, schema, addEntity, visitedEntities);
  return {
    entities: entities,
    result: result
  };
};

var Normalizer =
/** @class */
function () {
  function Normalizer() {}
  /**
   * Normalize the record.
   */


  Normalizer.process = function (query, record) {
    if (Utils.isEmpty(record)) {
      return {};
    }

    var entity = query.database.schemas[query.model.entity];
    var schema = Utils.isArray(record) ? [entity] : entity;
    return normalize$1(record, schema).entities;
  };

  return Normalizer;
}();

var PivotCreator =
/** @class */
function () {
  function PivotCreator() {}
  /**
   * Create an intermediate entity if the data contains any entities that
   * require it for example `belongsTo` or `morphMany`.
   */


  PivotCreator.process = function (query, data) {
    Object.keys(data).forEach(function (entity) {
      var model = query.getModel(entity);

      if (model.hasPivotFields()) {
        Utils.forOwn(model.pivotFields(), function (field) {
          Utils.forOwn(field, function (attr, key) {
            attr.createPivots(model, data, key);
          });
        });
      }
    });
    return data;
  };

  return PivotCreator;
}();

var Attacher =
/** @class */
function () {
  function Attacher() {}
  /**
   * Attach missing relational key to the records.
   */


  Attacher.process = function (query, data) {
    Utils.forOwn(data, function (entity, name) {
      var fields = query.getModel(name).fields();
      Utils.forOwn(entity, function (record) {
        Utils.forOwn(record, function (value, key) {
          var field = fields[key];

          if (field instanceof Relation) {
            value !== null && field.attach(value, record, data);
          }
        });
      });
    });
    return data;
  };

  return Attacher;
}();

var Processor =
/** @class */
function () {
  function Processor() {}
  /**
   * Normalize the given data.
   */


  Processor.normalize = function (query, record) {
    // First, let's normalize the data.
    var data = Normalizer.process(query, record); // Then, attach any missing foreign keys. For example, if a User has many
    // Post nested but without foreign key such as `user_id`, we can attach
    // the `user_id` value to the Post entities.

    data = Attacher.process(query, data); // Now we'll create any missing pivot entities for relationships such as
    // `belongsTo` or `morphMany`.

    data = PivotCreator.process(query, data); // And we'll return the result as a normalized data.

    return data;
  };

  return Processor;
}();

var WhereFilter =
/** @class */
function () {
  function WhereFilter() {}
  /**
   * Filter the given data by registered where clause.
   */


  WhereFilter.filter = function (query, records) {
    var _this = this;

    if (query.wheres.length === 0) {
      return records;
    }

    return records.filter(function (record) {
      return _this.check(query, record);
    });
  };
  /**
   * Checks if given Record matches the registered where clause.
   */


  WhereFilter.check = function (query, record) {
    var whereTypes = Utils.groupBy(query.wheres, function (where) {
      return where.boolean;
    });
    var comparator = this.getComparator(query, record);
    var results = [];
    whereTypes.and && results.push(whereTypes.and.every(comparator));
    whereTypes.or && results.push(whereTypes.or.some(comparator));
    return results.indexOf(true) !== -1;
  };
  /**
   * Get comparator for the where clause.
   */


  WhereFilter.getComparator = function (query, record) {
    var _this = this;

    return function (where) {
      // Function with Record and Query as argument.
      if (typeof where.field === 'function') {
        var newQuery = new Query(query.store, query.entity);

        var result = _this.executeWhereClosure(newQuery, record, where.field);

        if (typeof result === 'boolean') {
          return result;
        } // If closure returns undefined, we need to execute the local query.


        var matchingRecords = newQuery.get(); // And check if current record is part of the result.

        return !Utils.isEmpty(matchingRecords.filter(function (rec) {
          return rec['$id'] === record['$id'];
        }));
      } // Function with Record value as argument.


      if (typeof where.value === 'function') {
        return where.value(record[where.field]);
      } // Check if field value is in given where Array.


      if (Utils.isArray(where.value)) {
        return where.value.indexOf(record[where.field]) !== -1;
      } // Simple equal check.


      return record[where.field] === where.value;
    };
  };
  /**
   * Execute where closure.
   */


  WhereFilter.executeWhereClosure = function (query, record, closure) {
    if (closure.length !== 3) {
      return closure(record, query);
    }

    var model = new query.model(record);
    return closure(record, query, model);
  };

  return WhereFilter;
}();

var OrderByFilter =
/** @class */
function () {
  function OrderByFilter() {}
  /**
   * Sort the given data by registered orders.
   */


  OrderByFilter.filter = function (query, records) {
    if (query.orders.length === 0) {
      return records;
    }

    var keys = query.orders.map(function (order) {
      return order.key;
    });
    var directions = query.orders.map(function (order) {
      return order.direction;
    });
    return Utils.orderBy(records, keys, directions);
  };

  return OrderByFilter;
}();

var LimitFilter =
/** @class */
function () {
  function LimitFilter() {}
  /**
   * Limit the given records by the lmilt and offset.
   */


  LimitFilter.filter = function (query, records) {
    return records.slice(query.offsetNumber, query.offsetNumber + query.limitNumber);
  };

  return LimitFilter;
}();

var Filter =
/** @class */
function () {
  function Filter() {}
  /**
   * Filter the given data by registered where clause.
   */


  Filter.where = function (query, records) {
    return WhereFilter.filter(query, records);
  };
  /**
   * Sort the given data by registered orders.
   */


  Filter.orderBy = function (query, records) {
    return OrderByFilter.filter(query, records);
  };
  /**
   * Limit the given records by the lmilt and offset.
   */


  Filter.limit = function (query, records) {
    return LimitFilter.filter(query, records);
  };

  return Filter;
}();

var Loader =
/** @class */
function () {
  function Loader() {}
  /**
   * Set the relationships that should be eager loaded with the query.
   */


  Loader.with = function (query, name, constraint) {
    var _this = this; // If the name of the relation is `*`, we'll load all relationships.


    if (name === '*') {
      this.withAll(query);
      return;
    } // If we passed an array, we dispatch the bits to with queries.


    if (isArray(name)) {
      name.forEach(function (relationName) {
        return _this.with(query, relationName, constraint);
      });
      return;
    } // Else parse relations and set appropriate constraints.


    this.parseWithRelations(query, name.split('.'), constraint);
  };
  /**
   * Set all relationships to be eager loaded with the query.
   */


  Loader.withAll = function (query, constraint) {
    if (constraint === void 0) {
      constraint = function () {
        return null;
      };
    }

    var fields = query.model.getFields();

    for (var field in fields) {
      fields[field] instanceof Relation && this.with(query, field, constraint);
    }
  };
  /**
   * Set relationships to be recursively eager loaded with the query.
   */


  Loader.withAllRecursive = function (query, depth) {
    this.withAll(query, function (relatedQuery) {
      depth > 0 && relatedQuery.withAllRecursive(depth - 1);
    });
  };
  /**
   * Set eager load relation and constraint.
   */


  Loader.setEagerLoad = function (query, name, constraint) {
    if (constraint === void 0) {
      constraint = null;
    }

    if (!query.load[name]) {
      query.load[name] = [];
    }

    constraint && query.load[name].push(constraint);
  };
  /**
   * Parse a list of relations into individuals.
   */


  Loader.parseWithRelations = function (query, relations, constraint) {
    var _this = this; // First we'll get the very first relationship from teh whole relations.


    var relation = relations[0]; // If the first relation has "or" syntax which is `|` for example
    // `posts|videos`, set each of them as separate eager load.

    relation.split('|').forEach(function (name) {
      // If there's only one relationship in relations array, that means
      // there's no nested relationship. So we'll set the given
      // constraint to the relationship loading.
      if (relations.length === 1) {
        _this.setEagerLoad(query, name, constraint);

        return;
      } // Else we'll skip adding constraint because the constraint has to be
      // applied to the nested relationship. We'll let `addNestedWiths`
      // method to handle that later.


      _this.setEagerLoad(query, name);
    }); // If the given relations only contains a single name, which means it
    // doesn't have any nested relations such as `posts.comments`, we
    // don't need go farther so return here.

    if (relations.length === 1) {
      return;
    } // Finally, we shift the first relation from the array and handle lest
    // of relations as a nested relation.


    relations.shift();
    this.addNestedWiths(query, relation, relations, constraint);
  };
  /**
   * Parse the nested relationships in a relation.
   */


  Loader.addNestedWiths = function (query, name, children, constraint) {
    this.setEagerLoad(query, name, function (nestedQuery) {
      nestedQuery.with(children.join('.'), constraint);
    });
  };
  /**
   * Eager load the relationships for the given collection.
   */


  Loader.eagerLoadRelations = function (query, collection) {
    var fields = query.model.getFields();

    for (var name_1 in query.load) {
      var constraints = query.load[name_1];
      var relation = fields[name_1];

      if (relation instanceof Relation) {
        relation.load(query, collection, name_1, constraints);
        continue;
      } // If no relation was found on the query, it might be run on the
      // base entity of a hierarchy. In this case, we try looking up
      // the relation on the derived entities


      if (query.model.hasTypes()) {
        var candidateRelation = query.model.findRelationInSubTypes(name_1);

        if (candidateRelation !== null) {
          candidateRelation.load(query, collection, name_1, constraints);
        }
      }
    }
  };

  return Loader;
}();

var Rollcaller =
/** @class */
function () {
  function Rollcaller() {}
  /**
   * Set where constraint based on relationship existence.
   */


  Rollcaller.has = function (query, relation, operator, count) {
    this.setHas(query, relation, 'exists', operator, count);
  };
  /**
   * Set where constraint based on relationship absence.
   */


  Rollcaller.hasNot = function (query, relation, operator, count) {
    this.setHas(query, relation, 'doesntExist', operator, count);
  };
  /**
   * Add where has condition.
   */


  Rollcaller.whereHas = function (query, relation, constraint) {
    this.setHas(query, relation, 'exists', undefined, undefined, constraint);
  };
  /**
   * Add where has not condition.
   */


  Rollcaller.whereHasNot = function (query, relation, constraint) {
    this.setHas(query, relation, 'doesntExist', undefined, undefined, constraint);
  };
  /**
   * Set `has` condition.
   */


  Rollcaller.setHas = function (query, relation, type, operator, count, constraint) {
    if (operator === void 0) {
      operator = '>=';
    }

    if (count === void 0) {
      count = 1;
    }

    if (constraint === void 0) {
      constraint = null;
    }

    if (typeof operator === 'number') {
      query.have.push({
        relation: relation,
        type: type,
        operator: '>=',
        count: operator,
        constraint: constraint
      });
      return;
    }

    query.have.push({
      relation: relation,
      type: type,
      operator: operator,
      count: count,
      constraint: constraint
    });
  };
  /**
   * Convert `has` conditions to where clause. It will check any relationship
   * existence, or absence for the records then set ids of the records that
   * matched the condition to `where` clause.
   *
   * This way, when the query gets executed, only those records that matched
   * the `has` condition get retrieved. In the future, once relationship index
   * mapping is implemented, we can simply do all checks inside the where
   * filter since we can treat `has` condition as usual `where` condition.
   *
   * For now, since we must fetch any relationship by eager loading them, due
   * to performance concern, we'll apply `has` conditions this way to gain
   * maximum performance.
   */


  Rollcaller.applyConstraints = function (query) {
    if (query.have.length === 0) {
      return;
    }

    var newQuery = query.newQuery();
    this.addHasWhereConstraints(query, newQuery);
    this.addHasConstraints(query, newQuery.get());
  };
  /**
   * Add has constraints to the given query. It's going to set all relationship
   * as `with` alongside with its closure constraints.
   */


  Rollcaller.addHasWhereConstraints = function (query, newQuery) {
    query.have.forEach(function (constraint) {
      newQuery.with(constraint.relation, constraint.constraint);
    });
  };
  /**
   * Add has constraints as where clause.
   */


  Rollcaller.addHasConstraints = function (query, collection) {
    var comparators = this.getComparators(query);
    var ids = [];
    collection.forEach(function (model) {
      if (comparators.every(function (comparator) {
        return comparator(model);
      })) {
        ids.push(model.$self().getIdFromRecord(model));
      }
    });
    query.whereIdIn(ids);
  };
  /**
   * Get comparators for the has clause.
   */


  Rollcaller.getComparators = function (query) {
    var _this = this;

    return query.have.map(function (constraint) {
      return _this.getComparator(constraint);
    });
  };
  /**
   * Get a comparator for the has clause.
   */


  Rollcaller.getComparator = function (constraint) {
    var _this = this;

    var compare = this.getCountComparator(constraint.operator);
    return function (model) {
      var count = _this.getRelationshipCount(model[constraint.relation]);

      var result = compare(count, constraint.count);
      return constraint.type === 'exists' ? result : !result;
    };
  };
  /**
   * Get count of the relationship.
   */


  Rollcaller.getRelationshipCount = function (relation) {
    if (isArray(relation)) {
      return relation.length;
    }

    return relation ? 1 : 0;
  };
  /**
   * Get comparator function for the `has` clause.
   */


  Rollcaller.getCountComparator = function (operator) {
    switch (operator) {
      case '=':
        return function (x, y) {
          return x === y;
        };

      case '>':
        return function (x, y) {
          return x > y;
        };

      case '>=':
        return function (x, y) {
          return x >= y;
        };

      case '<':
        return function (x, y) {
          return x > 0 && x < y;
        };

      case '<=':
        return function (x, y) {
          return x > 0 && x <= y;
        };

      default:
        return function (x, y) {
          return x === y;
        };
    }
  };

  return Rollcaller;
}();

var Query =
/** @class */
function () {
  /**
   * Create a new Query instance.
   */
  function Query(store, entity) {
    /**
     * This flag lets us know if current Query instance applies to
     * a base class or not (in order to know when to filter out
     * some records).
     */
    this.appliedOnBase = true;
    /**
     * Primary key ids to filter records by. It is used for filtering records
     * direct key lookup when a user is trying to fetch records by its
     * primary key.
     *
     * It should not be used if there is a logic which prevents index usage, for
     * example, an "or" condition which already requires a full scan of records.
     */

    this.idFilter = null;
    /**
     * Whether to use `idFilter` key lookup. True if there is a logic which
     * prevents index usage, for example, an "or" condition which already
     * requires full scan.
     */

    this.cancelIdFilter = false;
    /**
     * Primary key ids to filter joined records. It is used for filtering
     * records direct key lookup. It should not be cancelled, because it
     * is free from the effects of normal where methods.
     */

    this.joinedIdFilter = null;
    /**
     * The where constraints for the query.
     */

    this.wheres = [];
    /**
     * The has constraints for the query.
     */

    this.have = [];
    /**
     * The orders of the query result.
     */

    this.orders = [];
    /**
     * Number of results to skip.
     */

    this.offsetNumber = 0;
    /**
     * Maximum number of records to return.
     *
     * We use polyfill of `Number.MAX_SAFE_INTEGER` for IE11 here.
     */

    this.limitNumber = Math.pow(2, 53) - 1;
    /**
     * The relationships that should be eager loaded with the result.
     */

    this.load = {};
    this.store = store;
    this.database = store.$db();
    this.model = this.getModel(entity);
    this.baseModel = this.getBaseModel(entity);
    this.entity = entity;
    this.baseEntity = this.baseModel.entity;
    this.rootState = this.database.getState();
    this.state = this.rootState[this.baseEntity];
    this.appliedOnBase = this.baseEntity === this.entity;
  }
  /**
   * Delete all records from the store.
   */


  Query.deleteAll = function (store) {
    var database = store.$db();
    var models = database.models();

    for (var entity in models) {
      var state = database.getState()[entity];
      state && new this(store, entity).deleteAll();
    }
  };
  /**
   * Register a global hook. It will return ID for the hook that users may use
   * it to unregister hooks.
   */


  Query.on = function (on, callback) {
    var id = ++this.lastHookId;

    if (!this.hooks[on]) {
      this.hooks[on] = [];
    }

    this.hooks[on].push({
      id: id,
      callback: callback
    });
    return id;
  };
  /**
   * Unregister global hook with the given id.
   */


  Query.off = function (id) {
    var _this = this;

    return Object.keys(this.hooks).some(function (on) {
      var hooks = _this.hooks[on];
      var index = hooks.findIndex(function (h) {
        return h.id === id;
      });

      if (index === -1) {
        return false;
      }

      hooks.splice(index, 1);
      return true;
    });
  };
  /**
   * Get query class.
   */


  Query.prototype.self = function () {
    return this.constructor;
  };
  /**
   * Create a new query instance.
   */


  Query.prototype.newQuery = function (entity) {
    entity = entity || this.entity;
    return new Query(this.store, entity);
  };
  /**
   * Get model of given name from the container.
   */


  Query.prototype.getModel = function (name) {
    var entity = name || this.entity;
    return this.database.model(entity);
  };
  /**
   * Get all models from the container.
   */


  Query.prototype.getModels = function () {
    return this.database.models();
  };
  /**
   * Get base model of given name from the container.
   */


  Query.prototype.getBaseModel = function (name) {
    return this.database.baseModel(name);
  };
  /**
   * Returns all record of the query chain result. This method is alias
   * of the `get` method.
   */


  Query.prototype.all = function () {
    return this.get();
  };
  /**
   * Find the record by the given id.
   */


  Query.prototype.find = function (value) {
    var record = this.state.data[this.normalizeIndexId(value)];

    if (!record) {
      return null;
    }

    return this.item(this.hydrate(record));
  };
  /**
   * Get the record of the given array of ids.
   */


  Query.prototype.findIn = function (values) {
    var _this = this;

    if (!Utils.isArray(values)) {
      return [];
    }

    var records = values.reduce(function (collection, value) {
      var record = _this.state.data[_this.normalizeIndexId(value)];

      if (!record) {
        return collection;
      }

      collection.push(_this.hydrate(record));
      return collection;
    }, []);
    return this.collect(records);
  };
  /**
   * Returns all record of the query chain result.
   */


  Query.prototype.get = function () {
    var records = this.select();
    return this.collect(records);
  };
  /**
   * Returns the first record of the query chain result.
   */


  Query.prototype.first = function () {
    var records = this.select();

    if (records.length === 0) {
      return null;
    }

    return this.item(this.hydrate(records[0]));
  };
  /**
   * Returns the last record of the query chain result.
   */


  Query.prototype.last = function () {
    var records = this.select();

    if (records.length === 0) {
      return null;
    }

    return this.item(this.hydrate(records[records.length - 1]));
  };
  /**
   * Checks whether a result of the query chain exists.
   */


  Query.prototype.exists = function () {
    var records = this.select();
    return records.length > 0;
  };
  /**
   * Add a and where clause to the query.
   */


  Query.prototype.where = function (field, value) {
    if (this.isIdfilterable(field)) {
      this.setIdFilter(value);
    }

    this.wheres.push({
      field: field,
      value: value,
      boolean: 'and'
    });
    return this;
  };
  /**
   * Add a or where clause to the query.
   */


  Query.prototype.orWhere = function (field, value) {
    // Cancel id filter usage, since "or" needs full scan.
    this.cancelIdFilter = true;
    this.wheres.push({
      field: field,
      value: value,
      boolean: 'or'
    });
    return this;
  };
  /**
   * Filter records by their primary key.
   */


  Query.prototype.whereId = function (value) {
    if (this.model.isCompositePrimaryKey()) {
      return this.where('$id', this.normalizeIndexId(value));
    }

    return this.where(this.model.primaryKey, value);
  };
  /**
   * Filter records by their primary keys.
   */


  Query.prototype.whereIdIn = function (values) {
    var _this = this;

    if (this.model.isCompositePrimaryKey()) {
      var idList = values.reduce(function (keys, value) {
        return __spreadArrays(keys, [_this.normalizeIndexId(value)]);
      }, []);
      return this.where('$id', idList);
    }

    return this.where(this.model.primaryKey, values);
  };
  /**
   * Fast comparison for foreign keys. If the foreign key is the primary key,
   * it uses object lookup, fallback normal where otherwise.
   *
   * Why separate `whereFk` instead of just `where`? Additional logic needed
   * for the distinction between where and orWhere in normal queries, but
   * Fk lookups are always "and" type.
   */


  Query.prototype.whereFk = function (field, value) {
    var values = Utils.isArray(value) ? value : [value]; // If lookup filed is the primary key. Initialize or get intersection,
    // because boolean and could have a condition such as
    // `whereId(1).whereId(2).get()`.

    if (field === this.model.primaryKey) {
      this.setJoinedIdFilter(values);
      return this;
    } // Else fallback to normal where.


    this.where(field, values);
    return this;
  };
  /**
   * Convert value to string for composite primary keys as it expects an array.
   * Otherwise return as is.
   *
   * Throws an error when malformed value is given:
   * - Composite primary key defined on model, expects value to be array.
   * - Normal primary key defined on model, expects a primitive value.
   */


  Query.prototype.normalizeIndexId = function (value) {
    if (this.model.isCompositePrimaryKey()) {
      if (!Utils.isArray(value)) {
        throw new Error('[Vuex ORM] Entity `' + this.entity + '` is configured with a composite ' + 'primary key and expects an array value but instead received: ' + JSON.stringify(value));
      }

      return JSON.stringify(value);
    }

    if (Utils.isArray(value)) {
      throw new Error('[Vuex ORM] Entity `' + this.entity + '` expects a single value but ' + 'instead received: ' + JSON.stringify(value));
    }

    return value;
  };
  /**
   * Check whether the given field is filterable through primary key
   * direct look up.
   */


  Query.prototype.isIdfilterable = function (field) {
    return (field === this.model.primaryKey || field === '$id') && !this.cancelIdFilter;
  };
  /**
   * Set id filter for the given where condition.
   */


  Query.prototype.setIdFilter = function (value) {
    var _this = this;

    var values = Utils.isArray(value) ? value : [value]; // Initialize or get intersection, because boolean and could have a
    // condition such as `whereIdIn([1,2,3]).whereIdIn([1,2]).get()`.

    if (this.idFilter === null) {
      this.idFilter = new Set(values);
      return;
    }

    this.idFilter = new Set(values.filter(function (v) {
      return _this.idFilter.has(v);
    }));
  };
  /**
   * Set joined id filter for the given where condition.
   */


  Query.prototype.setJoinedIdFilter = function (values) {
    var _this = this; // Initialize or get intersection, because boolean and could have a
    // condition such as `whereId(1).whereId(2).get()`.


    if (this.joinedIdFilter === null) {
      this.joinedIdFilter = new Set(values);
      return;
    }

    this.joinedIdFilter = new Set(values.filter(function (v) {
      return _this.joinedIdFilter.has(v);
    }));
  };
  /**
   * Add an order to the query.
   */


  Query.prototype.orderBy = function (key, direction) {
    if (direction === void 0) {
      direction = 'asc';
    }

    this.orders.push({
      key: key,
      direction: direction
    });
    return this;
  };
  /**
   * Add an offset to the query.
   */


  Query.prototype.offset = function (offset) {
    this.offsetNumber = offset;
    return this;
  };
  /**
   * Add limit to the query.
   */


  Query.prototype.limit = function (limit) {
    this.limitNumber = limit;
    return this;
  };
  /**
   * Set the relationships that should be loaded.
   */


  Query.prototype.with = function (name, constraint) {
    if (constraint === void 0) {
      constraint = null;
    }

    Loader.with(this, name, constraint);
    return this;
  };
  /**
   * Query all relations.
   */


  Query.prototype.withAll = function () {
    Loader.withAll(this);
    return this;
  };
  /**
   * Query all relations recursively.
   */


  Query.prototype.withAllRecursive = function (depth) {
    if (depth === void 0) {
      depth = 3;
    }

    Loader.withAllRecursive(this, depth);
    return this;
  };
  /**
   * Set where constraint based on relationship existence.
   */


  Query.prototype.has = function (relation, operator, count) {
    Rollcaller.has(this, relation, operator, count);
    return this;
  };
  /**
   * Set where constraint based on relationship absence.
   */


  Query.prototype.hasNot = function (relation, operator, count) {
    Rollcaller.hasNot(this, relation, operator, count);
    return this;
  };
  /**
   * Add where has condition.
   */


  Query.prototype.whereHas = function (relation, constraint) {
    Rollcaller.whereHas(this, relation, constraint);
    return this;
  };
  /**
   * Add where has not condition.
   */


  Query.prototype.whereHasNot = function (relation, constraint) {
    Rollcaller.whereHasNot(this, relation, constraint);
    return this;
  };
  /**
   * Get all records from the state and convert them into the array of
   * model instances.
   */


  Query.prototype.records = function () {
    var _this = this;

    this.finalizeIdFilter();
    return this.getIdsToLookup().reduce(function (models, id) {
      var record = _this.state.data[id];

      if (!record) {
        return models;
      }

      var model = _this.hydrate(record); // Ignore if the model is not current type of model.


      if (!_this.appliedOnBase && !(_this.model.entity === model.$self().entity)) {
        return models;
      }

      models.push(model);
      return models;
    }, []);
  };
  /**
   * Check whether if id filters should on select. If not, clear out id filter.
   */


  Query.prototype.finalizeIdFilter = function () {
    if (!this.cancelIdFilter || this.idFilter === null) {
      return;
    }

    this.where(this.model.isCompositePrimaryKey() ? '$id' : this.model.primaryKey, Array.from(this.idFilter.values()));
    this.idFilter = null;
  };
  /**
   * Get a list of id that should be used to lookup when fetching records
   * from the state.
   */


  Query.prototype.getIdsToLookup = function () {
    var _this = this; // If both id filter and joined id filter are set, intersect them.


    if (this.idFilter && this.joinedIdFilter) {
      return Array.from(this.idFilter.values()).filter(function (id) {
        return _this.joinedIdFilter.has(id);
      });
    } // If only either one is set, return which one is set.


    if (this.idFilter || this.joinedIdFilter) {
      return Array.from((this.idFilter || this.joinedIdFilter).values());
    } // If none is set, return all keys.


    return Object.keys(this.state.data);
  };
  /**
   * Process the query and filter data.
   */


  Query.prototype.select = function () {
    // At first, well apply any `has` condition to the query.
    Rollcaller.applyConstraints(this); // Next, get all record as an array and then start filtering it through.

    var records = this.records(); // Process `beforeSelect` hook.

    records = this.executeSelectHook('beforeSelect', records); // Let's filter the records at first by the where clauses.

    records = this.filterWhere(records); // Process `afterWhere` hook.

    records = this.executeSelectHook('afterWhere', records); // Next, lets sort the data.

    records = this.filterOrderBy(records); // Process `afterOrderBy` hook.

    records = this.executeSelectHook('afterOrderBy', records); // Finally, slice the record by limit and offset.

    records = this.filterLimit(records); // Process `afterLimit` hook.

    records = this.executeSelectHook('afterLimit', records);
    return records;
  };
  /**
   * Filter the given data by registered where clause.
   */


  Query.prototype.filterWhere = function (records) {
    return Filter.where(this, records);
  };
  /**
   * Sort the given data by registered orders.
   */


  Query.prototype.filterOrderBy = function (records) {
    return Filter.orderBy(this, records);
  };
  /**
   * Limit the given records by the limit and offset.
   */


  Query.prototype.filterLimit = function (records) {
    return Filter.limit(this, records);
  };
  /**
   * Get the count of the retrieved data.
   */


  Query.prototype.count = function () {
    return this.get().length;
  };
  /**
   * Get the max value of the specified filed.
   */


  Query.prototype.max = function (field) {
    var numbers = this.get().reduce(function (numbers, item) {
      if (typeof item[field] === 'number') {
        numbers.push(item[field]);
      }

      return numbers;
    }, []);
    return numbers.length === 0 ? 0 : Math.max.apply(Math, numbers);
  };
  /**
   * Get the min value of the specified filed.
   */


  Query.prototype.min = function (field) {
    var numbers = this.get().reduce(function (numbers, item) {
      if (typeof item[field] === 'number') {
        numbers.push(item[field]);
      }

      return numbers;
    }, []);
    return numbers.length === 0 ? 0 : Math.min.apply(Math, numbers);
  };
  /**
   * Get the sum value of the specified filed.
   */


  Query.prototype.sum = function (field) {
    return this.get().reduce(function (sum, item) {
      if (typeof item[field] === 'number') {
        sum += item[field];
      }

      return sum;
    }, 0);
  };
  /**
   * Create a item from given record.
   */


  Query.prototype.item = function (item) {
    if (Object.keys(this.load).length > 0) {
      Loader.eagerLoadRelations(this, [item]);
    }

    return item;
  };
  /**
   * Create a collection (array) from given records.
   */


  Query.prototype.collect = function (collection) {
    var _this = this;

    if (collection.length < 1) {
      return [];
    }

    if (Object.keys(this.load).length > 0) {
      collection = collection.map(function (item) {
        var model = _this.model.getModelFromRecord(item);

        return new model(item);
      });
      Loader.eagerLoadRelations(this, collection);
    }

    return collection;
  };
  /**
   * Create new data with all fields filled by default values.
   */


  Query.prototype.new = function () {
    var model = new this.model().$generateId();
    this.commitInsert(model.$getAttributes());
    return model;
  };
  /**
   * Save given data to the store by replacing all existing records in the
   * store. If you want to save data without replacing existing records,
   * use the `insert` method instead.
   */


  Query.prototype.create = function (data, options) {
    return this.persist('create', data, options);
  };
  /**
   * Create records to the state.
   */


  Query.prototype.createRecords = function (records) {
    this.deleteAll();
    return this.insertRecords(records);
  };
  /**
   * Insert given data to the store. Unlike `create`, this method will not
   * remove existing data within the store, but it will update the data
   * with the same primary key.
   */


  Query.prototype.insert = function (data, options) {
    return this.persist('insert', data, options);
  };
  /**
   * Insert records to the store.
   */


  Query.prototype.insertRecords = function (records) {
    var collection = this.mapHydrateRecords(records);
    collection = this.executeMutationHooks('beforeCreate', collection);
    this.commitInsertRecords(this.convertCollectionToRecords(collection));
    this.executeMutationHooks('afterCreate', collection);
    return collection;
  };
  /**
   * Update data in the state.
   */


  Query.prototype.update = function (data, condition, options) {
    // If the data is array, simply normalize the data and update them.
    if (Utils.isArray(data)) {
      return this.persist('update', data, options);
    } // OK, the data is not an array. Now let's check `data` to see what we can
    // do if it's a closure.


    if (typeof data === 'function') {
      // If the data is closure, but if there's no condition, we wouldn't know
      // what record to update so raise an error and abort.
      if (!condition) {
        throw new Error('You must specify `where` to update records by specifying `data` as a closure.');
      } // If the condition is a closure, then update records by the closure.


      if (typeof condition === 'function') {
        return this.updateByCondition(data, condition);
      } // Else the condition is either String or Number, so let's
      // update the record by ID.


      return this.updateById(data, condition);
    } // Now the data is not a closure, and it's not an array, so it should be an object.
    // If the condition is closure, we can't normalize the data so let's update
    // records using the closure.


    if (typeof condition === 'function') {
      return this.updateByCondition(data, condition);
    } // If there's no condition, let's normalize the data and update them.


    if (!condition) {
      return this.persist('update', data, options);
    } // Now since the condition is either String or Number, let's check if the
    // model's primary key is not a composite key. If yes, we can't set the
    // condition as ID value for the record so throw an error and abort.


    if (this.model.isCompositePrimaryKey() && !Utils.isArray(condition)) {
      throw new Error('[Vuex ORM] You can\'t specify `where` value as `string` or `number` ' + 'when you have a composite key defined in your model. Please include ' + 'composite keys to the `data` fields.');
    } // Finally, let's add condition as the primary key of the object and
    // then normalize them to update the records.


    return this.updateById(data, condition);
  };
  /**
   * Update all records.
   */


  Query.prototype.updateRecords = function (records) {
    var models = this.hydrateRecordsByMerging(records);
    return this.performUpdate(models);
  };
  /**
   * Update the state by id.
   */


  Query.prototype.updateById = function (data, id) {
    var _a;

    id = typeof id === 'number' ? id.toString() : this.normalizeIndexId(id);
    var record = this.state.data[id];

    if (!record) {
      return null;
    }

    var model = this.hydrate(record);
    var instances = (_a = {}, _a[id] = this.processUpdate(data, model), _a);
    this.performUpdate(instances);
    return instances[id];
  };
  /**
   * Update the state by condition.
   */


  Query.prototype.updateByCondition = function (data, condition) {
    var _this = this;

    var instances = Object.keys(this.state.data).reduce(function (instances, id) {
      var instance = _this.hydrate(_this.state.data[id]);

      if (!condition(instance)) {
        return instances;
      }

      instances[id] = _this.processUpdate(data, instance);
      return instances;
    }, {});
    return this.performUpdate(instances);
  };
  /**
   * Update the given record with given data.
   */


  Query.prototype.processUpdate = function (data, instance) {
    if (typeof data === 'function') {
      data(instance);
      return instance;
    } // When the updated instance is not the base model, we tell te hydrate what model to use


    if (instance.constructor !== this.model && instance instanceof Model) {
      return this.hydrate(__assign(__assign({}, instance), data), instance.constructor);
    }

    return this.hydrate(__assign(__assign({}, instance), data));
  };
  /**
   * Commit `update` to the state.
   */


  Query.prototype.performUpdate = function (models) {
    var _this = this;

    models = this.updateIndexes(models);
    var beforeHooks = this.buildHooks('beforeUpdate');
    var afterHooks = this.buildHooks('afterUpdate');
    var updated = [];

    var _loop_1 = function (id) {
      var model = models[id];

      if (beforeHooks.some(function (hook) {
        return hook(model, null, _this.entity) === false;
      })) {
        return "continue";
      }

      this_1.commitInsert(model.$getAttributes());
      afterHooks.forEach(function (hook) {
        hook(model, null, _this.entity);
      });
      updated.push(model);
    };

    var this_1 = this;

    for (var id in models) {
      _loop_1(id);
    }

    return updated;
  };
  /**
   * Update the key of the instances. This is needed when a user updates
   * record's primary key. We must then update the index key to
   * correspond with new id value.
   */


  Query.prototype.updateIndexes = function (instances) {
    var _this = this;

    return Object.keys(instances).reduce(function (instances, key) {
      var instance = instances[key];
      var id = String(_this.model.getIndexIdFromRecord(instance));

      if (key !== id) {
        instance.$id = id;
        instances[id] = instance;
        delete instances[key];
      }

      return instances;
    }, instances);
  };
  /**
   * Insert or update given data to the state. Unlike `insert`, this method
   * will not replace existing data within the state, but it will update only
   * the submitted data with the same primary key.
   */


  Query.prototype.insertOrUpdate = function (data, options) {
    return this.persist('insertOrUpdate', data, options);
  };
  /**
   * Insert or update the records.
   */


  Query.prototype.insertOrUpdateRecords = function (records) {
    var _this = this;

    var toBeInserted = {};
    var toBeUpdated = {};
    Object.keys(records).forEach(function (id) {
      var record = records[id];

      if (_this.state.data[id]) {
        toBeUpdated[id] = record;
        return;
      }

      toBeInserted[id] = record;
    });
    return __spreadArrays(this.insertRecords(toBeInserted), this.updateRecords(toBeUpdated));
  };
  /**
   * Persist data into the state while preserving it's original structure.
   */


  Query.prototype.persist = function (method, data, options) {
    var _this = this;

    var clonedData = Utils.cloneDeep(data);
    var normalizedData = this.normalize(clonedData);

    if (Utils.isEmpty(normalizedData)) {
      if (method === 'create') {
        this.emptyState();
      }

      return {};
    }

    return Object.entries(normalizedData).reduce(function (collections, _a) {
      var entity = _a[0],
          records = _a[1];

      var newQuery = _this.newQuery(entity);

      var methodForEntity = _this.getPersistMethod(entity, options, method);

      var collection = newQuery.persistRecords(methodForEntity, records);

      if (collection.length > 0) {
        collections[entity] = collection;
      }

      return collections;
    }, {});
  };
  /**
   * Persist given records to the store by the given method.
   */


  Query.prototype.persistRecords = function (method, records) {
    switch (method) {
      case 'create':
        return this.createRecords(records);

      case 'insert':
        return this.insertRecords(records);

      case 'update':
        return this.updateRecords(records);

      case 'insertOrUpdate':
        return this.insertOrUpdateRecords(records);
    }
  };
  /**
   * Get persist method from given information.
   */


  Query.prototype.getPersistMethod = function (entity, options, fallback) {
    if (options.create && options.create.includes(entity)) {
      return 'create';
    }

    if (options.insert && options.insert.includes(entity)) {
      return 'insert';
    }

    if (options.update && options.update.includes(entity)) {
      return 'update';
    }

    if (options.insertOrUpdate && options.insertOrUpdate.includes(entity)) {
      return 'insertOrUpdate';
    }

    return fallback;
  };

  Query.prototype.delete = function (condition) {
    if (typeof condition === 'function') {
      return this.deleteByCondition(condition);
    }

    return this.deleteById(condition);
  };
  /**
   * Delete all records from the store. Even when deleting all records, we'll
   * iterate over all records to ensure that before and after hook will be
   * called for each existing records.
   */


  Query.prototype.deleteAll = function () {
    var _this = this; // If the target entity is the base entity and not inherited entity, we can
    // just delete all records.


    if (this.appliedOnBase) {
      return this.deleteByCondition(function () {
        return true;
      });
    } // Otherwise, we should filter out any derived entities from being deleted
    // so we'll add such filter here.


    return this.deleteByCondition(function (model) {
      return model.$self().entity === _this.model.entity;
    });
  };
  /**
   * Delete a record from the store by given id.
   */


  Query.prototype.deleteById = function (id) {
    var item = this.find(id);

    if (!item) {
      return null;
    }

    return this.deleteByCondition(function (model) {
      return model.$id === item.$id;
    })[0];
  };
  /**
   * Perform the actual delete query to the store.
   */


  Query.prototype.deleteByCondition = function (condition) {
    var collection = this.mapHydrateAndFilterRecords(this.state.data, condition);
    collection = this.executeMutationHooks('beforeDelete', collection);

    if (collection.length === 0) {
      return [];
    }

    this.commitDelete(collection.map(function (model) {
      return model.$id;
    }));
    this.executeMutationHooks('afterDelete', collection);
    return collection;
  };
  /**
   * Commit mutation.
   */


  Query.prototype.commit = function (name, payload) {
    this.store.commit(this.database.namespace + "/" + name, __assign({
      entity: this.baseEntity
    }, payload));
  };
  /**
   * Commit insert mutation.
   */


  Query.prototype.commitInsert = function (record) {
    this.commit('insert', {
      record: record
    });
  };
  /**
   * Commit insert records mutation.
   */


  Query.prototype.commitInsertRecords = function (records) {
    this.commit('insertRecords', {
      records: records
    });
  };
  /**
   * Commit delete mutation.
   */


  Query.prototype.commitDelete = function (id) {
    this.commit('delete', {
      id: id
    });
  };
  /**
   * Normalize the given data.
   */


  Query.prototype.normalize = function (data) {
    return Processor.normalize(this, data);
  };
  /**
   * Convert given record to the model instance.
   */


  Query.prototype.hydrate = function (record, forceModel) {
    var _a;

    if (forceModel) {
      return new forceModel(record);
    }

    var newModel = this.model.getModelFromRecord(record);

    if (newModel !== null) {
      return new newModel(record);
    }

    if (!this.appliedOnBase && record[this.model.typeKey] === undefined) {
      var typeValue = this.model.getTypeKeyValueFromModel();
      record = __assign(__assign({}, record), (_a = {}, _a[this.model.typeKey] = typeValue, _a));
      return new this.model(record);
    }

    var baseModel = this.getBaseModel(this.entity);
    return new baseModel(record);
  };
  /**
   * Convert given records to instances by merging existing record. If there's
   * no existing record, that record will not be included in the result.
   */


  Query.prototype.hydrateRecordsByMerging = function (records) {
    var _this = this;

    return Object.keys(records).reduce(function (instances, id) {
      var recordInStore = _this.state.data[id];

      if (!recordInStore) {
        return instances;
      }

      var record = records[id];

      var modelForRecordInStore = _this.model.getModelFromRecord(recordInStore);

      if (modelForRecordInStore === null) {
        instances[id] = _this.hydrate(__assign(__assign({}, recordInStore), record));
        return instances;
      }

      instances[id] = _this.hydrate(__assign(__assign({}, recordInStore), record), modelForRecordInStore);
      return instances;
    }, {});
  };
  /**
   * Convert all given records and return it as a collection.
   */


  Query.prototype.mapHydrateRecords = function (records) {
    var _this = this;

    return Utils.map(records, function (record) {
      return _this.hydrate(record);
    });
  };
  /**
   * Convert all given records and return it as a collection.
   */


  Query.prototype.mapHydrateAndFilterRecords = function (records, condition) {
    var collection = [];

    for (var key in records) {
      var model = this.hydrate(records[key]);
      condition(model) && collection.push(model);
    }

    return collection;
  };
  /**
   * Convert given collection to records by using index id as a key.
   */


  Query.prototype.convertCollectionToRecords = function (collection) {
    return collection.reduce(function (carry, model) {
      carry[model['$id']] = model.$getAttributes();
      return carry;
    }, {});
  };
  /**
   * Clears the current state from any data related to current model.
   *
   * - Everything if not in a inheritance scheme.
   * - Only derived instances if applied to a derived entity.
   */


  Query.prototype.emptyState = function () {
    this.deleteAll();
  };
  /**
   * Build executable hook collection for the given hook.
   */


  Query.prototype.buildHooks = function (on) {
    var hooks = this.getGlobalHookAsArray(on);
    var localHook = this.model[on];
    localHook && hooks.push(localHook.bind(this.model));
    return hooks;
  };
  /**
   * Get global hook of the given name as array by stripping id key and keep
   * only hook functions.
   */


  Query.prototype.getGlobalHookAsArray = function (on) {
    var _this = this;

    var hooks = this.self().hooks[on];
    return hooks ? hooks.map(function (h) {
      return h.callback.bind(_this);
    }) : [];
  };
  /**
   * Execute mutation hooks to the given collection.
   */


  Query.prototype.executeMutationHooks = function (on, collection) {
    var _this = this;

    var hooks = this.buildHooks(on);

    if (hooks.length === 0) {
      return collection;
    }

    return collection.filter(function (model) {
      return !hooks.some(function (hook) {
        return hook(model, null, _this.entity) === false;
      });
    });
  };
  /**
   * Execute retrieve hook for the given method.
   */


  Query.prototype.executeSelectHook = function (on, models) {
    var _this = this;

    var hooks = this.buildHooks(on);
    return hooks.reduce(function (collection, hook) {
      collection = hook(models, _this.entity);
      return collection;
    }, models);
  };
  /**
   * The global lifecycle hook registries.
   */


  Query.hooks = {};
  /**
   * The counter to generate the UID for global hooks.
   */

  Query.lastHookId = 0;
  return Query;
}();
/**
 * Create a new Query instance.
 */


function query$1(_state) {
  var _this = this;

  return function (entity) {
    return new Query(_this, entity);
  };
}
/**
 * Get all data of given entity.
 */


function all$1(_state) {
  var _this = this;

  return function (entity) {
    return new Query(_this, entity).all();
  };
}
/**
 * Find a data of the given entity by given id.
 */


function find$1(_state) {
  var _this = this;

  return function (entity, id) {
    return new Query(_this, entity).find(id);
  };
}
/**
 * Find a data of the given entity by given id.
 */


function findIn$1(_state) {
  var _this = this;

  return function (entity, idList) {
    return new Query(_this, entity).findIn(idList);
  };
}

var RootGetters = {
  query: query$1,
  all: all$1,
  find: find$1,
  findIn: findIn$1
};

var OptionsBuilder =
/** @class */
function () {
  function OptionsBuilder() {}
  /**
   * Get persist options from the given payload.
   */


  OptionsBuilder.createPersistOptions = function (payload) {
    return {
      create: payload.create,
      insert: payload.insert,
      update: payload.update,
      insertOrUpdate: payload.insertOrUpdate
    };
  };

  return OptionsBuilder;
}();
/**
 * Create new data with all fields filled by default values.
 */


function newRecord$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_a) {
      return [2
      /*return*/
      , new Query(this, payload.entity).new()];
    });
  });
}
/**
 * Save given data to the store by replacing all existing records in the
 * store. If you want to save data without replacing existing records,
 * use the `insert` method instead.
 */


function create$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var entity, data, options;
    return __generator(this, function (_a) {
      entity = payload.entity;
      data = payload.data;
      options = OptionsBuilder.createPersistOptions(payload);
      return [2
      /*return*/
      , new Query(this, entity).create(data, options)];
    });
  });
}
/**
 * Insert given data to the state. Unlike `create`, this method will not
 * remove existing data within the state, but it will update the data
 * with the same primary key.
 */


function insert$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var entity, data, options;
    return __generator(this, function (_a) {
      entity = payload.entity;
      data = payload.data;
      options = OptionsBuilder.createPersistOptions(payload);
      return [2
      /*return*/
      , new Query(this, entity).insert(data, options)];
    });
  });
}
/**
 * Update data in the store.
 */


function update$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var entity, data, where, options;
    return __generator(this, function (_a) {
      entity = payload.entity;
      data = payload.data;
      where = payload.where || null;
      options = OptionsBuilder.createPersistOptions(payload);
      return [2
      /*return*/
      , new Query(this, entity).update(data, where, options)];
    });
  });
}
/**
 * Insert or update given data to the state. Unlike `insert`, this method
 * will not replace existing data within the state, but it will update only
 * the submitted data with the same primary key.
 */


function insertOrUpdate$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var entity, data, options;
    return __generator(this, function (_a) {
      entity = payload.entity;
      data = payload.data;
      options = OptionsBuilder.createPersistOptions(payload);
      return [2
      /*return*/
      , new Query(this, entity).insertOrUpdate(data, options)];
    });
  });
}

function destroy$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    var entity, where;
    return __generator(this, function (_a) {
      entity = payload.entity, where = payload.where;
      return [2
      /*return*/
      , new Query(this, entity).delete(where)];
    });
  });
}
/**
 * Delete all data from the store.
 */


function deleteAll$1(_context, payload) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_a) {
      if (payload && payload.entity) {
        new Query(this, payload.entity).deleteAll();
        return [2
        /*return*/
        ];
      }

      Query.deleteAll(this);
      return [2
      /*return*/
      ];
    });
  });
}

var RootActions = {
  new: newRecord$1,
  create: create$1,
  insert: insert$1,
  update: update$1,
  insertOrUpdate: insertOrUpdate$1,
  delete: destroy$1,
  deleteAll: deleteAll$1
};

var Connection =
/** @class */
function () {
  /**
   * Create a new connection instance.
   */
  function Connection(store, connection, entity) {
    this.store = store;
    this.connection = connection;
    this.entity = entity;
    this.rootState = this.store.state[connection];
    this.state = this.rootState[entity];
  }
  /**
   * Insert the given record.
   */


  Connection.prototype.insert = function (record) {
    var _a;

    this.state.data = __assign(__assign({}, this.state.data), (_a = {}, _a[record.$id] = record, _a));
  };
  /**
   * Insert the given records.
   */


  Connection.prototype.insertRecords = function (records) {
    this.state.data = __assign(__assign({}, this.state.data), records);
  };
  /**
   * Delete records that matches the given id.
   */


  Connection.prototype.delete = function (id) {
    var data = {};

    for (var i in this.state.data) {
      if (!id.includes(i)) {
        data[i] = this.state.data[i];
      }
    }

    this.state.data = data;
  };

  return Connection;
}();
/**
 * Execute generic mutation. This method is used by `Model.commit` method so
 * that user can commit any state changes easily through models.
 */


function $mutate(state, payload) {
  payload.callback(state[payload.entity]);
}
/**
 * Insert the given record.
 */


function insert$2(state, payload) {
  var entity = payload.entity,
      record = payload.record;
  new Connection(this, state.$name, entity).insert(record);
}
/**
 * Insert the given records.
 */


function insertRecords(state, payload) {
  var entity = payload.entity,
      records = payload.records;
  new Connection(this, state.$name, entity).insertRecords(records);
}
/**
 * Delete records from the store. The actual name for this mutation is
 * `delete`, but named `destroy` here because `delete` can't be declared at
 * this scope level.
 */


function destroy$2(state, payload) {
  var entity = payload.entity,
      id = payload.id;
  new Connection(this, state.$name, entity).delete(id);
}

var RootMutations = {
  $mutate: $mutate,
  insert: insert$2,
  insertRecords: insertRecords,
  delete: destroy$2
};

var IdAttribute =
/** @class */
function () {
  function IdAttribute() {}
  /**
   * Creates a closure that generates the required id's for an entity.
   */


  IdAttribute.create = function (model) {
    var _this = this;

    return function (value, _parentValue, _key) {
      _this.generateIds(value, model);

      var indexId = _this.generateIndexId(value, model);

      return indexId;
    };
  };
  /**
   * Generate a field that is defined as primary keys. For keys with a proper
   * value set, it will do nothing. If a key is missing, it will generate
   * UID for it.
   */


  IdAttribute.generateIds = function (record, model) {
    var keys = isArray(model.primaryKey) ? model.primaryKey : [model.primaryKey];
    keys.forEach(function (k) {
      if (record[k] !== undefined && record[k] !== null) {
        return;
      }

      var attr = model.getFields()[k];
      record[k] = attr instanceof Uid$1 ? attr.make() : Uid.make();
    });
  };
  /**
   * Generate index id field (which is `$id`) and attach to the given record.
   */


  IdAttribute.generateIndexId = function (record, model) {
    record.$id = model.getIndexIdFromRecord(record);
    return record.$id;
  };

  return IdAttribute;
}();

var Schema =
/** @class */
function () {
  /**
   * Create a new schema instance.
   */
  function Schema(model) {
    var _this = this;
    /**
     * List of generated schemas.
     */


    this.schemas = {};
    this.model = model;
    var models = model.database().models();
    Object.keys(models).forEach(function (name) {
      _this.one(models[name]);
    });
  }
  /**
   * Create a schema for the given model.
   */


  Schema.create = function (model) {
    return new this(model).one();
  };
  /**
   * Create a single schema for the given model.
   */


  Schema.prototype.one = function (model) {
    model = model || this.model;

    if (this.schemas[model.entity]) {
      return this.schemas[model.entity];
    }

    var schema$1 = new schema.Entity(model.entity, {}, {
      idAttribute: IdAttribute.create(model)
    });
    this.schemas[model.entity] = schema$1;
    var definition = this.definition(model);
    schema$1.define(definition);
    return schema$1;
  };
  /**
   * Create an array schema for the given model.
   */


  Schema.prototype.many = function (model) {
    return new schema.Array(this.one(model));
  };
  /**
   * Create an union schema for the given model.
   */


  Schema.prototype.union = function (callback) {
    return new schema.Union(this.schemas, callback);
  };
  /**
   * Create a dfinition for the given model.
   */


  Schema.prototype.definition = function (model) {
    var _this = this;

    var fields = model.getFields();
    return Object.keys(fields).reduce(function (definition, key) {
      var field = fields[key];

      if (field instanceof Relation) {
        definition[key] = field.define(_this);
      }

      return definition;
    }, {});
  };

  return Schema;
}();

var Database =
/** @class */
function () {
  function Database() {
    /**
     * The list of entities. It contains models and modules with its name.
     * The name is going to be the namespace for the Vuex Modules.
     */
    this.entities = [];
    /**
     * The normalizr schema.
     */

    this.schemas = {};
    /**
     * Whether the database has already been installed to Vuex or not.
     * Model registration steps depend on its value.
     */

    this.isStarted = false;
  }
  /**
   * Initialize the database before a user can start using it.
   */


  Database.prototype.start = function (store, namespace) {
    this.store = store;
    this.namespace = namespace;
    this.connect();
    this.registerModules();
    this.createSchema();
    this.isStarted = true;
  };
  /**
   * Register a model and a module to Database.
   */


  Database.prototype.register = function (model, module) {
    if (module === void 0) {
      module = {};
    }

    this.checkModelTypeMappingCapability(model);
    var entity = {
      name: model.entity,
      base: model.baseEntity || model.entity,
      model: this.createBindingModel(model),
      module: module
    };
    this.entities.push(entity);

    if (this.isStarted) {
      this.registerModule(entity);
      this.registerSchema(entity);
    }
  };

  Database.prototype.model = function (model) {
    var name = typeof model === 'string' ? model : model.entity;
    var m = this.models()[name];

    if (!m) {
      throw new Error("[Vuex ORM] Could not find the model `" + name + "`. Please check if you " + 'have registered the model to the database.');
    }

    return m;
  };

  Database.prototype.baseModel = function (model) {
    var name = typeof model === 'string' ? model : model.entity;
    var m = this.baseModels()[name];

    if (!m) {
      throw new Error("[Vuex ORM] Could not find the model `" + name + "`. Please check if you " + 'have registered the model to the database.');
    }

    return m;
  };
  /**
   * Get all models from the entities list.
   */


  Database.prototype.models = function () {
    return this.entities.reduce(function (models, entity) {
      models[entity.name] = entity.model;
      return models;
    }, {});
  };
  /**
   * Get all base models from the entities list.
   */


  Database.prototype.baseModels = function () {
    var _this = this;

    return this.entities.reduce(function (models, entity) {
      models[entity.name] = _this.model(entity.base);
      return models;
    }, {});
  };
  /**
   * Get the module of the given name from the entities list.
   */


  Database.prototype.module = function (name) {
    var module = this.modules()[name];

    if (!module) {
      throw new Error("[Vuex ORM] Could not find the module `" + name + "`. Please check if you " + 'have registered the module to the database.');
    }

    return module;
  };
  /**
   * Get all modules from the entities list.
   */


  Database.prototype.modules = function () {
    return this.entities.reduce(function (modules, entity) {
      modules[entity.name] = entity.module;
      return modules;
    }, {});
  };
  /**
   * Get the root state from the store.
   */


  Database.prototype.getState = function () {
    return this.store.state[this.namespace];
  };
  /**
   * Create a new model that binds the database.
   *
   * Transpiled classes cannot extend native classes. Implemented a workaround
   * until Babel releases a fix (https://github.com/babel/babel/issues/9367).
   */


  Database.prototype.createBindingModel = function (model) {
    var _this = this;

    var proxy;

    try {
      proxy = new Function('model', "\n        'use strict';\n        return class " + model.name + " extends model {}\n      ")(model);
    } catch (_a) {
      /* istanbul ignore next: rollback (mostly <= IE10) */
      proxy =
      /** @class */
      function (_super) {
        __extends(proxy, _super);

        function proxy() {
          return _super !== null && _super.apply(this, arguments) || this;
        }

        return proxy;
      }(model);
      /* istanbul ignore next: allocate model name */


      Object.defineProperty(proxy, 'name', {
        get: function () {
          return model.name;
        }
      });
    }

    Object.defineProperty(proxy, 'store', {
      value: function () {
        return _this.store;
      }
    });
    return proxy;
  };
  /**
   * Create Vuex Module from the registered entities, and register to
   * the store.
   */


  Database.prototype.registerModules = function () {
    this.store.registerModule(this.namespace, this.createModule());
  };
  /**
   * Generate module from the given entity, and register to the store.
   */


  Database.prototype.registerModule = function (entity) {
    this.store.registerModule([this.namespace, entity.name], this.createSubModule(entity));
  };
  /**
   * Create Vuex Module from the registered entities.
   */


  Database.prototype.createModule = function () {
    var _this = this;

    var module = this.createRootModule();
    this.entities.forEach(function (entity) {
      module.modules[entity.name] = _this.createSubModule(entity);
    });
    return module;
  };
  /**
   * Create root module.
   */


  Database.prototype.createRootModule = function () {
    return {
      namespaced: true,
      state: this.createRootState(),
      getters: this.createRootGetters(),
      actions: this.createRootActions(),
      mutations: this.createRootMutations(),
      modules: {}
    };
  };
  /**
   * Create root state.
   */


  Database.prototype.createRootState = function () {
    var _this = this;

    return function () {
      return {
        $name: _this.namespace
      };
    };
  };
  /**
   * Create root getters. For the getters, we bind the store instance to each
   * function to retrieve database instances within getters. We only need this
   * for the getter since actions and mutations are already bound to store.
   */


  Database.prototype.createRootGetters = function () {
    var _this = this;

    return mapValues(RootGetters, function (_getter, name) {
      return RootGetters[name].bind(_this.store);
    });
  };
  /**
   * Create root actions.
   */


  Database.prototype.createRootActions = function () {
    return RootActions;
  };
  /**
   * Create root mutations.
   */


  Database.prototype.createRootMutations = function () {
    return RootMutations;
  };
  /**
   * Create sub module.
   */


  Database.prototype.createSubModule = function (entity) {
    return {
      namespaced: true,
      state: this.createSubState(entity),
      getters: this.createSubGetters(entity),
      actions: this.createSubActions(entity),
      mutations: this.createSubMutations(entity)
    };
  };
  /**
   * Create sub state.
   */


  Database.prototype.createSubState = function (entity) {
    var _this = this;

    var name = entity.name,
        model = entity.model,
        module = entity.module;
    var modelState = typeof model.state === 'function' ? model.state() : model.state;
    var moduleState = typeof module.state === 'function' ? module.state() : module.state;
    return function () {
      return __assign(__assign(__assign({}, modelState), moduleState), {
        $connection: _this.namespace,
        $name: name,
        data: {}
      });
    };
  };
  /**
   * Create sub getters.
   */


  Database.prototype.createSubGetters = function (entity) {
    return __assign(__assign({}, Getters), entity.module.getters);
  };
  /**
   * Create sub actions.
   */


  Database.prototype.createSubActions = function (entity) {
    return __assign(__assign({}, Actions), entity.module.actions);
  };
  /**
   * Create sub mutations.
   */


  Database.prototype.createSubMutations = function (entity) {
    var _a;

    return _a = entity.module.mutations, _a !== null && _a !== void 0 ? _a : {};
  };
  /**
   * Create the schema definition from registered entities list and set it to
   * the `schema` property. This schema will be used by the normalizer
   * to normalize data before persisting them to the Vuex Store.
   */


  Database.prototype.createSchema = function () {
    var _this = this;

    this.entities.forEach(function (entity) {
      _this.registerSchema(entity);
    });
  };
  /**
   * Generate schema from the given entity.
   */


  Database.prototype.registerSchema = function (entity) {
    this.schemas[entity.name] = Schema.create(entity.model);
  };
  /**
   * Inject database to the store instance.
   */


  Database.prototype.connect = function () {
    var _this = this;

    this.store.$db = function () {
      return _this;
    };
  };
  /**
   * Warn user if the given model is a type of an inherited model that is being
   * defined without overwriting `Model.types()` because the user will not be
   * able to use the type mapping feature in this case.
   */


  Database.prototype.checkModelTypeMappingCapability = function (model) {
    // We'll not be logging any warning if it's on a production environment,
    // so let's return here if it is.

    /* istanbul ignore next */
    if (true) {
      return;
    } // If the model doesn't have `baseEntity` property set, we'll assume it is
    // not an inherited model so we can stop here.


    if (!model.baseEntity) {
      return;
    } // Now it seems like the model is indeed an inherited model. Let's check if
    // it has `types()` method declared, or we'll warn the user that it's not
    // possible to use type mapping feature.


    var baseModel = this.model(model.baseEntity);

    if (baseModel && baseModel.types === Model.types) {
      console.warn("[Vuex ORM] Model `" + model.name + "` extends `" + baseModel.name + "` which doesn't " + 'overwrite Model.types(). You will not be able to use type mapping.');
    }
  };

  return Database;
}();

function use(plugin, options) {
  if (options === void 0) {
    options = {};
  }

  var components = {
    Model: Model,
    Attribute: Attribute,
    Type: Type,
    Attr: Attr,
    String: String$1,
    Number: Number,
    Boolean: Boolean,
    Uid: Uid$1,
    Relation: Relation,
    HasOne: HasOne,
    BelongsTo: BelongsTo,
    HasMany: HasMany,
    HasManyBy: HasManyBy,
    BelongsToMany: BelongsToMany,
    HasManyThrough: HasManyThrough,
    MorphTo: MorphTo,
    MorphOne: MorphOne,
    MorphMany: MorphMany,
    MorphToMany: MorphToMany,
    MorphedByMany: MorphedByMany,
    Getters: Getters,
    Actions: Actions,
    RootGetters: RootGetters,
    RootActions: RootActions,
    RootMutations: RootMutations,
    Query: Query,
    Database: Database
  };
  plugin.install(components, options);
}

var index = {
  install: install,
  use: use,
  Container: Container,
  Database: Database,
  Model: Model,
  Attribute: Attribute,
  Type: Type,
  Attr: Attr,
  String: String$1,
  Number: Number,
  Boolean: Boolean,
  Uid: Uid$1,
  Relation: Relation,
  HasOne: HasOne,
  BelongsTo: BelongsTo,
  HasMany: HasMany,
  HasManyBy: HasManyBy,
  BelongsToMany: BelongsToMany,
  HasManyThrough: HasManyThrough,
  MorphTo: MorphTo,
  MorphOne: MorphOne,
  MorphMany: MorphMany,
  MorphToMany: MorphToMany,
  MorphedByMany: MorphedByMany,
  Getters: Getters,
  Actions: Actions,
  RootGetters: RootGetters,
  RootActions: RootActions,
  RootMutations: RootMutations,
  Query: Query
};
/* harmony default export */ __webpack_exports__["c"] = (index);


/***/ }),
/* 11 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Activity; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _meta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _createSuper(a){var b=_isNativeReflectConstruct();return function(){var c,d=_getPrototypeOf(a);if(b){var e=_getPrototypeOf(this).constructor;c=Reflect.construct(d,arguments,e)}else c=d.apply(this,arguments);return _possibleConstructorReturn(this,c)}}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(a){return!1}}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var Activity=/*#__PURE__*/function(a){function b(){return _classCallCheck(this,b),c.apply(this,arguments)}_inherits(b,a);var c=_createSuper(b);return _createClass(b,null,[{key:"fields",value:function fields(){return{id:this.attr(null),activity:this.attr(null),scheme:this.attr(null),level:this.attr(null),time:this.attr(null),order:this.attr(null),agent_id:this.attr(null),packaged_id:this.attr(null),agent:this.belongsTo(_agent__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],"agent_id"),meta:this.morphOne(_meta__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],"item_id","item_type")}}}]),b}(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);_defineProperty(Activity,"entity","activities");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/Field.vue?vue&type=template&id=fd7017d8&scoped=true&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { class: _vm.classes }, [
    _c("label", { attrs: { for: _vm.fieldId } }, [_vm._t("default")], 2),
    _vm._v(" "),
    _c("input", {
      attrs: { type: _vm.inputType, id: _vm.fieldId },
      domProps: { value: _vm.value },
      on: { change: _vm.setValue }
    })
  ])
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./src/components/fields/Field.vue?vue&type=template&id=fd7017d8&scoped=true&

// EXTERNAL MODULE: ./node_modules/nanoid/index.browser.js + 1 modules
var index_browser = __webpack_require__(34);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/Field.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
/* harmony default export */ var Fieldvue_type_script_lang_js_ = ({name:"Field",props:["value","inputType","cls"],data:function data(){return{fieldId:Object(index_browser["a" /* nanoid */])(8)}},computed:{classes:function classes(){var a=["attribution-field"];return this.cls&&(a=a.concat(this.cls)),a}},methods:{setValue:function setValue(a){this.$emit("input",a.target.value)}}});
// CONCATENATED MODULE: ./src/components/fields/Field.vue?vue&type=script&lang=js&
 /* harmony default export */ var fields_Fieldvue_type_script_lang_js_ = (Fieldvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1);

// CONCATENATED MODULE: ./src/components/fields/Field.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  fields_Fieldvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  "fd7017d8",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/fields/Field.vue"
/* harmony default export */ var Field = __webpack_exports__["a"] = (component.exports);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(42);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BaseModel; });
/* harmony import */ var _vuex_orm_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _meta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _createSuper(a){var b=_isNativeReflectConstruct();return function(){var c,d=_getPrototypeOf(a);if(b){var e=_getPrototypeOf(this).constructor;c=Reflect.construct(d,arguments,e)}else c=d.apply(this,arguments);return _possibleConstructorReturn(this,c)}}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(a){return!1}}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}var BaseModel=/*#__PURE__*/function(a){function b(){return _classCallCheck(this,b),c.apply(this,arguments)}_inherits(b,a);var c=_createSuper(b);return _createClass(b,[{key:"getCopy",value:function getCopy(){// get a clone of all the non-relationship fields
var a=lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2___default()(this.$getAttributes()),b={};// don't include the ID - we don't want to update that
return Object.entries(this.$fields()).filter(function(a){return!(a[1]instanceof _vuex_orm_core__WEBPACK_IMPORTED_MODULE_0__[/* Relation */ "b"])}).forEach(function(c){b[c[0]]=a[c[0]]}),delete b.id,b}}],[{key:"updateMeta",value:function updateMeta(a,b){var c=this;return new Promise(function(d,f){var g=c.query()["with"]("meta").find(a);g||f("Item not found"),_meta__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].update({where:g.meta.id,data:b}).then(function(a){return d(a)})["catch"](function(a){return f(a)})})}},{key:"afterCreate",value:function afterCreate(a){var b=_meta__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].query().where("item_id",a.id).where("item_type",this.entity).exists();b||_meta__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].insert({data:{item_id:a.id,item_type:this.entity}})}}]),b}(_vuex_orm_core__WEBPACK_IMPORTED_MODULE_0__[/* Model */ "a"]);

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Citation; });
/* harmony import */ var _activity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _createSuper(a){var b=_isNativeReflectConstruct();return function(){var c,d=_getPrototypeOf(a);if(b){var e=_getPrototypeOf(this).constructor;c=Reflect.construct(d,arguments,e)}else c=d.apply(this,arguments);return _possibleConstructorReturn(this,c)}}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(a){return!1}}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var Citation=/*#__PURE__*/function(a){function b(){return _classCallCheck(this,b),c.apply(this,arguments)}_inherits(b,a);var c=_createSuper(b);return b}(_activity__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);_defineProperty(Citation,"entity","citations");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
Copyright (c) 2009-2019 Frank Bennett

	This program is free software: you can redistribute it and/or
	modify it under EITHER

      * the terms of the Common Public Attribution License (CPAL) as
	    published by the Open Source Initiative, either version 1 of
	    the CPAL, or (at your option) any later version; OR

      * the terms of the GNU Affero General Public License (AGPL)
        as published by the Free Software Foundation, either version
        3 of the AGPL, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Affero General Public License for more details.

	You should have received copies of the Common Public Attribution
    License and of the GNU Affero General Public License along with
    this program.  If not, see <https://opensource.org/licenses/> or
    <http://www.gnu.org/licenses/> respectively.
*/ /*global CSL: true */ /**
 * A Javascript implementation of the CSL citation formatting language.
 *
 * <p>A configured instance of the process is built in two stages,
 * using {@link CSL.Core.Build} and {@link CSL.Core.Configure}.
 * The former sets up hash-accessible locale data and imports the CSL format file
 * to be applied to the citations,
 * transforming it into a one-dimensional token list, and
 * registering functions and parameters on each token as appropriate.
 * The latter sets jump-point information
 * on tokens that constitute potential branch
 * points, in a single back-to-front scan of the token list.
 * This
 * yields a token list that can be executed front-to-back by
 * body methods available on the
 * {@link CSL.Engine} class.</p>
 *
 * <p>This top-level {@link CSL} object itself carries
 * constants that are needed during processing.</p>
 * @namespace A CSL citation formatter.
 */ // IE6 does not implement Array.indexOf().
// IE7 neither, according to rumour.
// Potential skip words:
// under; along; out; between; among; outside; inside; amid; amidst; against; toward; towards.
// See https://forums.zotero.org/discussion/30484/?Focus=159613#Comment_159613
var CSL={PROCESSOR_VERSION:"1.4.59",error:function(str){// default error function
if("undefined"===typeof Error){throw new Error("citeproc-js error: "+str);}else{throw"citeproc-js error: "+str;}},debug:function(str){// default debug function
if("undefined"===typeof console){dump("CSL: "+str+"\n");}else{console.log("citeproc-js warning: "+str);}},toLocaleUpperCase(str){var arr=this.tmp.lang_array;try{str=str.toLocaleUpperCase(arr);}catch(e){str=str.toUpperCase();}return str;},toLocaleLowerCase(str){var arr=this.tmp.lang_array;try{str=str.toLocaleLowerCase(arr);}catch(e){str=str.toLowerCase();}return str;},LOCATOR_LABELS_REGEXP:new RegExp("^((vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\\.)\\s+(.*)"),STATUTE_SUBDIV_PLAIN_REGEX:/(?:(?:^| )(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,STATUTE_SUBDIV_PLAIN_REGEX_FRONT:/(?:^\s*[.,;]*\s*(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,STATUTE_SUBDIV_STRINGS:{"vrs.":"verse","sv.":"sub-verbo","subpara.":"subparagraph","op.":"opus","subch.":"subchapter","add.":"addendum","amend.":"amendment","annot.":"annotation","app.":"appendix","art.":"article","bibliog.":"bibliography","bk.":"book","ch.":"chapter","cl.":"clause","col.":"column","cmt.":"comment","dec.":"decision","dept.":"department","div.":"division","ex.":"example","fig.":"figure","fld.":"field","fol.":"folio","n.":"note","hypo.":"hypothetical","illus.":"illustration","intro.":"introduction","l.":"line","no.":"issue","p.":"page","pp.":"page","para.":"paragraph","pt.":"part","pmbl.":"preamble","princ.":"principle","pub.":"publication","r.":"rule","rn.":"randnummer","sched.":"schedule","sec.":"section","ser.":"series,","subdiv.":"subdivision","subsec.":"subsection","supp.":"supplement","tbl.":"table","tit.":"title","vol.":"volume"},STATUTE_SUBDIV_STRINGS_REVERSE:{"verse":"vrs.","sub-verbo":"sv.","sub verbo":"sv.","subparagraph":"subpara.","opus":"op.","subchapter":"subch.","addendum":"add.","amendment":"amend.","annotation":"annot.","appendix":"app.","article":"art.","bibliography":"bibliog.","book":"bk.","chapter":"ch.","clause":"cl.","column":"col.","comment":"cmt.","decision":"dec.","department":"dept.","division":"div.","example":"ex.","figure":"fig.","field":"fld.","folio":"fol.","note":"n.","hypothetical":"hypo.","illustration":"illus.","introduction":"intro.","line":"l.","issue":"no.","page":"p.","paragraph":"para.","part":"pt.","preamble":"pmbl.","principle":"princ.","publication":"pub.","rule":"r.","randnummer":"rn.","schedule":"sched.","section":"sec.","series,":"ser.","subdivision":"subdiv.","subsection":"subsec.","supplement":"supp.","table":"tbl.","title":"tit.","volume":"vol."},LOCATOR_LABELS_MAP:{"vrs":"verse","sv":"sub-verbo","subpara":"subparagraph","op":"opus","subch":"subchapter","add":"addendum","amend":"amendment","annot":"annotation","app":"appendix","art":"article","bibliog":"bibliography","bk":"book","ch":"chapter","cl":"clause","col":"column","cmt":"comment","dec":"decision","dept":"department","div":"division","ex":"example","fig":"figure","fld":"field","fol":"folio","n":"note","hypo":"hypothetical","illus":"illustration","intro":"introduction","l":"line","no":"issue","p":"page","pp":"page","para":"paragraph","pt":"part","pmbl":"preamble","princ":"principle","pub":"publication","r":"rule","rn":"randnummer","sched":"schedule","sec":"section","ser":"series,","subdiv":"subdivision","subsec":"subsection","supp":"supplement","tbl":"table","tit":"title","vol":"volume"},MODULE_MACROS:{"juris-pretitle":true,"juris-title":true,"juris-pretitle-short":true,"juris-title-short":true,"juris-main":true,"juris-main-short":true,"juris-tail":true,"juris-tail-short":true,"juris-locator":true},MODULE_TYPES:{"legal_case":true,"legislation":true,"bill":true,"hearing":true,"gazette":true,"report":true,"regulation":true,"standard":true,"patent":true,"locator":true},checkNestedBrace:function(state){if(state.opt.xclass==="note"){this.depth=0;this.update=function(str){// Receives affix string, returns with flipped parens.
var str=str?str:"";var lst=str.split(/([\(\)])/);for(var i=1,ilen=lst.length;i<ilen;i+=2){if(lst[i]==="("){if(1===this.depth%2){lst[i]="[";}this.depth+=1;}else if(lst[i]===")"){if(0===this.depth%2){lst[i]="]";}this.depth-=1;}}var ret=lst.join("");return ret;};}else{this.update=function(str){return str;};}},MULTI_FIELDS:["event","publisher","publisher-place","event-place","title","container-title","collection-title","authority","genre","title-short","medium","country","jurisdiction","archive","archive-place"],LangPrefsMap:{"title":"titles","title-short":"titles","event":"titles","genre":"titles","medium":"titles","container-title":"journals","collection-title":"titles","archive":"journals","publisher":"publishers","authority":"publishers","publisher-place":"places","event-place":"places","archive-place":"places","jurisdiction":"places","number":"places","edition":"places","issue":"places","volume":"places"},AbbreviationSegments:function(){this["container-title"]={};this["collection-title"]={};this["institution-entire"]={};this["institution-part"]={};this.nickname={};this.number={};this.title={};this.place={};this.hereinafter={};this.classic={};this["container-phrase"]={};this["title-phrase"]={};},getAbbrevsDomain:function(state,country,lang){var domain=null;if(state.opt.availableAbbrevDomains&&country&&country!=="default"){var globalDomainPreference=state.locale[state.opt.lang].opts["jurisdiction-preference"];var itemDomainPreference=null;if(state.locale[lang]){itemDomainPreference=state.locale[lang].opts["jurisdiction-preference"];}if(itemDomainPreference){for(var j=itemDomainPreference.length-1;j>-1;j--){if(state.opt.availableAbbrevDomains[country].indexOf(itemDomainPreference[j])>-1){domain=itemDomainPreference[j];break;}}}if(!domain&&globalDomainPreference){for(var j=globalDomainPreference.length-1;j>-1;j--){if(state.opt.availableAbbrevDomains[country].indexOf(globalDomainPreference[j])>-1){domain=globalDomainPreference[j];break;}}}}return domain;},FIELD_CATEGORY_REMAP:{"title":"title","container-title":"container-title","collection-title":"collection-title","country":"place","number":"number","place":"place","archive":"container-title","title-short":"title","genre":"title","event":"title","medium":"title","archive-place":"place","publisher-place":"place","event-place":"place","jurisdiction":"place","language-name":"place","language-name-original":"place","call-number":"number","chapter-number":"number","collection-number":"number","edition":"number","page":"number","issue":"number","locator":"number","locator-extra":"number","number-of-pages":"number","number-of-volumes":"number","volume":"number","citation-number":"number","publisher":"institution-part"},parseLocator:function(item){if(this.opt.development_extensions.locator_date_and_revision){// Break out locator elements if necessary
if(item.locator){item.locator=""+item.locator;var idx=item.locator.indexOf("|");if(idx>-1){var raw_locator=item.locator;item.locator=raw_locator.slice(0,idx);raw_locator=raw_locator.slice(idx+1);var m=raw_locator.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2}).*/);if(m){item["locator-date"]=this.fun.dateparser.parseDateToObject(m[1]);raw_locator=raw_locator.slice(m[1].length);}item["locator-extra"]=raw_locator.replace(/^\s+/,"").replace(/\s+$/,"");}}}if(item.locator){item.locator=(""+item.locator).replace(/\s+$/,'');}return item;},normalizeLocaleStr:function(str){if(!str){return;}var lst=str.split('-');lst[0]=lst[0].toLowerCase();if(lst[1]){lst[1]=lst[1].toUpperCase();}return lst.join("-");},parseNoteFieldHacks:function(Item,validFieldsForType,allowDateOverride){if("string"!==typeof Item.note){return;}var elems=[];var lines=Item.note.split('\n');// Normalize entries
for(var i=0,ilen=lines.length;i<ilen;i++){var line=lines[i];var elems=[];var m=line.match(CSL.NOTE_FIELDS_REGEXP);if(m){var splt=line.split(CSL.NOTE_FIELDS_REGEXP);for(var j=0,jlen=splt.length-1;j<jlen;j++){elems.push(splt[j]);elems.push(m[j]);}elems.push(splt[splt.length-1]);for(var j=1,jlen=elems.length;j<jlen;j+=2){// Abort conversions if preceded by unparseable text
if(elems[j-1].trim()&&(i>0||j>1)&&!elems[j-1].match(CSL.NOTE_FIELD_REGEXP)){break;}else{elems[j]='\n'+elems[j].slice(2,-1).trim()+'\n';}}lines[i]=elems.join('');}}// Resplit
lines=lines.join('\n').split('\n');var offset=0;var names={};for(var i=0,ilen=lines.length;i<ilen;i++){var line=lines[i];var mm=line.match(CSL.NOTE_FIELD_REGEXP);if(!line.trim()){continue;}else if(!mm){if(i===0){continue;}else{offset=i;break;}}var key=mm[1];var val=mm[2].replace(/^\s+/,"").replace(/\s+$/,"");if(key==="type"){Item.type=val;lines[i]="";}else if(CSL.DATE_VARIABLES.indexOf(key.replace(/^alt-/,""))>-1){if(!Item[key]||allowDateOverride){Item[key]=CSL.DateParser.parseDateToArray(val);if(!validFieldsForType||validFieldsForType[key]&&this.isDateString(val)){lines[i]="";}}}else if(!Item[key]){if(CSL.NAME_VARIABLES.indexOf(key.replace(/^alt-/,""))>-1){if(!names[key]){names[key]=[];}var lst=val.split(/\s*\|\|\s*/);if(lst.length===1){names[key].push({literal:lst[0]});}else if(lst.length===2){var name={family:lst[0],given:lst[1]};CSL.parseParticles(name);names[key].push(name);}}else{Item[key]=val;}if(!validFieldsForType||validFieldsForType[key]){lines[i]="";}}}for(var key in names){Item[key]=names[key];}// Final cleanup for validCslFields only: eliminate blank lines, add blank line to text
if(validFieldsForType){if(lines[offset].trim()){lines[offset]='\n'+lines[offset];}for(var i=offset-1;i>-1;i--){if(!lines[i].trim()){lines=lines.slice(0,i).concat(lines.slice(i+1));}}}Item.note=lines.join("\n").trim();},checkPrefixSpaceAppend:function(state,prefix){if(!prefix){prefix="";}var sp="";// We need the raw string, without decorations
// of any kind. Markup scheme is known, though, so
// markup can be safely stripped at string level.
//
// U+201d = right double quotation mark
// U+2019 = right single quotation mark
// U+00bb = right double angle bracket (guillemet)
// U+202f = non-breaking thin space
// U+00a0 = non-breaking space
var test_prefix=prefix.replace(/<[^>]+>/g,"").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g,"");var test_char=test_prefix.slice(-1);if(test_prefix.match(CSL.ENDSWITH_ROMANESQUE_REGEXP)){sp=" ";}else if(CSL.TERMINAL_PUNCTUATION.slice(0,-1).indexOf(test_char)>-1){sp=" ";}else if(test_char.match(/[\)\],0-9]/)){sp=" ";}// Protect against double spaces, which would trigger an extra,
// explicit, non-breaking space.
var prefix=(prefix+sp).replace(/\s+/g," ");return prefix;},checkIgnorePredecessor:function(state,prefix){var ignorePredecessor=false;var test_prefix=prefix.replace(/<[^>]+>/g,"").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g,"");var test_char=test_prefix.slice(-1);if(CSL.TERMINAL_PUNCTUATION.slice(0,-1).indexOf(test_char)>-1&&prefix.trim().indexOf(" ")>-1){state.tmp.term_predecessor=false;return true;}return false;},checkSuffixSpacePrepend:function(state,suffix){if(!suffix){return"";}if(suffix.match(CSL.STARTSWITH_ROMANESQUE_REGEXP)||['[','('].indexOf(suffix.slice(0,1))>-1){suffix=" "+suffix;}return suffix;},GENDERS:["masculine","feminine"],ERROR_NO_RENDERED_FORM:1,PREVIEW:"Just for laughs.",ASSUME_ALL_ITEMS_REGISTERED:2,START:0,END:1,SINGLETON:2,SEEN:6,SUCCESSOR:3,SUCCESSOR_OF_SUCCESSOR:4,SUPPRESS:5,SINGULAR:0,PLURAL:1,LITERAL:true,BEFORE:1,AFTER:2,DESCENDING:1,ASCENDING:2,PRIMARY:1,SECONDARY:2,POSITION_FIRST:0,POSITION_SUBSEQUENT:1,POSITION_IBID:2,POSITION_IBID_WITH_LOCATOR:3,POSITION_CONTAINER_SUBSEQUENT:4,POSITION_MAP:{"0":0,"4":1,"1":2,"2":3,"3":4},POSITION_TEST_VARS:["position","first-reference-note-number","near-note"],AREAS:["citation","citation_sort","bibliography","bibliography_sort","intext"],CITE_FIELDS:["first-reference-note-number","first-container-reference-note-number","locator","locator-extra"],SWAPPING_PUNCTUATION:[".","!","?",":",","],TERMINAL_PUNCTUATION:[":",".",";","!","?"," "],// update modes
NONE:0,NUMERIC:1,POSITION:2,TRIGRAPH:3,DATE_PARTS:["year","month","day"],DATE_PARTS_ALL:["year","month","day","season"],DATE_PARTS_INTERNAL:["year","month","day","year_end","month_end","day_end"],NAME_PARTS:["non-dropping-particle","family","given","dropping-particle","suffix","literal"],DISAMBIGUATE_OPTIONS:["disambiguate-add-names","disambiguate-add-givenname","disambiguate-add-year-suffix"],GIVENNAME_DISAMBIGUATION_RULES:["all-names","all-names-with-initials","primary-name","primary-name-with-initials","by-cite"],NAME_ATTRIBUTES:["and","delimiter-precedes-last","delimiter-precedes-et-al","initialize-with","initialize","name-as-sort-order","sort-separator","et-al-min","et-al-use-first","et-al-subsequent-min","et-al-subsequent-use-first","form","prefix","suffix","delimiter"],LOOSE:0,STRICT:1,TOLERANT:2,PREFIX_PUNCTUATION:/[.;:]\s*$/,SUFFIX_PUNCTUATION:/^\s*[.;:,\(\)]/,NUMBER_REGEXP:/(?:^\d+|\d+$)/,//
// \u0400-\u042f are cyrillic and extended cyrillic capitals
// this is not fully smart yet.  can't do what this was trying to do
// with regexps, actually; we want to identify strings with a leading
// capital letter, and any subsequent capital letters.  Have to compare
// locale caps version with existing version, character by character.
// hard stuff, but if it breaks, that's what to do.
// \u0600-\u06ff is Arabic/Persian
// \u200c-\u200e and \u202a-\u202e are special spaces and left-right 
// control characters
NAME_INITIAL_REGEXP:/^([A-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u042f\u0590-\u05d4\u05d6-\u05ff\u0600-\u06ff\u0370\u0372\u0376\u0386\u0388-\u03ab\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03fd-\u03ff])([a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u052f\u0600-\u06ff\u0370-\u03ff\u1f00-\u1fff]*|)(\.)*/,ROMANESQUE_REGEXP:/[-0-9a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,ROMANESQUE_NOT_REGEXP:/[^a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/g,STARTSWITH_ROMANESQUE_REGEXP:/^[&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,ENDSWITH_ROMANESQUE_REGEXP:/[.;:&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]$/,ALL_ROMANESQUE_REGEXP:/^[a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]+$/,VIETNAMESE_SPECIALS:/[\u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]/,VIETNAMESE_NAMES:/^(?:(?:[.AaBbCcDdEeGgHhIiKkLlMmNnOoPpQqRrSsTtUuVvXxYy \u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]{2,6})(\s+|$))+$/,NOTE_FIELDS_REGEXP:/\{:(?:[\-_a-z]+|[A-Z]+):[^\}]+\}/g,NOTE_FIELD_REGEXP:/^([\-_a-z]+|[A-Z]+):\s*([^\}]+)$/,PARTICLE_GIVEN_REGEXP:/^([^ ]+(?:\u02bb |\u2019 | |\' ) *)(.+)$/,PARTICLE_FAMILY_REGEXP:/^([^ ]+(?:\-|\u02bb|\u2019| |\') *)(.+)$/,DISPLAY_CLASSES:["block","left-margin","right-inline","indent"],NAME_VARIABLES:["author","collection-editor","composer","container-author","director","editor","editorial-director","illustrator","interviewer","original-author","recipient","reviewed-author","translator","commenter"],CREATORS:["author","collection-editor","composer","container-author","director","editor","editorial-director","illustrator","interviewer","original-author","recipient","reviewed-author","translator","commenter"],NUMERIC_VARIABLES:["call-number","chapter-number","collection-number","division","edition","page","issue","locator","locator-extra","number","number-of-pages","number-of-volumes","version","volume",// "section", ??? add this?
"supplement","citation-number"],//var x = new Array();
//x = x.concat(["title","container-title","issued","page"]);
//x = x.concat(["locator","collection-number","original-date"]);
//x = x.concat(["reporting-date","decision-date","filing-date"]);
//x = x.concat(["revision-date"]);
//NUMERIC_VARIABLES = x.slice();
DATE_VARIABLES:["locator-date","issued","event-date","accessed","original-date","publication-date","available-date","submitted","alt-issued","alt-event"],VARIABLES_WITH_SHORT_FORM:["title","container-title"],TITLE_FIELD_SPLITS:function(seg){var keys=["title","short","main","sub","subjoin"];var ret={};for(var i=0,ilen=keys.length;i<ilen;i++){ret[keys[i]]=seg+"title"+(keys[i]==="title"?"":"-"+keys[i]);}return ret;},demoteNoiseWords:function(state,fld,drop_or_demote){var SKIP_WORDS=state.locale[state.opt.lang].opts["leading-noise-words"];if(fld&&drop_or_demote){fld=fld.split(/\s+/);fld.reverse();var toEnd=[];for(var j=fld.length-1;j>-1;j+=-1){if(SKIP_WORDS.indexOf(fld[j].toLowerCase())>-1){toEnd.push(fld.pop());}else{break;}}fld.reverse();var start=fld.join(" ");var end=toEnd.join(" ");if("drop"===drop_or_demote||!end){fld=start;}else if("demote"===drop_or_demote){fld=[start,end].join(", ");}}return fld;},extractTitleAndSubtitle:function(Item,narrowSpaceLocale){var narrowSpace=narrowSpaceLocale?"\u202f":"";// XXX In this function, split on split-char, but prefer exact match
// XXX of subtitle to a split-char in title if found.
var segments=[""];if(this.opt.development_extensions.split_container_title){segments.push("container-");}for(var i=0,ilen=segments.length;i<ilen;i++){var seg=segments[i];var title=CSL.TITLE_FIELD_SPLITS(seg);var langs=[false];if(Item.multi){for(var lang in Item.multi._keys[title.short]){langs.push(lang);}}for(var j=0,jlen=langs.length;j<jlen;j++){var lang=langs[j];var vals={};if(lang){if(Item.multi._keys[title.title]){vals[title.title]=Item.multi._keys[title.title][lang];}if(Item.multi._keys[title["short"]]){vals[title["short"]]=Item.multi._keys[title["short"]][lang];}}else{vals[title.title]=Item[title.title];vals[title["short"]]=Item[title["short"]];}vals[title.main]=vals[title.title];vals[title.sub]=false;var shortTitle=vals[title["short"]];if(vals[title.title]){// Rules
// TITLE_SPLIT eliminates split-points of period-space preceded by a capital letter.
// If short title exists and matches exactly to a split-point, use that split-point only.
// Otherwise if there is just one split-point, use that as main/sub split.
// Otherwise use all split-points ... which is handled in titleCaseSentenceOrNormal, not here.
if(shortTitle&&shortTitle.toLowerCase()===vals[title.title].toLowerCase()){vals[title.main]=vals[title.title];vals[title.subjoin]="";vals[title.sub]="";}else if(shortTitle){// check for valid match to shortTitle
var tail=vals[title.title].slice(shortTitle.replace(/[\?\!]+$/,"").length);var top=vals[title.title].replace(tail.replace(/^[\?\!]+/,""),"").trim();var m=CSL.TITLE_SPLIT_REGEXP.matchfirst.exec(tail);if(m&&top.toLowerCase()===shortTitle.toLowerCase()){vals[title.main]=top;vals[title.subjoin]=m[1].replace(/[\?\!]+(\s*)$/,"$1");vals[title.sub]=tail.replace(CSL.TITLE_SPLIT_REGEXP.matchfirst,"");if(this.opt.development_extensions.force_short_title_casing_alignment){vals[title["short"]]=vals[title.main];}}else{var splitTitle=CSL.TITLE_SPLIT(vals[title.title]);if(splitTitle.length==3){vals[title.main]=splitTitle[0];vals[title.subjoin]=splitTitle[1];vals[title.sub]=splitTitle[2];}else{vals[title.main]=vals[title.title];vals[title.subjoin]="";vals[title.sub]="";}}}else{var splitTitle=CSL.TITLE_SPLIT(vals[title.title]);if(splitTitle.length==3){vals[title.main]=splitTitle[0];vals[title.subjoin]=splitTitle[1];vals[title.sub]=splitTitle[2];if(this.opt.development_extensions.implicit_short_title&&Item.type!=="legal_case"){if(!Item[title.short]&&!vals[title.main].match(/^[\-\.[0-9]+$/)){var punct=vals[title.subjoin].trim();if(["?","!"].indexOf(punct)===-1){punct="";}vals[title.short]=vals[title.main]+punct;}}}else{vals[title.main]=vals[title.title];vals[title.subjoin]="";vals[title.sub]="";}}if(vals[title.subjoin]){if(vals[title.subjoin].match(/([\?\!])/)){var m=vals[title.subjoin].match(/(\s*)$/);vals[title.main]=vals[title.main]+narrowSpace+vals[title.subjoin].trim();vals[title.subjoin]=m[1];}}}if(vals[title.subjoin]){if(vals[title.subjoin].indexOf(":")>-1){vals[title.subjoin]=narrowSpace+": ";}if(vals[title.subjoin].indexOf("-")>-1||vals[title.subjoin].indexOf("—")>-1){vals[title.subjoin]="—";}}if(lang){for(var key in vals){if(!Item.multi._keys[key]){Item.multi._keys[key]={};}Item.multi._keys[key][lang]=vals[key];}}else{for(var key in vals){Item[key]=vals[key];}}}}},titlecaseSentenceOrNormal:function(state,Item,seg,lang,sentenceCase){// Hold on here.
// What is seg here?
// It's ... either "" or "container-". Which is ugly, but works.
// But this ALWAYS returns the full title, never short.
// So sentence-casing cannot be applied to short.
// Goes unnoticed because forced sentence-casing almost never appears in styles.
var title=CSL.TITLE_FIELD_SPLITS(seg);var vals={};if(lang&&Item.multi){if(Item.multi._keys[title.title]){vals[title.title]=Item.multi._keys[title.title][lang];}if(Item.multi._keys[title.main]){vals[title.main]=Item.multi._keys[title.main][lang];}if(Item.multi._keys[title.sub]){vals[title.sub]=Item.multi._keys[title.sub][lang];}if(Item.multi._keys[title.subjoin]){vals[title.subjoin]=Item.multi._keys[title.subjoin][lang];}}else{vals[title.title]=Item[title.title];vals[title.main]=Item[title.main];vals[title.sub]=Item[title.sub];vals[title.subjoin]=Item[title.subjoin];}if(vals[title.main]&&vals[title.sub]){var mainTitle=vals[title.main];var subJoin=vals[title.subjoin];var subTitle=vals[title.sub];if(sentenceCase){mainTitle=CSL.Output.Formatters.sentence(state,mainTitle);subTitle=CSL.Output.Formatters.sentence(state,subTitle);}else if(state.opt.development_extensions.uppercase_subtitles){subTitle=CSL.Output.Formatters["capitalize-first"](state,subTitle);}return[mainTitle,subJoin,subTitle].join("");}else if(vals[title.title]){if(sentenceCase){return CSL.Output.Formatters.sentence(state,vals[title.title]);}else if(state.opt.development_extensions.uppercase_subtitles){// Split and apply everywhere.
var splits=CSL.TITLE_SPLIT(vals[title.title]);for(var i=0,ilen=splits.length;i<ilen;i+=2){splits[i]=CSL.Output.Formatters["capitalize-first"](state,splits[i]);}for(var i=1,ilen=splits.length-1;i<ilen;i+=2){var m=splits[i].match(/([:\?\!] )/);if(m){var narrowSpace=state.opt["default-locale"][0].slice(0,2).toLowerCase()==="fr"?"\u202f":"";splits[i]=narrowSpace+m[1];}if(splits[i].indexOf("-")>-1||splits[i].indexOf("—")>-1){splits[i]="—";}}vals[title.title]=splits.join("");return vals[title.title];}else{return vals[title.title];}}else{return"";}},getSafeEscape:function(state){if(["bibliography","citation"].indexOf(state.tmp.area)>-1){// Callback to apply thin space hack
// Callback to force LTR/RTL on parens and braces
// XXX Is this really necessary?
var callbacks=[];if(state.opt.development_extensions.thin_non_breaking_space_html_hack&&state.opt.mode==="html"){callbacks.push(function(txt){return txt.replace(/\u202f/g,'<span style="white-space:nowrap">&thinsp;</span>');});}if(callbacks.length){return function(txt){for(var i=0,ilen=callbacks.length;i<ilen;i+=1){txt=callbacks[i](txt);}return CSL.Output.Formats[state.opt.mode].text_escape(txt);};}else{return CSL.Output.Formats[state.opt.mode].text_escape;}}else{return function(txt){return txt;};}},SKIP_WORDS:["about","above","across","afore","after","against","al","along","alongside","amid","amidst","among","amongst","anenst","apropos","apud","around","as","aside","astride","at","athwart","atop","barring","before","behind","below","beneath","beside","besides","between","beyond","but","by","circa","despite","down","during","et","except","for","forenenst","from","given","in","inside","into","lest","like","modulo","near","next","notwithstanding","of","off","on","onto","out","over","per","plus","pro","qua","sans","since","than","through"," thru","throughout","thruout","till","to","toward","towards","under","underneath","until","unto","up","upon","versus","vs.","v.","vs","v","via","vis-à-vis","with","within","without","according to","ahead of","apart from","as for","as of","as per","as regards","aside from","back to","because of","close to","due to","except for","far from","inside of","instead of","near to","next to","on to","out from","out of","outside of","prior to","pursuant to","rather than","regardless of","such as","that of","up to","where as","or","yet","so","for","and","nor","a","an","the","de","d'","von","van","c","ca"],FORMAT_KEY_SEQUENCE:["@strip-periods","@font-style","@font-variant","@font-weight","@text-decoration","@vertical-align","@quotes"],INSTITUTION_KEYS:["font-style","font-variant","font-weight","text-decoration","text-case"],SUFFIX_CHARS:"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z",ROMAN_NUMERALS:[["","i","ii","iii","iv","v","vi","vii","viii","ix"],["","x","xx","xxx","xl","l","lx","lxx","lxxx","xc"],["","c","cc","ccc","cd","d","dc","dcc","dccc","cm"],["","m","mm","mmm","mmmm","mmmmm"]],LANGS:{"af-ZA":"Afrikaans","ar":"Arabic","bg-BG":"Bulgarian","ca-AD":"Catalan","cs-CZ":"Czech","da-DK":"Danish","de-AT":"Austrian","de-CH":"German (CH)","de-DE":"German (DE)","el-GR":"Greek","en-GB":"English (GB)","en-US":"English (US)","es-ES":"Spanish","et-EE":"Estonian","eu":"European","fa-IR":"Persian","fi-FI":"Finnish","fr-CA":"French (CA)","fr-FR":"French (FR)","he-IL":"Hebrew","hr-HR":"Croatian","hu-HU":"Hungarian","is-IS":"Icelandic","it-IT":"Italian","ja-JP":"Japanese","km-KH":"Khmer","ko-KR":"Korean","lt-LT":"Lithuanian","lv-LV":"Latvian","mn-MN":"Mongolian","nb-NO":"Norwegian (Bokmål)","nl-NL":"Dutch","nn-NO":"Norwegian (Nynorsk)","pl-PL":"Polish","pt-BR":"Portuguese (BR)","pt-PT":"Portuguese (PT)","ro-RO":"Romanian","ru-RU":"Russian","sk-SK":"Slovak","sl-SI":"Slovenian","sr-RS":"Serbian","sv-SE":"Swedish","th-TH":"Thai","tr-TR":"Turkish","uk-UA":"Ukrainian","vi-VN":"Vietnamese","zh-CN":"Chinese (CN)","zh-TW":"Chinese (TW)"},LANG_BASES:{af:"af_ZA",ar:"ar",bg:"bg_BG",ca:"ca_AD",cs:"cs_CZ",da:"da_DK",de:"de_DE",el:"el_GR",en:"en_US",es:"es_ES",et:"et_EE",eu:"eu",fa:"fa_IR",fi:"fi_FI",fr:"fr_FR",he:"he_IL",hr:"hr-HR",hu:"hu_HU",is:"is_IS",it:"it_IT",ja:"ja_JP",km:"km_KH",ko:"ko_KR",lt:"lt_LT",lv:"lv-LV",mn:"mn_MN",nb:"nb_NO",nl:"nl_NL",nn:"nn-NO",pl:"pl_PL",pt:"pt_PT",ro:"ro_RO",ru:"ru_RU",sk:"sk_SK",sl:"sl_SI",sr:"sr_RS",sv:"sv_SE",th:"th_TH",tr:"tr_TR",uk:"uk_UA",vi:"vi_VN",zh:"zh_CN"},SUPERSCRIPTS:{"\u00AA":"\u0061","\u00B2":"\u0032","\u00B3":"\u0033","\u00B9":"\u0031","\u00BA":"\u006F","\u02B0":"\u0068","\u02B1":"\u0266","\u02B2":"\u006A","\u02B3":"\u0072","\u02B4":"\u0279","\u02B5":"\u027B","\u02B6":"\u0281","\u02B7":"\u0077","\u02B8":"\u0079","\u02E0":"\u0263","\u02E1":"\u006C","\u02E2":"\u0073","\u02E3":"\u0078","\u02E4":"\u0295","\u1D2C":"\u0041","\u1D2D":"\u00C6","\u1D2E":"\u0042","\u1D30":"\u0044","\u1D31":"\u0045","\u1D32":"\u018E","\u1D33":"\u0047","\u1D34":"\u0048","\u1D35":"\u0049","\u1D36":"\u004A","\u1D37":"\u004B","\u1D38":"\u004C","\u1D39":"\u004D","\u1D3A":"\u004E","\u1D3C":"\u004F","\u1D3D":"\u0222","\u1D3E":"\u0050","\u1D3F":"\u0052","\u1D40":"\u0054","\u1D41":"\u0055","\u1D42":"\u0057","\u1D43":"\u0061","\u1D44":"\u0250","\u1D45":"\u0251","\u1D46":"\u1D02","\u1D47":"\u0062","\u1D48":"\u0064","\u1D49":"\u0065","\u1D4A":"\u0259","\u1D4B":"\u025B","\u1D4C":"\u025C","\u1D4D":"\u0067","\u1D4F":"\u006B","\u1D50":"\u006D","\u1D51":"\u014B","\u1D52":"\u006F","\u1D53":"\u0254","\u1D54":"\u1D16","\u1D55":"\u1D17","\u1D56":"\u0070","\u1D57":"\u0074","\u1D58":"\u0075","\u1D59":"\u1D1D","\u1D5A":"\u026F","\u1D5B":"\u0076","\u1D5C":"\u1D25","\u1D5D":"\u03B2","\u1D5E":"\u03B3","\u1D5F":"\u03B4","\u1D60":"\u03C6","\u1D61":"\u03C7","\u2070":"\u0030","\u2071":"\u0069","\u2074":"\u0034","\u2075":"\u0035","\u2076":"\u0036","\u2077":"\u0037","\u2078":"\u0038","\u2079":"\u0039","\u207A":"\u002B","\u207B":"\u2212","\u207C":"\u003D","\u207D":"\u0028","\u207E":"\u0029","\u207F":"\u006E","\u2120":"\u0053\u004D","\u2122":"\u0054\u004D","\u3192":"\u4E00","\u3193":"\u4E8C","\u3194":"\u4E09","\u3195":"\u56DB","\u3196":"\u4E0A","\u3197":"\u4E2D","\u3198":"\u4E0B","\u3199":"\u7532","\u319A":"\u4E59","\u319B":"\u4E19","\u319C":"\u4E01","\u319D":"\u5929","\u319E":"\u5730","\u319F":"\u4EBA","\u02C0":"\u0294","\u02C1":"\u0295","\u06E5":"\u0648","\u06E6":"\u064A"},SUPERSCRIPTS_REGEXP:new RegExp("[\u00AA\u00B2\u00B3\u00B9\u00BA\u02B0\u02B1\u02B2\u02B3\u02B4\u02B5\u02B6\u02B7\u02B8\u02E0\u02E1\u02E2\u02E3\u02E4\u1D2C\u1D2D\u1D2E\u1D30\u1D31\u1D32\u1D33\u1D34\u1D35\u1D36\u1D37\u1D38\u1D39\u1D3A\u1D3C\u1D3D\u1D3E\u1D3F\u1D40\u1D41\u1D42\u1D43\u1D44\u1D45\u1D46\u1D47\u1D48\u1D49\u1D4A\u1D4B\u1D4C\u1D4D\u1D4F\u1D50\u1D51\u1D52\u1D53\u1D54\u1D55\u1D56\u1D57\u1D58\u1D59\u1D5A\u1D5B\u1D5C\u1D5D\u1D5E\u1D5F\u1D60\u1D61\u2070\u2071\u2074\u2075\u2076\u2077\u2078\u2079\u207A\u207B\u207C\u207D\u207E\u207F\u2120\u2122\u3192\u3193\u3194\u3195\u3196\u3197\u3198\u3199\u319A\u319B\u319C\u319D\u319E\u319F\u02C0\u02C1\u06E5\u06E6]","g"),// I think we need to have separate args for prefix and term,
// since they have different effects between comma-safe and comma-safe-numbers-only.
// Either that, or -- oh, we could just bang the two together for the test where
// necessary.
UPDATE_GROUP_CONTEXT_CONDITION:function(state,str,valueTerm,token,value){if(!state.opt.use_context_condition)return;var flags=state.tmp.group_context.tip;if(flags.condition){if(!flags.condition.termtxt){flags.condition.termtxt=str;flags.condition.valueTerm=valueTerm;}if(!flags.value_seen&&flags.condition.test==="comma-safe-numbers-only"){if(value){flags.value_seen=true;if(!value.match(/^[0-9]/)){state.tmp.just_did_number=false;}}}}else{// If not inside a conditional group, raise numeric flag
// if and only if the current term string ends in a number.
if(token&&token.decorations.filter(o=>o[0]==="@vertical-align").length>0){state.tmp.just_did_number=false;}else if(token&&token.strings.suffix){state.tmp.just_did_number=false;}else if(str){if(str.match(/[0-9]$/)){state.tmp.just_did_number=true;}else{state.tmp.just_did_number=false;}}}},EVALUATE_GROUP_CONDITION:function(state,flags){if(!state.opt.use_context_condition)return;var testres;var numbersOnly=flags.condition.test==="comma-safe-numbers-only";if(flags.condition.test==="empty-label"){testres=!flags.condition.termtxt;}else if(flags.condition.test==="empty-label-no-decor"){testres=!flags.condition.termtxt||flags.condition.termtxt.indexOf("%s")>-1;}else if(["comma-safe","comma-safe-numbers-only"].indexOf(flags.condition.test)>-1){var locale_term=flags.condition.termtxt;var termStartAlpha=false;if(flags.condition.termtxt){termStartAlpha=flags.condition.termtxt.slice(0,1).match(CSL.ALL_ROMANESQUE_REGEXP);}var num=state.tmp.just_did_number;if(num){if(flags.condition.valueTerm){testres=numbersOnly?false:true;}else if(!locale_term){testres=true;}else if(termStartAlpha){testres=numbersOnly?false:true;}else if(["always","after-number"].indexOf(state.opt.require_comma_on_symbol)>-1){testres=true;}else{testres=false;}}else{if(flags.condition.valueTerm){testres=false;}else if(!locale_term){testres=false;}else if(termStartAlpha){testres=numbersOnly?false:true;}else if(state.opt.require_comma_on_symbol==="always"){testres=true;}else{testres=false;}}}if(testres){var force_suppress=false;}else{var force_suppress=true;}if(flags.condition.not){force_suppress=!force_suppress;}return force_suppress;},SYS_OPTIONS:["prioritize_disambiguate_condition","csl_reverse_lookup_support","main_title_from_short_title","uppercase_subtitles","force_short_title_casing_alignment","implicit_short_title","split_container_title"],TITLE_SPLIT_REGEXP:function(){var splits=["\\.\\s+","\\!\\s+","\\?\\s+","\\s*::*\\s+","\\s*—\\s*","\\s+\\-\\s+","\\s*\\-\\-\\-*\\s*"];return{match:new RegExp("("+splits.join("|")+")","g"),matchfirst:new RegExp("^("+splits.join("|")+")"),split:new RegExp("(?:"+splits.join("|")+")")};}(),TITLE_SPLIT:function(str){if(!str){return str;}var m=str.match(CSL.TITLE_SPLIT_REGEXP.match);var lst=str.split(CSL.TITLE_SPLIT_REGEXP.split);for(var i=lst.length-2;i>-1;i--){lst[i]=lst[i].trim();if(lst[i]&&lst[i].slice(-1).toLowerCase()!==lst[i].slice(-1)){// recombine
lst[i]=lst[i]+m[i]+lst[i+1];lst=lst.slice(0,i+1).concat(lst.slice(i+2));}else{// merge
lst=lst.slice(0,i+1).concat([m[i]]).concat(lst.slice(i+1));}}return lst;},GET_COURT_CLASS:function(state,Item,sortKey){// Get authority as a string
var cls="";var authority=null;var country=Item.jurisdiction?Item.jurisdiction.split(":")[0]:null;// inStyle versus in module
var classType="court_condition_classes";if(sortKey){classType="court_key_classes";}if(country&&Item.authority){if("string"===typeof Item.authority){authority=Item.authority;}else{if(Item.authority[0]&&Item.authority[0].literal){authority=Item.authority[0].literal;}}}if(authority){if(this.lang&&state.locale[this.lang].opts[classType]&&state.locale[this.lang].opts[classType][country]&&state.locale[this.lang].opts[classType][country][authority]){cls=state.locale[this.lang].opts[classType][country][authority];}else if(state.locale[state.opt["default-locale"][0]].opts[classType]&&state.locale[state.opt["default-locale"][0]].opts[classType][country]&&state.locale[state.opt["default-locale"][0]].opts[classType][country][authority]){cls=state.locale[state.opt["default-locale"][0]].opts[classType][country][authority];}}return cls;},SET_COURT_CLASSES:function(state,lang,myxml,dataObj){var nodes=myxml.getNodesByName(dataObj,'court-class');for(var pos=0,len=myxml.numberofnodes(nodes);pos<len;pos+=1){var courtclass=nodes[pos];var attributes=myxml.attributes(courtclass);var cls=attributes["@name"];var country=attributes["@country"];var courts=attributes["@courts"];// Okay, this is a hack.
// If state.registry IS NOT yet defined, this is an in-style declaration.
// If state.registry IS defined, this is an in-module declaration.
var classType="court_key_classes";if(state.registry){classType="court_condition_classes";}if(cls&&country&&courts){courts=courts.trim().split(/\s+/);if(!state.locale[lang].opts[classType]){state.locale[lang].opts[classType]={};}if(!state.locale[lang].opts[classType][country]){state.locale[lang].opts[classType][country]={};}for(var i=0,ilen=courts.length;i<ilen;i++){state.locale[lang].opts[classType][country][courts[i]]=cls;}}}},INIT_JURISDICTION_MACROS:function(state,Item,item,macroName){if(!state.sys.retrieveStyleModule||!CSL.MODULE_MACROS[macroName]||!Item.jurisdiction){return false;}var jurisdictionList=state.getJurisdictionList(Item.jurisdiction);// Set up a list of jurisdictions here, we will reuse it
if(!state.opt.jurisdictions_seen[jurisdictionList[0]]){var res=state.retrieveAllStyleModules(jurisdictionList);// Okay. We have code for each of the novel modules in the
// hierarchy. Load them all into the processor.
for(var jurisdiction in res){var fallback=state.loadStyleModule(jurisdiction,res[jurisdiction]);if(fallback){if(!res[fallback]){Object.assign(res,state.retrieveAllStyleModules([fallback]));state.loadStyleModule(fallback,res[fallback],true);}}}}if(state.opt.parallel.enable){if(!state.parallel){state.parallel=new CSL.Parallel(state);}}// Identify the best jurisdiction for the item and return true, otherwise return false
for(var i=0,ilen=jurisdictionList.length;i<ilen;i++){var jurisdiction=jurisdictionList[i];if(item){if(state.juris[jurisdiction]&&!item["best-jurisdiction"]&&state.juris[jurisdiction].types.locator){item["best-jurisdiction"]=jurisdiction;}}if(state.juris[jurisdiction]&&state.juris[jurisdiction].types[Item.type]){Item["best-jurisdiction"]=jurisdiction;return true;}}return false;}};/**
 * Functions for parsing an XML object converted to JSON.
 */ /*
  Style and locale JSON should be formatted as follows. Note that
  an empty literal should be set as an explicit empty strings within
  children:[]
  
  {
    name:"term",
    children:[
      ""
    ],
    attrs:{
      name:"author"
    }
  }

  The following script will generate correctly formatted JSON
  from a CSL style or locale file:
*/CSL.XmlJSON=function(dataObj){this.dataObj=dataObj;this.institution={name:"institution",attrs:{"institution-parts":"long","delimiter":", "},children:[{name:"institution-part",attrs:{name:"long"},children:[]}]};};/**
 * No need for cleaning with native JSON.
 */CSL.XmlJSON.prototype.clean=function(json){return json;};/**
 * Methods to call on a node.
 */CSL.XmlJSON.prototype.getStyleId=function(myjson,styleName){var tagName='id';if(styleName){tagName='title';}var ret="";var children=myjson.children;for(var i=0,ilen=children.length;i<ilen;i++){if(children[i].name==='info'){var grandkids=children[i].children;for(var j=0,jlen=grandkids.length;j<jlen;j++){if(grandkids[j].name===tagName){ret=grandkids[j].children[0];}}}}return ret;};CSL.XmlJSON.prototype.children=function(myjson){//print("children()");
if(myjson&&myjson.children.length){return myjson.children.slice();}else{return false;}};CSL.XmlJSON.prototype.nodename=function(myjson){//print("nodename()");
return myjson?myjson.name:null;};CSL.XmlJSON.prototype.attributes=function(myjson){//print("attributes()");
var ret={};for(var attrname in myjson.attrs){ret["@"+attrname]=myjson.attrs[attrname];}return ret;};CSL.XmlJSON.prototype.content=function(myjson){//print("content()");
// xmldom.js and xmle4x.js have "undefined" as default
var ret="";// This only catches content at first level, but that is good enough
// for us.
if(!myjson||!myjson.children){return ret;}for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if("string"===typeof myjson.children[i]){ret+=myjson.children[i];}}return ret;};CSL.XmlJSON.prototype.namespace={};CSL.XmlJSON.prototype.numberofnodes=function(myjson){//print("numberofnodes()");
if(myjson&&"number"==typeof myjson.length){return myjson.length;}else{return 0;}};// getAttributeName() removed. Looks like it was not being used.
CSL.XmlJSON.prototype.getAttributeValue=function(myjson,name,namespace){//print("getAttributeValue()");
var ret="";if(namespace){name=namespace+":"+name;}if(myjson){if(myjson.attrs){if(myjson.attrs[name]){ret=myjson.attrs[name];}else{ret="";}}}return ret;};CSL.XmlJSON.prototype.getNodeValue=function(myjson,name){//print("getNodeValue()");
var ret="";if(name){for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if(myjson.children[i].name===name){// This will always be Object() unless empty
if(myjson.children[i].children.length){ret=myjson.children[i];}else{ret="";}}}}else if(myjson){ret=myjson;}// Just being careful here, following the former DOM code. The JSON object we receive 
// for this should be fully normalized.
if(ret&&ret.children&&ret.children.length==1&&"string"===typeof ret.children[0]){ret=ret.children[0];}return ret;};CSL.XmlJSON.prototype.setAttributeOnNodeIdentifiedByNameAttribute=function(myjson,nodename,partname,attrname,val){//print("setAttributeOnNodeIdentifiedByNameAttribute()");
var pos,len,xml,nodes,node;if(attrname.slice(0,1)==='@'){attrname=attrname.slice(1);}// In the one place this is used in citeproc-js code, it doesn't need to recurse.
for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if(myjson.children[i].name===nodename&&myjson.children[i].attrs.name===partname){myjson.children[i].attrs[attrname]=val;}}};CSL.XmlJSON.prototype.deleteNodeByNameAttribute=function(myjson,val){//print("deleteNodeByNameAttribute()");
var i,ilen;for(i=0,ilen=myjson.children.length;i<ilen;i+=1){if(!myjson.children[i]||"string"===typeof myjson.children[i]){continue;}if(myjson.children[i].attrs.name==val){myjson.children=myjson.children.slice(0,i).concat(myjson.children.slice(i+1));}}};CSL.XmlJSON.prototype.deleteAttribute=function(myjson,attrname){//print("deleteAttribute()");
var i,ilen;if("undefined"!==typeof myjson.attrs[attrname]){myjson.attrs.pop(attrname);}};CSL.XmlJSON.prototype.setAttribute=function(myjson,attr,val){//print("setAttribute()");
myjson.attrs[attr]=val;return false;};CSL.XmlJSON.prototype.nodeCopy=function(myjson,clone){//print("nodeCopy()");
if(!clone){var clone={};}if("object"===typeof clone&&"undefined"===typeof clone.length){// myjson is an object
for(var key in myjson){if("string"===typeof myjson[key]){clone[key]=myjson[key];}else if("object"===typeof myjson[key]){if("undefined"===typeof myjson[key].length){clone[key]=this.nodeCopy(myjson[key],{});}else{clone[key]=this.nodeCopy(myjson[key],[]);}}}}else{// myjson is an array
for(var i=0,ilen=myjson.length;i<ilen;i+=1){if("string"===typeof myjson[i]){clone[i]=myjson[i];}else{// If it's at the first level of an array, it's an object.
clone[i]=this.nodeCopy(myjson[i],{});}}}return clone;};CSL.XmlJSON.prototype.getNodesByName=function(myjson,name,nameattrval,ret){//print("getNodesByName()");
var nodes,node,pos,len;if(!ret){var ret=[];}if(!myjson||!myjson.children){return ret;}if(name===myjson.name){if(nameattrval){if(nameattrval===myjson.attrs.name){ret.push(myjson);}}else{ret.push(myjson);}}for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if("object"!==typeof myjson.children[i]){continue;}this.getNodesByName(myjson.children[i],name,nameattrval,ret);}return ret;};CSL.XmlJSON.prototype.nodeNameIs=function(myjson,name){//print("nodeNameIs()");
if(typeof myjson==="undefined"){return false;}if(name==myjson.name){return true;}return false;};CSL.XmlJSON.prototype.makeXml=function(myjson){//print("makeXml()");
if("string"===typeof myjson){if(myjson.slice(0,1)==="<"){myjson=this.jsonStringWalker.walkToObject(myjson);}else{myjson=JSON.parse(myjson);}}return myjson;};CSL.XmlJSON.prototype.insertChildNodeAfter=function(parent,node,pos,datejson){//print("insertChildNodeAfter()");
// Function is misnamed: this replaces the node
for(var i=0,ilen=parent.children.length;i<ilen;i+=1){if(node===parent.children[i]){parent.children=parent.children.slice(0,i).concat([datejson]).concat(parent.children.slice(i+1));break;}}return parent;};CSL.XmlJSON.prototype.insertPublisherAndPlace=function(myjson){if(myjson.name==="group"){var useme=true;var mustHaves=["publisher","publisher-place"];for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){var haveVarname=mustHaves.indexOf(myjson.children[i].attrs.variable);var isText=myjson.children[i].name==="text";if(isText&&haveVarname>-1&&!myjson.children[i].attrs.prefix&&!myjson.children[i].attrs.suffix){mustHaves=mustHaves.slice(0,haveVarname).concat(mustHaves.slice(haveVarname+1));}else{useme=false;break;}}if(useme&&!mustHaves.length){myjson.attrs["has-publisher-and-publisher-place"]=true;}}for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if("object"===typeof myjson.children[i]){this.insertPublisherAndPlace(myjson.children[i]);}}};/*
CSL.XmlJSON.prototype.insertPublisherAndPlace = function(myxml) {
    var group = myxml.getElementsByTagName("group");
    for (var i = 0, ilen = group.length; i < ilen; i += 1) {
        var node = group.item(i);
        var skippers = [];
        for (var j = 0, jlen = node.childNodes.length; j < jlen; j += 1) {
            if (node.childNodes.item(j).nodeType !== 1) {
                skippers.push(j);
            }
        }
        if (node.childNodes.length - skippers.length === 2) {
            var twovars = [];
            for (var j = 0, jlen = 2; j < jlen; j += 1) {
                if (skippers.indexOf(j) > -1) {
                    continue;
                }
                var child = node.childNodes.item(j);                    
                var subskippers = [];
                for (var k = 0, klen = child.childNodes.length; k < klen; k += 1) {
                    if (child.childNodes.item(k).nodeType !== 1) {
                        subskippers.push(k);
                    }
                }
                if (child.childNodes.length - subskippers.length === 0) {
                    twovars.push(child.getAttribute('variable'));
                    if (child.getAttribute('suffix')
                        || child.getAttribute('prefix')) {
                        twovars = [];
                        break;
                    }
                }
            }
            if (twovars.indexOf("publisher") > -1 && twovars.indexOf("publisher-place") > -1) {
                node.setAttribute('has-publisher-and-publisher-place', true);
            }
        }
    }
};
*/CSL.XmlJSON.prototype.isChildOfSubstitute=function(parents){if(parents.length>0){var myparents=parents.slice();var parent=myparents.pop();if(parent==="substitute"){return true;}else{return this.isChildOfSubstitute(myparents);}}return false;};CSL.XmlJSON.prototype.addMissingNameNodes=function(myjson,parents){if(!parents){parents=[];}if(myjson.name==="names"){// Trawl through children to decide whether a name node is needed here
if(!this.isChildOfSubstitute(parents)){var addName=true;for(var i=0,ilen=myjson.children.length;i<ilen;i++){if(myjson.children[i].name==="name"){addName=false;break;}}if(addName){myjson.children=[{name:"name",attrs:{},children:[]}].concat(myjson.children);}}}parents.push(myjson.name);for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if("object"===typeof myjson.children[i]){this.addMissingNameNodes(myjson.children[i],parents);}}parents.pop();};CSL.XmlJSON.prototype.addInstitutionNodes=function(myjson){//print("addInstitutionNodes()");
var names,thenames,institution,theinstitution,name,thename,xml,pos,len;// The idea here is to map relevant attributes from name and nampart=family
// to the "long" institution-part node, when and only when forcing insert
// of the default node.
if(myjson.name==="names"){// do stuff
var attributes={};var insertPos=-1;for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if(myjson.children[i].name=="name"){for(var key in myjson.children[i].attrs){attributes[key]=myjson.children[i].attrs[key];}attributes.delimiter=myjson.children[i].attrs.delimiter;attributes.and=myjson.children[i].attrs.and;insertPos=i;for(var k=0,klen=myjson.children[i].children.length;k<klen;k+=1){if(myjson.children[i].children[k].attrs.name!=='family'){continue;}for(var key in myjson.children[i].children[k].attrs){attributes[key]=myjson.children[i].children[k].attrs[key];}}}if(myjson.children[i].name=="institution"){insertPos=-1;break;}}if(insertPos>-1){var institution=this.nodeCopy(this.institution);for(var i=0,ilen=CSL.INSTITUTION_KEYS.length;i<ilen;i+=1){var attrname=CSL.INSTITUTION_KEYS[i];if("undefined"!==typeof attributes[attrname]){institution.children[0].attrs[attrname]=attributes[attrname];}if(attributes.delimiter){institution.attrs.delimiter=attributes.delimiter;}if(attributes.and){institution.attrs.and=attributes.and;}}myjson.children=myjson.children.slice(0,insertPos+1).concat([institution]).concat(myjson.children.slice(insertPos+1));}}for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if("string"===typeof myjson.children[i]){continue;}// Recurse
this.addInstitutionNodes(myjson.children[i]);}};CSL.XmlJSON.prototype.flagDateMacros=function(myjson){// print("flagDateMacros()");
for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if(myjson.children[i].name==="macro"){if(this.inspectDateMacros(myjson.children[i])){myjson.children[i].attrs["macro-has-date"]="true";}}}};CSL.XmlJSON.prototype.inspectDateMacros=function(myjson){//print("inspectDateMacros()");
if(!myjson||!myjson.children){return false;}if(myjson.name==="date"){return true;}else{for(var i=0,ilen=myjson.children.length;i<ilen;i+=1){if(this.inspectDateMacros(myjson.children[i])){return true;}}}return false;};/*
 * Clean serialized XML
 */CSL.stripXmlProcessingInstruction=function(xml){if(!xml){return xml;}xml=xml.replace(/^<\?[^?]+\?>/,"");xml=xml.replace(/<!--[^>]+-->/g,"");xml=xml.replace(/^\s+/g,"");xml=xml.replace(/\s+$/g,"");return xml;};/*
 * String parser for XML inputs
 */CSL.parseXml=function(str){var _pos=0;var _obj={children:[]};var _stack=[_obj.children];function _listifyString(str){str=str.split(/(?:\r\n|\n|\r)/).join(" ").replace(/>[	 ]+</g,"><").replace(/<\!--.*?-->/g,"");var lst=str.split("><");var stylePos=null;for(var i=0,ilen=lst.length;i<ilen;i++){if(i>0){lst[i]="<"+lst[i];}if(i<lst.length-1){lst[i]=lst[i]+">";}if("number"!=typeof stylePos){if(lst[i].slice(0,7)==="<style "||lst[i].slice(0,8)=="<locale "){stylePos=i;}}}lst=lst.slice(stylePos);// Combine open/close elements for empty terms,
// so that they will be passed through correctly
// as empty strings.
for(var i=lst.length-2;i>-1;i--){if(lst[i].slice(1).indexOf("<")===-1){var stub=lst[i].slice(0,5);if(lst[i].slice(-2)!=="/>"){if(stub==="<term"){if(lst[i+1].slice(0,6)==="</term"){lst[i]=lst[i]+lst[i+1];lst=lst.slice(0,i+1).concat(lst.slice(i+2));}}else if(["<sing","<mult"].indexOf(stub)>-1){if(lst[i].slice(-2)!=="/>"&&lst[i+1].slice(0,1)==="<"){lst[i]=lst[i]+lst[i+1];lst=lst.slice(0,i+1).concat(lst.slice(i+2));}}}}}return lst;}function _decodeHtmlEntities(str){return str.split("&amp;").join("&").split("&quot;").join("\"").split("&gt;").join(">").split("&lt;").join("<").replace(/&#([0-9]{1,6});/gi,function(match,numStr){var num=parseInt(numStr,10);// read num as normal number
return String.fromCharCode(num);}).replace(/&#x([a-f0-9]{1,6});/gi,function(match,numStr){var num=parseInt(numStr,16);// read num as hex
return String.fromCharCode(num);});}function _getAttributes(elem){var m=elem.match(/([^\'\"=	 ]+)=(?:\"[^\"]*\"|\'[^\']*\')/g);if(m){for(var i=0,ilen=m.length;i<ilen;i++){m[i]=m[i].replace(/=.*/,"");}}return m;}function _getAttribute(elem,attr){var rex=RegExp('^.*[	 ]+'+attr+'=(\"(?:[^\"]*)\"|\'(?:[^\']*)\').*$');var m=elem.match(rex);return m?m[1].slice(1,-1):null;}function _getTagName(elem){var rex=RegExp("^<([^	 />]+)");var m=elem.match(rex);return m?m[1]:null;}function _castObjectFromOpeningTag(elem){var obj={};obj.name=_getTagName(elem);obj.attrs={};var attributes=_getAttributes(elem);if(attributes){for(var i=0,ilen=attributes.length;i<ilen;i++){var attr={name:attributes[i],value:_getAttribute(elem,attributes[i])};obj.attrs[attr.name]=_decodeHtmlEntities(attr.value);}}obj.children=[];return obj;}function _extractTextFromCompositeElement(elem){var m=elem.match(/^.*>([^<]*)<.*$/);return _decodeHtmlEntities(m[1]);}function _appendToChildren(obj){_stack.slice(-1)[0].push(obj);}function _extendStackWithNewChildren(obj){_stack.push(obj.children);}function processElement(elem){var obj;if(elem.slice(1).indexOf('<')>-1){// withtext
var tag=elem.slice(0,elem.indexOf('>')+1);obj=_castObjectFromOpeningTag(tag);obj.children=[_extractTextFromCompositeElement(elem)];_appendToChildren(obj);}else if(elem.slice(-2)==='/>'){// singleton
obj=_castObjectFromOpeningTag(elem);// Empty term as singleton
if(_getTagName(elem)==='term'){obj.children.push('');}_appendToChildren(obj);}else if(elem.slice(0,2)==='</'){// close
_stack.pop();}else{// open
obj=_castObjectFromOpeningTag(elem);_appendToChildren(obj);_extendStackWithNewChildren(obj);}}var lst=_listifyString(str);for(var i=0,ilen=lst.length;i<ilen;i++){var elem=lst[i];processElement(elem);}return _obj.children[0];};/**
 * Functions for parsing an XML object using E4X.
 */CSL.XmlDOM=function(dataObj){this.dataObj=dataObj;if("undefined"==typeof DOMParser){DOMParser=function(){};DOMParser.prototype.parseFromString=function(str,contentType){if("undefined"!=typeof ActiveXObject){var xmldata=new ActiveXObject('MSXML.DomDocument');xmldata.async=false;xmldata.loadXML(str);return xmldata;}else if("undefined"!=typeof XMLHttpRequest){var xmldata=new XMLHttpRequest();if(!contentType){contentType='text/xml';}xmldata.open('GET','data:'+contentType+';charset=utf-8,'+encodeURIComponent(str),false);if(xmldata.overrideMimeType){xmldata.overrideMimeType(contentType);}xmldata.send(null);return xmldata.responseXML;}else if("undefined"!=typeof marknote){var parser=new marknote.Parser();return parser.parse(str);}};this.hasAttributes=function(node){var ret;if(node.attributes&&node.attributes.length){ret=true;}else{ret=false;}return ret;};}else{/*
        this.hasAttributes = function (node) {
            return node["hasAttributes"]();
        };
        */this.hasAttributes=function(node){var ret;if(node.attributes&&node.attributes.length){ret=true;}else{ret=false;}return ret;};}this.importNode=function(doc,srcElement){var ret;if("undefined"==typeof doc.importNode){ret=this._importNode(doc,srcElement,true);}else{ret=doc.importNode(srcElement,true);}return ret;};// In case importNode is not available.
// Thx + hat tip to Anthony T. Holdener III
// http://www.alistapart.com/articles/crossbrowserscripting
// cases 3, 4, 8 = text, cdata, comment
this._importNode=function(doc,node,allChildren){switch(node.nodeType){// element node
case 1:var newNode=doc.createElement(node.nodeName);if(node.attributes&&node.attributes.length>0)for(var i=0,il=node.attributes.length;i<il;)newNode.setAttribute(node.attributes[i].nodeName,node.getAttribute(node.attributes[i++].nodeName));if(allChildren&&node.childNodes&&node.childNodes.length>0)for(var i=0,il=node.childNodes.length;i<il;)newNode.appendChild(this._importNode(doc,node.childNodes[i++],allChildren));return newNode;break;case 3:case 4:case 8:// Drop comments on the floor as well.
//return doc.createTextNode(node.nodeValue);
//break;
}};this.parser=new DOMParser();// This seems horribly tormented, but there might be a reason for it.
// Perhaps this was the only way I found to get namespacing to work ... ?
var str="<docco><institution institution-parts=\"long\" delimiter=\", \" substitute-use-first=\"1\" use-last=\"1\"><institution-part name=\"long\"/></institution></docco>";var inst_doc=this.parser.parseFromString(str,"text/xml");var inst_node=inst_doc.getElementsByTagName("institution");this.institution=inst_node.item(0);var inst_part_node=inst_doc.getElementsByTagName("institution-part");this.institutionpart=inst_part_node.item(0);this.ns="http://purl.org/net/xbiblio/csl";};/**
 * No need for cleaning with the DOM, I think.  This will probably just be a noop.
 * But first, let's get XML mode switching up and running.
 */CSL.XmlDOM.prototype.clean=function(xml){xml=xml.replace(/<\?[^?]+\?>/g,"");xml=xml.replace(/<![^>]+>/g,"");xml=xml.replace(/^\s+/,"");xml=xml.replace(/\s+$/,"");xml=xml.replace(/^\n*/,"");return xml;};/**
 * Methods to call on a node.
 */CSL.XmlDOM.prototype.getStyleId=function(myxml,styleName){var text="";var tagName="id";if(styleName){tagName="title";}var node=myxml.getElementsByTagName(tagName);if(node&&node.length){node=node.item(0);}if(node){// W3C conformant browsers
text=node.textContent;}if(!text){// Opera, IE 6 & 7
text=node.innerText;}if(!text){// Safari
text=node.innerHTML;}return text;};CSL.XmlDOM.prototype.children=function(myxml){var children,pos,len,ret;if(myxml){ret=[];children=myxml.childNodes;for(pos=0,len=children.length;pos<len;pos+=1){if(children[pos].nodeName!="#text"){ret.push(children[pos]);}}return ret;}else{return[];}};CSL.XmlDOM.prototype.nodename=function(myxml){var ret=myxml.nodeName;return ret;};CSL.XmlDOM.prototype.attributes=function(myxml){var ret,attrs,attr,key,xml,pos,len;ret=new Object();if(myxml&&this.hasAttributes(myxml)){attrs=myxml.attributes;for(pos=0,len=attrs.length;pos<len;pos+=1){attr=attrs[pos];ret["@"+attr.name]=attr.value;}}return ret;};CSL.XmlDOM.prototype.content=function(myxml){var ret;if("undefined"!=typeof myxml.textContent){ret=myxml.textContent;}else if("undefined"!=typeof myxml.innerText){ret=myxml.innerText;}else{ret=myxml.txt;}return ret;};CSL.XmlDOM.prototype.namespace={"xml":"http://www.w3.org/XML/1998/namespace"};CSL.XmlDOM.prototype.numberofnodes=function(myxml){if(myxml){return myxml.length;}else{return 0;}};CSL.XmlDOM.prototype.getAttributeName=function(attr){var ret=attr.name;return ret;};CSL.XmlDOM.prototype.getAttributeValue=function(myxml,name,namespace){var ret="";if(namespace){name=namespace+":"+name;}if(myxml&&this.hasAttributes(myxml)&&myxml.getAttribute(name)){ret=myxml.getAttribute(name);}return ret;};//
// Can't this be, you know ... simplified?
//
CSL.XmlDOM.prototype.getNodeValue=function(myxml,name){var ret=null;if(name){var vals=myxml.getElementsByTagName(name);if(vals.length>0){if("undefined"!=typeof vals[0].textContent){ret=vals[0].textContent;}else if("undefined"!=typeof vals[0].innerText){ret=vals[0].innerText;}else{ret=vals[0].text;}}}if(ret===null&&myxml&&myxml.childNodes&&(myxml.childNodes.length==0||myxml.childNodes.length==1&&myxml.firstChild.nodeName=="#text")){if("undefined"!=typeof myxml.textContent){ret=myxml.textContent;}else if("undefined"!=typeof myxml.innerText){ret=myxml.innerText;}else{ret=myxml.text;}}if(ret===null){ret=myxml;}return ret;};CSL.XmlDOM.prototype.setAttributeOnNodeIdentifiedByNameAttribute=function(myxml,nodename,partname,attrname,val){var pos,len,xml,nodes,node;if(attrname.slice(0,1)==='@'){attrname=attrname.slice(1);}nodes=myxml.getElementsByTagName(nodename);for(pos=0,len=nodes.length;pos<len;pos+=1){node=nodes[pos];if(node.getAttribute("name")!=partname){continue;}node.setAttribute(attrname,val);}};CSL.XmlDOM.prototype.deleteNodeByNameAttribute=function(myxml,val){var pos,len,node,nodes;nodes=myxml.childNodes;for(pos=0,len=nodes.length;pos<len;pos+=1){node=nodes[pos];if(!node||node.nodeType==node.TEXT_NODE){continue;}if(this.hasAttributes(node)&&node.getAttribute("name")==val){myxml.removeChild(nodes[pos]);}}};CSL.XmlDOM.prototype.deleteAttribute=function(myxml,attr){myxml.removeAttribute(attr);};CSL.XmlDOM.prototype.setAttribute=function(myxml,attr,val){if(!myxml.ownerDocument){myxml=myxml.firstChild;}// "unknown" to satisfy IE8, which crashes when setAttribute
// is checked directly as a property, and report its type as
// "unknown".
// Many thanks to Phil Lord for tracing the cause of the fault.
if(["function","unknown"].indexOf(typeof myxml.setAttribute)>-1){myxml.setAttribute(attr,val);}return false;};CSL.XmlDOM.prototype.nodeCopy=function(myxml){var cloned_node=myxml.cloneNode(true);return cloned_node;};CSL.XmlDOM.prototype.getNodesByName=function(myxml,name,nameattrval){var ret,nodes,node,pos,len;ret=[];nodes=myxml.getElementsByTagName(name);for(pos=0,len=nodes.length;pos<len;pos+=1){node=nodes.item(pos);if(nameattrval&&!(this.hasAttributes(node)&&node.getAttribute("name")==nameattrval)){//        if (nameattrval && !(this.attributes && node.attributes.name && node.attributes.name.value == nameattrval)) {
continue;}ret.push(node);}return ret;};CSL.XmlDOM.prototype.nodeNameIs=function(myxml,name){if(name==myxml.nodeName){return true;}return false;};CSL.XmlDOM.prototype.makeXml=function(myxml){var ret,topnode;if(!myxml){myxml="<docco><bogus/></docco>";}myxml=myxml.replace(/\s*<\?[^>]*\?>\s*\n*/g,"");var nodetree=this.parser.parseFromString(myxml,"application/xml");return nodetree.firstChild;};CSL.XmlDOM.prototype.insertChildNodeAfter=function(parent,node,pos,datexml){var myxml,xml;myxml=this.importNode(node.ownerDocument,datexml);parent.replaceChild(myxml,node);return parent;};CSL.XmlDOM.prototype.insertPublisherAndPlace=function(myxml){var group=myxml.getElementsByTagName("group");for(var i=0,ilen=group.length;i<ilen;i+=1){var node=group.item(i);var skippers=[];for(var j=0,jlen=node.childNodes.length;j<jlen;j+=1){if(node.childNodes.item(j).nodeType!==1){skippers.push(j);}}if(node.childNodes.length-skippers.length===2){var twovars=[];for(var j=0,jlen=2;j<jlen;j+=1){if(skippers.indexOf(j)>-1){continue;}var child=node.childNodes.item(j);var subskippers=[];for(var k=0,klen=child.childNodes.length;k<klen;k+=1){if(child.childNodes.item(k).nodeType!==1){subskippers.push(k);}}if(child.childNodes.length-subskippers.length===0){twovars.push(child.getAttribute('variable'));if(child.getAttribute('suffix')||child.getAttribute('prefix')){twovars=[];break;}}}if(twovars.indexOf("publisher")>-1&&twovars.indexOf("publisher-place")>-1){node.setAttribute('has-publisher-and-publisher-place',true);}}}};CSL.XmlDOM.prototype.isChildOfSubstitute=function(node){if(node.parentNode){if(node.parentNode.tagName.toLowerCase()==="substitute"){return true;}else{return this.isChildOfSubstitute(node.parentNode);}}return false;};CSL.XmlDOM.prototype.addMissingNameNodes=function(myxml){var nameslist=myxml.getElementsByTagName("names");for(var i=0,ilen=nameslist.length;i<ilen;i+=1){var names=nameslist.item(i);var namelist=names.getElementsByTagName("name");if((!namelist||namelist.length===0)&&!this.isChildOfSubstitute(names)){var doc=names.ownerDocument;var name=doc.createElement("name");names.appendChild(name);}}};CSL.XmlDOM.prototype.addInstitutionNodes=function(myxml){var names,thenames,institution,theinstitution,theinstitutionpart,name,thename,xml,pos,len;names=myxml.getElementsByTagName("names");for(pos=0,len=names.length;pos<len;pos+=1){thenames=names.item(pos);name=thenames.getElementsByTagName("name");if(name.length==0){continue;}institution=thenames.getElementsByTagName("institution");if(institution.length==0){theinstitution=this.importNode(myxml.ownerDocument,this.institution);theinstitutionpart=theinstitution.getElementsByTagName("institution-part").item(0);thename=name.item(0);thenames.insertBefore(theinstitution,thename.nextSibling);for(var j=0,jlen=CSL.INSTITUTION_KEYS.length;j<jlen;j+=1){var attrname=CSL.INSTITUTION_KEYS[j];var attrval=thename.getAttribute(attrname);if(attrval){theinstitutionpart.setAttribute(attrname,attrval);}}var nameparts=thename.getElementsByTagName("name-part");for(var j=0,jlen=nameparts.length;j<jlen;j+=1){if('family'===nameparts[j].getAttribute('name')){for(var k=0,klen=CSL.INSTITUTION_KEYS.length;k<klen;k+=1){var attrname=CSL.INSTITUTION_KEYS[k];var attrval=nameparts[j].getAttribute(attrname);if(attrval){theinstitutionpart.setAttribute(attrname,attrval);}}}}}}};CSL.XmlDOM.prototype.flagDateMacros=function(myxml){var pos,len,thenode,thedate;var nodes=myxml.getElementsByTagName("macro");for(pos=0,len=nodes.length;pos<len;pos+=1){thenode=nodes.item(pos);thedate=thenode.getElementsByTagName("date");if(thedate.length){thenode.setAttribute('macro-has-date','true');}}};/*global CSL: true */CSL.setupXml=function(xmlObject){var dataObj={};var parser=null;if("undefined"!==typeof xmlObject){if("string"===typeof xmlObject){xmlObject=xmlObject.replace("^\uFEFF","").replace(/^\s+/,"");if(xmlObject.slice(0,1)==="<"){// Assume serialized XML
dataObj=CSL.parseXml(xmlObject);}else{// Assume serialized JSON
dataObj=JSON.parse(xmlObject);}parser=new CSL.XmlJSON(dataObj);}else if("undefined"!==typeof xmlObject.getAttribute){// Assume DOM instance
parser=new CSL.XmlDOM(xmlObject);}else if("undefined"!==typeof xmlObject.toXMLString){// Assume E4X object
parser=new CSL.XmlE4X(xmlObject);}else{// Assume JS object
parser=new CSL.XmlJSON(xmlObject);}}else{CSL.error("unable to parse XML input");}if(!parser){CSL.error("citeproc-js error: unable to parse CSL style or locale object");}return parser;};/*global CSL: true */CSL.getSortCompare=function(default_locale){if(CSL.stringCompare){return CSL.stringCompare;}var me=this;var strcmp;var strcmp_opts={sensitivity:"base",ignorePunctuation:true,numeric:true};// In order, attempt the following:
//   (1) Set locale collation from processor language
//   (2) Use localeCompare()
if(!default_locale){default_locale="en-US";}strcmp=function(a,b){return CSL.toLocaleLowerCase.call(me,a).localeCompare(CSL.toLocaleLowerCase.call(me,b),default_locale,strcmp_opts);};var stripPunct=function(str){return str.replace(/^[\[\]\'\"]*/g,"");};var getBracketPreSort=function(){if(!strcmp("[x","x")){return false;}else{return function(a,b){return strcmp(stripPunct(a),stripPunct(b));};}};var bracketPreSort=getBracketPreSort();var sortCompare=function(a,b){if(bracketPreSort){return bracketPreSort(a,b);}else{return strcmp(a,b);}};return sortCompare;};/*global CSL: true */CSL.ambigConfigDiff=function(a,b){var pos,len,ppos,llen;// return of true means the ambig configs differ
if(a.names.length!==b.names.length){//print("   (1)");
return 1;}else{for(pos=0,len=a.names.length;pos<len;pos+=1){if(a.names[pos]!==b.names[pos]){//print("   (2) "+a.names[pos]+" "+b.names[pos]);
return 1;}else{for(ppos=0,llen=a.givens[pos];ppos<llen;ppos+=1){if(a.givens[pos][ppos]!==b.givens[pos][ppos]){//print("   (3): "+a.givens[pos][ppos]+" "+b.givens[pos][ppos]+" "+pos+"/"+ppos+" "+b.givens[pos]);
return 1;}}}}}if(a.disambiguate!=b.disambiguate){//print("   (4) "+a.disambiguate+" "+b.disambiguate);
return 1;}if(a.year_suffix!==b.year_suffix){//print("   (5) "+a.year_suffix+" "+b.year_suffix);
return 1;}return 0;};CSL.cloneAmbigConfig=function(config,oldconfig){var i,ilen,j,jlen,param;var ret={};ret.names=[];ret.givens=[];ret.year_suffix=false;ret.disambiguate=false;for(i=0,ilen=config.names.length;i<ilen;i+=1){param=config.names[i];// Fixes update bug affecting plugins, without impacting
// efficiency with update of large numbers of year-suffixed
// items.
ret.names[i]=param;}for(i=0,ilen=config.givens.length;i<ilen;i+=1){param=[];for(j=0,jlen=config.givens[i].length;j<jlen;j+=1){// condition at line 312 of disambiguate.js protects against negative
// values of j
param.push(config.givens[i][j]);}ret.givens.push(param);}// XXXX Is this necessary at all?
if(oldconfig){ret.year_suffix=oldconfig.year_suffix;ret.disambiguate=oldconfig.disambiguate;}else{ret.year_suffix=config.year_suffix;ret.disambiguate=config.disambiguate;}return ret;};/**
 * Return current base configuration for disambiguation
 */CSL.getAmbigConfig=function(){var config,ret;config=this.tmp.disambig_request;if(!config){config=this.tmp.disambig_settings;}var ret=CSL.cloneAmbigConfig(config);return ret;};/**
 * Return max values for disambiguation
 */CSL.getMaxVals=function(){return this.tmp.names_max.mystack.slice();};/**
 * Return min value for disambiguation
 */CSL.getMinVal=function(){return this.tmp["et-al-min"];};/*global CSL: true */ /* For node execution pretty-printing (see below) */ /*
var INDENT = "";
*/CSL.tokenExec=function(token,Item,item){// Called on state object
var next,maybenext,exec,debug;debug=false;next=token.next;maybenext=false;/* Pretty-print node executions */ /*
    if (["if", "else-if", "else"].indexOf(token.name) === -1) {
        if (token.tokentype == 1) {
            INDENT = INDENT.slice(0, -2);
        }
    }
    this.sys.print(INDENT + "---> Token: " + token.name + " (" + token.tokentype + ") in " + this.tmp.area + ", " + this.output.current.mystack.length);
    if (["if", "else-if", "else"].indexOf(token.name) === -1) {
        if (token.tokentype == 0) {
            INDENT += "  ";
        }
    }
    */var record=function(result){if(result){this.tmp.jump.replace("succeed");return token.succeed;}else{this.tmp.jump.replace("fail");return token.fail;}};if(token.test){next=record.call(this,token.test(Item,item));}for(var i=0,ilen=token.execs.length;i<ilen;i++){exec=token.execs[i];maybenext=exec.call(token,this,Item,item);if(maybenext){next=maybenext;}}//SNIP-START
if(debug){CSL.debug(token.name+" ("+token.tokentype+") ---> done");}//SNIP-END
return next;};/**
 * Macro expander.
 * <p>Called on the state object.</p>
 */CSL.expandMacro=function(macro_key_token,target){var mkey,macro_nodes,end_of_macro,func;mkey=macro_key_token.postponed_macro;var sort_direction=macro_key_token.strings.sort_direction;// Decorations and affixes are in wrapper applied in cs:text
macro_key_token=new CSL.Token("group",CSL.START);var hasDate=false;var macroid=false;macro_nodes=this.cslXml.getNodesByName(this.cslXml.dataObj,'macro',mkey);if(macro_nodes.length){macroid=this.cslXml.getAttributeValue(macro_nodes[0],'cslid');hasDate=this.cslXml.getAttributeValue(macro_nodes[0],"macro-has-date");}if(hasDate){mkey=mkey+"@"+this.build.current_default_locale;func=function(state){if(state.tmp.extension){state.tmp["doing-macro-with-date"]=true;}};macro_key_token.execs.push(func);}if(this.build.macro_stack.indexOf(mkey)>-1){CSL.error("CSL processor error: call to macro \""+mkey+"\" would cause an infinite loop");}else{this.build.macro_stack.push(mkey);}macro_key_token.cslid=macroid;if(CSL.MODULE_MACROS[mkey]){macro_key_token.juris=mkey;this.opt.update_mode=CSL.POSITION;}// Macro group is treated as a real node in the style
CSL.Node.group.build.call(macro_key_token,this,target,true);// Node does not exist in the CSL
if(!this.cslXml.getNodeValue(macro_nodes)){CSL.error("CSL style error: undefined macro \""+mkey+"\"");}// Let's macro
var mytarget=CSL.getMacroTarget.call(this,mkey);if(mytarget){CSL.buildMacro.call(this,mytarget,macro_nodes);CSL.configureMacro.call(this,mytarget);}if(!this.build.extension){var func=function(macro_name){return function(state,Item,item){var next=0;while(next<state.macros[macro_name].length){next=CSL.tokenExec.call(state,state.macros[macro_name][next],Item,item);}};}(mkey);var text_node=new CSL.Token("text",CSL.SINGLETON);text_node.execs.push(func);target.push(text_node);}// Decorations and affixes are in wrapper applied in cs:text
end_of_macro=new CSL.Token("group",CSL.END);end_of_macro.strings.sort_direction=sort_direction;if(hasDate){func=function(state){if(state.tmp.extension){state.tmp["doing-macro-with-date"]=false;}};end_of_macro.execs.push(func);}if(macro_key_token.juris){end_of_macro.juris=mkey;}// Macro group is treated as a real node in the style
CSL.Node.group.build.call(end_of_macro,this,target,true);this.build.macro_stack.pop();};CSL.getMacroTarget=function(mkey){var mytarget=false;if(this.build.extension){mytarget=this[this.build.root+this.build.extension].tokens;}else if(!this.macros[mkey]){mytarget=[];this.macros[mkey]=mytarget;}return mytarget;};CSL.buildMacro=function(mytarget,macro_nodes){var builder=CSL.makeBuilder(this,mytarget);var mynode;if("undefined"===typeof macro_nodes.length){mynode=macro_nodes;}else{mynode=macro_nodes[0];}builder(mynode);};CSL.configureMacro=function(mytarget){if(!this.build.extension){this.configureTokenList(mytarget);}};/**
 * Convert XML node to token.
 * <p>This is called on an XML node.  After extracting the name and attribute
 * information from the node, it performs three operations.  Attribute information
 * relating to output formatting is stored on the node as an array of tuples,
 * which fixes the sequence of execution of output functions to be invoked
 * in the next phase of processing.  Other attribute information is reduced
 * to functions, and is pushed into an array on the token in no particular
 * order, for later execution.  The element name is used as a key to
 * invoke the relevant <code>build</code> method of the target element.
 * Element methods are defined in {@link CSL.Node}.</p>
 * @param {Object} state  The state object returned by {@link CSL.Engine}.
 * @param {Int} tokentype  A CSL namespace constant (<code>CSL.START</code>,
 * <code>CSL.END</code> or <code>CSL.SINGLETON</code>.
 */CSL.XmlToToken=function(state,tokentype,explicitTarget,var_stack){var name,txt,attrfuncs,attributes,decorations,token,key,target;name=state.cslXml.nodename(this);//CSL.debug(tokentype + " : " + name);
if(state.build.skip&&state.build.skip!==name){return;}if(!name){txt=state.cslXml.content(this);if(txt){state.build.text=txt;}return;}if(!CSL.Node[state.cslXml.nodename(this)]){CSL.error("Undefined node name \""+name+"\".");}attrfuncs=[];attributes=state.cslXml.attributes(this);decorations=CSL.setDecorations.call(this,state,attributes);token=new CSL.Token(name,tokentype);if(tokentype!==CSL.END||name==="if"||name==="else-if"||name==="layout"){//
// xml: more xml stuff
//
for(var key in attributes){if(attributes.hasOwnProperty(key)){if(tokentype===CSL.END&&key!=="@language"&&key!=="@locale"){continue;}if(attributes.hasOwnProperty(key)){if(CSL.Attributes[key]){try{CSL.Attributes[key].call(token,state,""+attributes[key]);}catch(e){CSL.error(key+" attribute: "+e);}}else{CSL.debug("warning: undefined attribute \""+key+"\" in style");}}}}token.decorations=decorations;if(CSL.DATE_VARIABLES.indexOf(attributes['@variable'])>-1){var_stack.push(token.variables);}}else if(tokentype===CSL.END&&attributes['@variable']){token.hasVariable=true;if(CSL.DATE_VARIABLES.indexOf(attributes['@variable'])>-1){token.variables=var_stack.pop();}}//
// !!!!!: eliminate diversion of tokens to separate
// token list (formerly used for reading in macros
// and terms).
//
if(explicitTarget){target=explicitTarget;}else{target=state[state.build.area].tokens;}// True flags real nodes in the style
CSL.Node[name].build.call(token,state,target,true);};/*global CSL: true */CSL.DateParser=function(){/*
     * Fixed values
     */ // jse imperial years
var epochPairs=[["\u660E\u6CBB",1867],["\u5927\u6B63",1911],["\u662D\u548C",1925],["\u5E73\u6210",1988]];// years by jse imperial epoch
var epochYearByName={};for(var i=0,ilen=epochPairs.length;i<ilen;i++){var key=epochPairs[i][0];var val=epochPairs[i][1];epochYearByName[key]=val;}var epochMatchStrings=[];var epochMap={};for(var i=0,ilen=epochPairs.length;i<ilen;i++){var pair=epochPairs[i];var val=pair[0];epochMatchStrings.push(val);epochMap[pair[0]]=pair[1];}var epochMatchString=epochMatchStrings.join("|");// regular expression to trap year name and year
// (splitter and matcher, to cope with ancient JS implementations)
var epochSplitter=new RegExp("(?:"+epochMatchString+")(?:[0-9]+)");var epochMatcher=new RegExp("(?:"+epochMatchString+")(?:[0-9]+)","g");// regular expression for month or day kanji label
var kanjiMonthDay=/(\u6708|\u5E74)/g;// regular expression for year kanji label
var kanjiYear=/\u65E5/g;// regular expression for double-width Japanese range marker
var kanjiRange=/\u301c/g;// parsing regexps for normalized strings
//   raw materials
var yearLast="(?:[?0-9]{1,2}%%NUMD%%){0,2}[?0-9]{4}(?![0-9])";var yearFirst="[?0-9]{4}(?:%%NUMD%%[?0-9]{1,2}){0,2}(?![0-9])";var numberVal="[?0-9]{1,3}";var rangeSeparator="[%%DATED%%]";var fuzzyChar="[?~]";var chars="[^\-\/\~\?0-9]+";var rexString="("+yearFirst+"|"+yearLast+"|"+numberVal+"|"+rangeSeparator+"|"+fuzzyChar+"|"+chars+")";//   composed regexps
var rexDash=new RegExp(rexString.replace(/%%NUMD%%/g,"-").replace(/%%DATED%%/g,"-"));var rexDashSlash=new RegExp(rexString.replace(/%%NUMD%%/g,"-").replace(/%%DATED%%/g,"\/"));var rexSlashDash=new RegExp(rexString.replace(/%%NUMD%%/g,"\/").replace(/%%DATED%%/g,"-"));/*
     * Mutable values
     */ // months
var monthString="january february march april may june july august september october november december spring summer fall winter spring summer";this.monthStrings=monthString.split(" ");/*
     * Configuration functions
     */this.setOrderDayMonth=function(){// preferred ordering for numeric dates
this.monthGuess=1;this.dayGuess=0;};this.setOrderMonthDay=function(){// preferred ordering for numeric dates
this.monthGuess=0;this.dayGuess=1;};this.resetDateParserMonths=function(){// Function to reset months to default.
this.monthSets=[];for(var i=0,ilen=this.monthStrings.length;i<ilen;i++){this.monthSets.push([this.monthStrings[i]]);}this.monthAbbrevs=[];for(var i=0,ilen=this.monthSets.length;i<ilen;i++){this.monthAbbrevs.push([]);for(var j=0,jlen=this.monthSets[i].length;j<jlen;j++){this.monthAbbrevs[i].push(this.monthSets[i][0].slice(0,3));}}this.monthRexes=[];for(var i=0,ilen=this.monthAbbrevs.length;i<ilen;i++){this.monthRexes.push(new RegExp("(?:"+this.monthAbbrevs[i].join("|")+")"));}};this.addDateParserMonths=function(lst){// Extend list of months with an additional set of month abbreviations,
// extending strings as required to resolve ambiguities.
// Normalize string to list
if("string"===typeof lst){lst=lst.split(/\s+/);}// Check that there are twelve (or sixteen) to add
if(lst.length!==12&&lst.length!==16){CSL.debug("month [+season] list of "+lst.length+", expected 12 or 16. Ignoring.");return;}// Extend as necessary to resolve ambiguities
// For each new month string ...
for(var i=0,ilen=lst.length;i<ilen;i++){var abbrevLength=null;var skip=false;var insert=3;var extendedSets={};for(var j=0,jlen=this.monthAbbrevs.length;j<jlen;j++){extendedSets[j]={};if(j===i){// Mark for skipping if same as an existing abbreviation of same month
for(var k=0,klen=this.monthAbbrevs[i].length;k<klen;k++){if(this.monthAbbrevs[i][k]===lst[i].slice(0,this.monthAbbrevs[i][k].length)){skip=true;break;}}}else{// Mark for extending if same as existing abbreviation of any expression of another month
for(var k=0,klen=this.monthAbbrevs[j].length;k<klen;k++){abbrevLength=this.monthAbbrevs[j][k].length;if(this.monthAbbrevs[j][k]===lst[i].slice(0,abbrevLength)){while(this.monthSets[j][k].slice(0,abbrevLength)===lst[i].slice(0,abbrevLength)){// Abort when full length is hit, otherwise extend
if(abbrevLength>lst[i].length||abbrevLength>this.monthSets[j][k].length){CSL.debug("unable to disambiguate month string in date parser: "+lst[i]);break;}else{// Mark both new entry and existing abbrev for extension
abbrevLength+=1;}}insert=abbrevLength;extendedSets[j][k]=abbrevLength;}}}for(var jKey in extendedSets){for(var kKey in extendedSets[jKey]){abbrevLength=extendedSets[jKey][kKey];jKey=parseInt(jKey,10);kKey=parseInt(kKey,10);this.monthAbbrevs[jKey][kKey]=this.monthSets[jKey][kKey].slice(0,abbrevLength);}}}// Insert here
if(!skip){this.monthSets[i].push(lst[i]);this.monthAbbrevs[i].push(lst[i].slice(0,insert));}}// Compose
this.monthRexes=[];this.monthRexStrs=[];for(var i=0,ilen=this.monthAbbrevs.length;i<ilen;i++){this.monthRexes.push(new RegExp("^(?:"+this.monthAbbrevs[i].join("|")+")"));this.monthRexStrs.push("^(?:"+this.monthAbbrevs[i].join("|")+")");}if(this.monthAbbrevs.length===18){for(var i=12,ilen=14;i<ilen;i++){this.monthRexes[i+4]=new RegExp("^(?:"+this.monthAbbrevs[i].join("|")+")");this.monthRexStrs[i+4]="^(?:"+this.monthAbbrevs[i].join("|")+")";}}};/*
     * Conversion functions
     */this.convertDateObjectToArray=function(thedate){// Converts object in place and returns object
thedate["date-parts"]=[];thedate["date-parts"].push([]);var slicelen=0;var part;for(var i=0,ilen=3;i<ilen;i++){part=["year","month","day"][i];if(!thedate[part]){break;}slicelen+=1;thedate["date-parts"][0].push(thedate[part]);delete thedate[part];}thedate["date-parts"].push([]);for(var i=0,ilen=slicelen;i<ilen;i++){part=["year_end","month_end","day_end"][i];if(!thedate[part]){break;}thedate["date-parts"][1].push(thedate[part]);delete thedate[part];}if(thedate["date-parts"][0].length!==thedate["date-parts"][1].length){thedate["date-parts"].pop();}return thedate;};// XXXX String output is currently unable to represent ranges
this.convertDateObjectToString=function(thedate){// Returns string
var ret=[];for(var i=0,ilen=3;i<ilen;i+=1){if(thedate[CSL.DATE_PARTS_ALL[i]]){ret.push(thedate[CSL.DATE_PARTS_ALL[i]]);}else{break;}}return ret.join("-");};/*
     * Utility function
     */this._parseNumericDate=function(ret,delim,suff,txt){if(!suff){suff="";}var lst=txt.split(delim);for(var i=0,ilen=lst.length;i<ilen;i++){if(lst[i].length===4){ret["year"+suff]=lst[i].replace(/^0*/,"");if(!i){lst=lst.slice(1);}else{lst=lst.slice(0,i);}break;}}for(var i=0,ilen=lst.length;i<ilen;i++){lst[i]=parseInt(lst[i],10);}if(lst.length===1||lst.length===2&&!lst[1]){var month=lst[0];if(month){ret["month"+suff]=""+lst[0];}}else if(lst.length===2){if(lst[this.monthGuess]>12){var month=lst[this.dayGuess];var day=lst[this.monthGuess];if(month){ret["month"+suff]=""+month;if(day){ret["day"+suff]=""+day;}}}else{var month=lst[this.monthGuess];var day=lst[this.dayGuess];if(month){ret["month"+suff]=""+month;if(day){ret["day"+suff]=""+day;}}}}};/*
     * Parsing functions
     */this.parseDateToObject=function(txt){//
// Normalize the format and the year if it's a Japanese date
//
var orig=txt;var slashPos=-1;var dashPos=-1;var yearIsNegative=false;var lst;if(txt){txt=txt.replace(/^(.*[0-9])T[0-9].*/,"$1");// If string leads with a minus sign, strip and memo it.
if(txt.slice(0,1)==="-"){yearIsNegative=true;txt=txt.slice(1);}// If string is a number of 1 to 3 characters only, treat as year.
if(txt.match(/^[0-9]{1,3}$/)){while(txt.length<4){txt="0"+txt;}}// Normalize to string
txt=""+txt;// Remove things that look like times
txt=txt.replace(/\s*[0-9]{2}:[0-9]{2}(?::[0-9]+)/,"");var m=txt.match(kanjiMonthDay);if(m){txt=txt.replace(/\s+/g,"");txt=txt.replace(kanjiYear,"");txt=txt.replace(kanjiMonthDay,"-");txt=txt.replace(kanjiRange,"/");txt=txt.replace(/\-\//g,"/");txt=txt.replace(/-$/g,"");// Tortuous workaround for IE6
var slst=txt.split(epochSplitter);lst=[];var mm=txt.match(epochMatcher);if(mm){var mmx=[];for(var i=0,ilen=mm.length;i<ilen;i++){mmx=mmx.concat(mm[i].match(/([^0-9]+)([0-9]+)/).slice(1));}for(var i=0,ilen=slst.length;i<ilen;i++){lst.push(slst[i]);if(i!==ilen-1){// pos is undeclared, and multiplying by 2 here is insane.
var mmpos=i*2;lst.push(mmx[mmpos]);lst.push(mmx[mmpos+1]);}}}else{lst=slst;}// workaround duly applied, this now works
for(var i=1,ilen=lst.length;i<ilen;i+=3){lst[i+1]=epochMap[lst[i]]+parseInt(lst[i+1],10);lst[i]="";}txt=lst.join("");txt=txt.replace(/\s*-\s*$/,"").replace(/\s*-\s*\//,"/");//
// normalize date and identify delimiters
//
txt=txt.replace(/\.\s*$/,"");// not sure what this is meant to do
txt=txt.replace(/\.(?! )/,"");slashPos=txt.indexOf("/");dashPos=txt.indexOf("-");}}// drop punctuation from a.d., b.c.
txt=txt.replace(/([A-Za-z])\./g,"$1");var number="";var note="";var thedate={};var rangeDelim;var dateDelim;if(txt.slice(0,1)==="\""&&txt.slice(-1)==="\""){thedate.literal=txt.slice(1,-1);return thedate;}if(slashPos>-1&&dashPos>-1){var slashCount=txt.split("/");if(slashCount.length>3){rangeDelim="-";txt=txt.replace(/\_/g,"-");dateDelim="/";lst=txt.split(rexSlashDash);}else{rangeDelim="/";txt=txt.replace(/\_/g,"/");dateDelim="-";lst=txt.split(rexDashSlash);}}else{txt=txt.replace(/\//g,"-");txt=txt.replace(/\_/g,"-");rangeDelim="-";dateDelim="-";lst=txt.split(rexDash);}var ret=[];for(var i=0,ilen=lst.length;i<ilen;i++){var m=lst[i].match(/^\s*([\-\/]|[^\-\/\~\?0-9]+|[\-~?0-9]+)\s*$/);if(m){ret.push(m[1]);}}//
// Phase 2
//
var delimPos=ret.indexOf(rangeDelim);var delims=[];var isRange=false;if(delimPos>-1){delims.push([0,delimPos]);delims.push([delimPos+1,ret.length]);isRange=true;}else{delims.push([0,ret.length]);}//
// For each side of a range divide ...
//
var suff="";for(var i=0,ilen=delims.length;i<ilen;i++){var delim=delims[i];//
// Process each element ...
//
var date=ret.slice(delim[0],delim[1]);outer:for(var j=0,jlen=date.length;j<jlen;j++){var element=date[j];//
// If it's a numeric date, process it.
//
if(element.indexOf(dateDelim)>-1){this._parseNumericDate(thedate,dateDelim,suff,element);continue;}//
// If it's an obvious year, record it.
//
if(element.match(/[0-9]{4}/)){thedate["year"+suff]=element.replace(/^0*/,"");continue;}//
// If it's a fuzzy marker, record it.
//
if(element==="~"||element==="?"||element==="c"||element.match(/^cir/)){thedate.circa=true;}//
// If it's a month, record it.
//
for(var k=0,klen=this.monthRexes.length;k<klen;k++){if(element.toLocaleLowerCase().match(this.monthRexes[k])){thedate["month"+suff]=""+(parseInt(k,10)+1);continue outer;}}//
// If it's a number, make a note of it
//
if(element.match(/^[0-9]+$/)){number=element;}//
// If it's a BC or AD marker, make a year of
// any note.  Separate, reverse the sign of the year
// if it's BC.
//
if(element.toLocaleLowerCase().match(/^bc/)&&number){thedate["year"+suff]=""+number*-1;number="";continue;}if(element.toLocaleLowerCase().match(/^ad/)&&number){thedate["year"+suff]=""+number;number="";continue;}//
// If it's cruft, make a note of it
//
if(element.toLocaleLowerCase().match(/(?:mic|tri|hil|eas)/)&&!thedate["season"+suff]){note=element;continue;}}//
// If at the end of the string there's still a note
// hanging around, make a day of it.
//
if(number){thedate["day"+suff]=number;number="";}//
// If at the end of the string there's cruft lying
// around, and the season field is empty, put the
// cruft there.
//
if(note&&!thedate["season"+suff]){thedate["season"+suff]=note.trim();note="";}suff="_end";}//
// update any missing elements on each side of the divide
// from the other
//
if(isRange){for(var j=0,jlen=CSL.DATE_PARTS_ALL.length;j<jlen;j++){var item=CSL.DATE_PARTS_ALL[j];if(thedate[item]&&!thedate[item+"_end"]){thedate[item+"_end"]=thedate[item];}else if(!thedate[item]&&thedate[item+"_end"]){thedate[item]=thedate[item+"_end"];}}}//
// If there's no year, or if there only a year and a day, it's a failure; pass through the literal
//
if(!thedate.year||thedate.year&&thedate.day&&!thedate.month){thedate={"literal":orig};}var parts=["year","month","day","year_end","month_end","day_end"];for(var i=0,ilen=parts.length;i<ilen;i++){var part=parts[i];if("string"===typeof thedate[part]&&thedate[part].match(/^[0-9]+$/)){thedate[part]=parseInt(thedate[part],10);}}if(yearIsNegative&&Object.keys(thedate).indexOf("year")>-1){thedate.year=thedate.year*-1;}return thedate;};this.parseDateToArray=function(txt){return this.convertDateObjectToArray(this.parseDateToObject(txt));};this.parseDateToString=function(txt){return this.convertDateObjectToString(this.parseDateToObject(txt));};this.parse=function(txt){return this.parseDateToObject(txt);};/*

     * Setup
     */this.setOrderMonthDay();this.resetDateParserMonths();};CSL.DateParser=new CSL.DateParser();/*global CSL: true */CSL.Engine=function(sys,style,lang,forceLang){var attrs,langspec;this.processor_version=CSL.PROCESSOR_VERSION;this.csl_version="1.0";this.sys=sys;if(typeof Object.assign!='function'){// Must be writable: true, enumerable: false, configurable: true
Object.defineProperty(Object,"assign",{value:function assign(target){// .length of function is 2
'use strict';if(target==null){// TypeError if undefined or null
throw new TypeError('Cannot convert undefined or null to object');}var to=Object(target);for(var index=1;index<arguments.length;index++){var nextSource=arguments[index];if(nextSource!=null){// Skip over if undefined or null
for(var nextKey in nextSource){// Avoid bugs when hasOwnProperty is shadowed
if(Object.prototype.hasOwnProperty.call(nextSource,nextKey)){to[nextKey]=nextSource[nextKey];}}}}return to;},writable:true,configurable:true});}// XXX This may be excess code. Given the normalization performed on
// XXX the output queue before variableWrapper() is run, a single
// XXX space should be the most cruft that we ever see before a variable.
if(sys.variableWrapper){CSL.VARIABLE_WRAPPER_PREPUNCT_REX=new RegExp('^(['+[" "].concat(CSL.SWAPPING_PUNCTUATION).join("")+']*)(.*)');}// XXXX This should be restored -- temporarily suspended for testing of JSON style support.
if(CSL.retrieveStyleModule){this.sys.retrieveStyleModule=CSL.retrieveStyleModule;}if(CSL.getAbbreviation){this.sys.getAbbreviation=CSL.getAbbreviation;}if(this.sys.stringCompare){CSL.stringCompare=this.sys.stringCompare;}this.sys.AbbreviationSegments=CSL.AbbreviationSegments;this.transform=new CSL.Transform(this);// true or false
this.setParseNames=function(val){this.opt['parse-names']=val;};this.opt=new CSL.Engine.Opt();this.tmp=new CSL.Engine.Tmp();this.build=new CSL.Engine.Build();this.fun=new CSL.Engine.Fun(this);this.configure=new CSL.Engine.Configure();// Build citation before citation_sort in order to pick up
// state.opt.update_mode, needed it determine whether
// a grouped sort should be performed.
this.citation_sort=new CSL.Engine.CitationSort();this.bibliography_sort=new CSL.Engine.BibliographySort();this.citation=new CSL.Engine.Citation(this);this.bibliography=new CSL.Engine.Bibliography();this.intext=new CSL.Engine.InText();this.output=new CSL.Output.Queue(this);//this.render = new CSL.Render(this);
//
// This latter queue is used for formatting date chunks
// before they are folded back into the main queue.
//
this.dateput=new CSL.Output.Queue(this);this.cslXml=CSL.setupXml(style);for(var i in CSL.SYS_OPTIONS){var option=CSL.SYS_OPTIONS[i];if("boolean"===typeof this.sys[option]){this.opt.development_extensions[option]=this.sys[option];}}if(this.opt.development_extensions.uppercase_subtitles||this.opt.development_extensions.implicit_short_title){this.opt.development_extensions.main_title_from_short_title=true;}if(this.opt.development_extensions.csl_reverse_lookup_support){this.build.cslNodeId=0;this.setCslNodeIds=function(myxml,nodename){var children=this.cslXml.children(myxml);this.cslXml.setAttribute(myxml,'cslid',this.build.cslNodeId);this.opt.nodenames.push(nodename);this.build.cslNodeId+=1;for(var i=0,ilen=this.cslXml.numberofnodes(children);i<ilen;i+=1){nodename=this.cslXml.nodename(children[i]);if(nodename){this.setCslNodeIds(children[i],nodename);}}};this.setCslNodeIds(this.cslXml.dataObj,"style");}// Preprocessing ops for the XML input
this.cslXml.addMissingNameNodes(this.cslXml.dataObj);this.cslXml.addInstitutionNodes(this.cslXml.dataObj);this.cslXml.insertPublisherAndPlace(this.cslXml.dataObj);this.cslXml.flagDateMacros(this.cslXml.dataObj);attrs=this.cslXml.attributes(this.cslXml.dataObj);if("undefined"===typeof attrs["@sort-separator"]){this.cslXml.setAttribute(this.cslXml.dataObj,"sort-separator",", ");}// This setting does the right thing and seems not to be side-effects
this.opt["initialize-with-hyphen"]=true;// Locale resolution
//
// (1) Get three locale strings 
//     -- default-locale (stripped)
//     -- processor-locale
//     -- en_US
this.setStyleAttributes();this.opt.xclass=this.cslXml.getAttributeValue(this.cslXml.dataObj,"class");this.opt["class"]=this.opt.xclass;this.opt.styleID=this.cslXml.getStyleId(this.cslXml.dataObj);this.opt.styleName=this.cslXml.getStyleId(this.cslXml.dataObj,true);if(this.opt.version.slice(0,4)==="1.1m"){this.opt.development_extensions.consolidate_legal_items=true;this.opt.development_extensions.consolidate_container_items=true;this.opt.development_extensions.main_title_from_short_title=true;this.opt.development_extensions.expect_and_symbol_form=true;this.opt.development_extensions.require_explicit_legal_case_title_short=true;this.opt.development_extensions.force_jurisdiction=true;this.opt.development_extensions.force_title_abbrev_fallback=true;}// We seem to have two language specs flying around:
//   this.opt["default-locale"], and this.opt.lang
// Keeping them aligned for safety's sake, pending
// eventual cleanup.
if(lang){lang=lang.replace("_","-");lang=CSL.normalizeLocaleStr(lang);}if(this.opt["default-locale"][0]){this.opt["default-locale"][0]=this.opt["default-locale"][0].replace("_","-");this.opt["default-locale"][0]=CSL.normalizeLocaleStr(this.opt["default-locale"][0]);}if(lang&&forceLang){this.opt["default-locale"]=[lang];}if(lang&&!forceLang&&this.opt["default-locale"][0]){lang=this.opt["default-locale"][0];}if(this.opt["default-locale"].length===0){if(!lang){lang="en-US";}this.opt["default-locale"].push("en-US");}if(!lang){lang=this.opt["default-locale"][0];}langspec=CSL.localeResolve(lang);this.opt.lang=langspec.best;this.opt["default-locale"][0]=langspec.best;this.locale={};if(!this.opt["default-locale-sort"]){this.opt["default-locale-sort"]=this.opt["default-locale"][0];}// Test processor against JS engine locale mess to find a field separator that works
if('dale|'.localeCompare('daleb',this.opt["default-locale-sort"])>-1){this.opt.sort_sep="@";}else{this.opt.sort_sep="|";}this.localeConfigure(langspec);// Build skip-word regexp
function makeRegExp(lst){var lst=lst.slice();var ret=new RegExp("(?:(?:[?!:]*\\s+|-|^)(?:"+lst.join("|")+")(?=[!?:]*\\s+|-|$))","g");return ret;}this.locale[this.opt.lang].opts["skip-words-regexp"]=makeRegExp(this.locale[this.opt.lang].opts["skip-words"]);this.output.adjust=new CSL.Output.Queue.adjust(this.getOpt('punctuation-in-quote'));this.registry=new CSL.Registry(this);// XXX For modular jurisdiction support, parameterize buildTokenLists().
// XXX Feed as arguments:
// XXX * actual node to be walked (cslXml)
// XXX * actual target array
this.macros={};this.build.area="citation";var area_nodes=this.cslXml.getNodesByName(this.cslXml.dataObj,this.build.area);this.buildTokenLists(area_nodes,this[this.build.area].tokens);this.build.area="bibliography";var area_nodes=this.cslXml.getNodesByName(this.cslXml.dataObj,this.build.area);this.buildTokenLists(area_nodes,this[this.build.area].tokens);this.build.area="intext";var area_nodes=this.cslXml.getNodesByName(this.cslXml.dataObj,this.build.area);this.buildTokenLists(area_nodes,this[this.build.area].tokens);if(this.opt.parallel.enable){this.parallel=new CSL.Parallel(this);}this.juris={};this.configureTokenLists();this.disambiguate=new CSL.Disambiguation(this);this.splice_delimiter=false;//
// date parser
//
this.fun.dateparser=CSL.DateParser;//
// flip-flopper for inline markup
//
this.fun.flipflopper=new CSL.Util.FlipFlopper(this);//
// utility functions for quotes
//
this.setCloseQuotesArray();//
// configure ordinal numbers generator
//
this.fun.ordinalizer.init(this);//
// configure long ordinal numbers generator
//
this.fun.long_ordinalizer.init(this);//
// set up page mangler
//
this.fun.page_mangler=CSL.Util.PageRangeMangler.getFunction(this,"page");this.fun.year_mangler=CSL.Util.PageRangeMangler.getFunction(this,"year");this.setOutputFormat("html");};CSL.Engine.prototype.setCloseQuotesArray=function(){var ret;ret=[];ret.push(this.getTerm("close-quote"));ret.push(this.getTerm("close-inner-quote"));ret.push('"');ret.push("'");this.opt.close_quotes_array=ret;};// Walker for preparsed XML input
CSL.makeBuilder=function(me,target){var var_stack=[];var node_stack=[];function runStart(node){node_stack.push(node);CSL.XmlToToken.call(node,me,CSL.START,target,var_stack);}function runEnd(){var node=node_stack.pop();CSL.XmlToToken.call(node,me,CSL.END,target,var_stack);}function runSingle(node){CSL.XmlToToken.call(node,me,CSL.SINGLETON,target,var_stack);}function buildStyle(nodes,parent,node_stack){if(!node_stack){node_stack=[];}if(!nodes){nodes=[];}if("undefined"===typeof nodes.length){nodes=[nodes];}for(var i=0;i<nodes.length;i++){var node=nodes[i];if(me.cslXml.nodename(node)===null){continue;}if(parent&&me.cslXml.nodename(node)==="date"){CSL.Util.fixDateNode.call(me,parent,i,node);node=me.cslXml.children(parent)[i];}if(me.cslXml.numberofnodes(me.cslXml.children(node))){runStart(node);buildStyle(me.cslXml.children(node),node,node_stack);runEnd();}else{runSingle(node);}}}return buildStyle;};CSL.Engine.prototype.buildTokenLists=function(area_nodes,target){if(!this.cslXml.getNodeValue(area_nodes)){return;}var builder=CSL.makeBuilder(this,target);var mynode;if("undefined"===typeof area_nodes.length){mynode=area_nodes;}else{mynode=area_nodes[0];}builder(mynode);};CSL.Engine.prototype.setStyleAttributes=function(){var dummy,attributes,attrname;// Protect against DOM engines that deliver a top-level document
// (needed for createElement) that does not contain our top-level node.
// 
// The string coercion on this.cslXml.tagName addresses a bizarre
// condition on the top-level node in jsdom running under node.js, in which:
//   (1) typeof this.cslXml.tagName === "undefined"; and
//   (2) !this.cslXml.tagName === false
// Coerced, it becomes an empty string.
var dummy={};dummy.name=this.cslXml.nodename(this.cslXml.dataObj);attributes=this.cslXml.attributes(this.cslXml.dataObj);for(attrname in attributes){if(attributes.hasOwnProperty(attrname)){// attr = attributes[key];
CSL.Attributes[attrname].call(dummy,this,attributes[attrname]);}}};CSL.Engine.prototype.getTerm=function(term,form,plural,gender,mode,forceDefaultLocale){if(term&&term.match(/[A-Z]/)&&term===term.toUpperCase()){CSL.debug("Warning: term key is in uppercase form: "+term);term=term.toLowerCase();}var lang;if(forceDefaultLocale){lang=this.opt["default-locale"][0];}else{lang=this.opt.lang;}var ret=CSL.Engine.getField(CSL.LOOSE,this.locale[lang].terms,term,form,plural,gender);// XXXXX Temporary, until locale term is deployed in CSL.
if(!ret&&term==="range-delimiter"){ret="\u2013";}// XXXXX Not so good if mode is neither strict nor tolerant ...
if(typeof ret==="undefined"){if(mode===CSL.STRICT){CSL.error("Error in getTerm: term \""+term+"\" does not exist.");}else if(mode===CSL.TOLERANT){ret="";}}if(ret){this.tmp.cite_renders_content=true;}return ret;};CSL.Engine.prototype.getDate=function(form,forceDefaultLocale){var lang;if(forceDefaultLocale){lang=this.opt["default-locale"];}else{lang=this.opt.lang;}if(this.locale[lang].dates[form]){return this.locale[lang].dates[form];}else{return false;}};CSL.Engine.prototype.getOpt=function(arg){if("undefined"!==typeof this.locale[this.opt.lang].opts[arg]){return this.locale[this.opt.lang].opts[arg];}else{return false;}};CSL.Engine.prototype.getVariable=function(Item,varname,form,plural){return CSL.Engine.getField(CSL.LOOSE,Item,varname,form,plural);};CSL.Engine.prototype.getDateNum=function(ItemField,partname){if("undefined"===typeof ItemField){return 0;}else{return ItemField[partname];}};CSL.Engine.getField=function(mode,hash,term,form,plural,gender){var ret,forms,f,pos,len,hashterm;ret="";if("undefined"===typeof hash[term]){if(mode===CSL.STRICT){CSL.error("Error in getField: term \""+term+"\" does not exist.");}else{return undefined;}}if(gender&&hash[term][gender]){hashterm=hash[term][gender];}else{hashterm=hash[term];}forms=[];if(form==="symbol"){forms=["symbol","short"];}else if(form==="verb-short"){forms=["verb-short","verb"];}else if(form!=="long"){forms=[form];}forms=forms.concat(["long"]);len=forms.length;for(pos=0;pos<len;pos+=1){f=forms[pos];if("string"===typeof hashterm||"number"===typeof hashterm){ret=hashterm;}else if("undefined"!==typeof hashterm[f]){if("string"===typeof hashterm[f]||"number"===typeof hashterm[f]){ret=hashterm[f];}else{if("number"===typeof plural){ret=hashterm[f][plural];}else{ret=hashterm[f][0];}}break;}}return ret;};CSL.Engine.prototype.configureTokenLists=function(){var area,pos,len;//for each (var area in ["citation", "citation_sort", "bibliography","bibliography_sort"]) {
len=CSL.AREAS.length;for(pos=0;pos<len;pos+=1){//var ret = [];
area=CSL.AREAS[pos];var tokens=this[area].tokens;this.configureTokenList(tokens);}this.version=CSL.version;return this.state;};CSL.Engine.prototype.configureTokenList=function(tokens){var dateparts_master,token,dateparts,part,ppos,pppos,llen,lllen;dateparts_master=["year","month","day"];llen=tokens.length-1;for(ppos=llen;ppos>-1;ppos+=-1){token=tokens[ppos];//token.pos = ppos;
//ret.push(token);
if("date"===token.name&&CSL.END===token.tokentype){dateparts=[];}if("date-part"===token.name&&token.strings.name){lllen=dateparts_master.length;for(pppos=0;pppos<lllen;pppos+=1){part=dateparts_master[pppos];if(part===token.strings.name){dateparts.push(token.strings.name);}}}if("date"===token.name&&CSL.START===token.tokentype){dateparts.reverse();token.dateparts=dateparts;}token.next=ppos+1;if(token.name&&CSL.Node[token.name].configure){CSL.Node[token.name].configure.call(token,this,ppos);}}};CSL.Engine.prototype.refetchItems=function(ids){var ret=[];for(var i=0,ilen=ids.length;i<ilen;i+=1){ret.push(this.refetchItem(""+ids[i]));}return ret;};CSL.ITERATION=0;// Wrapper for sys.retrieveItem supplied by calling application.
// Adds experimental fields embedded in the note field for
// style development trial and testing purposes.
CSL.Engine.prototype.retrieveItem=function(id){var Item,m,i;if(!this.tmp.loadedItemIDs[id]){this.tmp.loadedItemIDs[id]=true;}else{return this.registry.refhash[id];}if(this.opt.development_extensions.normalize_lang_keys_to_lowercase&&"boolean"===typeof this.opt.development_extensions.normalize_lang_keys_to_lowercase){// This is a hack. Should properly be configured by a processor method after build.
for(var i=0,ilen=this.opt["default-locale"].length;i<ilen;i+=1){this.opt["default-locale"][i]=this.opt["default-locale"][i].toLowerCase();}for(var i=0,ilen=this.opt["locale-translit"].length;i<ilen;i+=1){this.opt["locale-translit"][i]=this.opt["locale-translit"][i].toLowerCase();}for(var i=0,ilen=this.opt["locale-translat"].length;i<ilen;i+=1){this.opt["locale-translat"][i]=this.opt["locale-translat"][i].toLowerCase();}this.opt.development_extensions.normalize_lang_keys_to_lowercase=100;}//Zotero.debug("XXX === ITERATION " + CSL.ITERATION + " "+ id +" ===");
CSL.ITERATION+=1;Item=JSON.parse(JSON.stringify(this.sys.retrieveItem(""+id)));// Optionally normalize keys to lowercase()
if(this.opt.development_extensions.normalize_lang_keys_to_lowercase){if(Item.multi){if(Item.multi._keys){for(var field in Item.multi._keys){for(var key in Item.multi._keys[field]){if(key!==key.toLowerCase()){Item.multi._keys[field][key.toLowerCase()]=Item.multi._keys[field][key];delete Item.multi._keys[field][key];}}}}if(Item.multi.main){for(var field in Item.multi.main){Item.multi.main[field]=Item.multi.main[field].toLowerCase();}}}for(var i=0,ilen=CSL.NAME_VARIABLES.length;i>ilen;i+=1){var ctype=CSL.NAME_VARIABLES[i];if(Item[ctype]&&Item[ctype].multi){for(var j=0,jlen=Item[ctype].length;j<jlen;j+=1){var creator=Item[ctype][j];if(creator.multi){if(creator.multi._key){for(var key in creator.multi._key){if(key!==key.toLowerCase()){creator.multi._key[key.toLowerCase()]=creator.multi._key[key];delete creator.multi._key[key];}}}if(creator.multi.main){creator.multi.main=creator.multi.main.toLowerCase();}}}}}}// Normalize language field into "language" and "language-original"
if(Item.language&&Item.language.match(/[><]/)){// Attempt to split field in two
var m=Item.language.match(/(.*?)([<>])(.*)/);if(m[2]==="<"){Item["language-name"]=m[1];Item["language-name-original"]=m[3];}else{Item["language-name"]=m[3];Item["language-name-original"]=m[1];}if(this.opt.multi_layout){if(Item["language-name-original"]){Item.language=Item["language-name-original"];}}else{if(Item["language-name"]){Item.language=Item["language-name"];}}}if(Item.page){Item["page-first"]=Item.page;var num=""+Item.page;var m=num.split(/\s*(?:&|, |-|\u2013)\s*/);if(m[0].slice(-1)!=="\\"){Item["page-first"]=m[0];}}// Optional development extensions
if(this.opt.development_extensions.field_hack&&Item.note){// false is for validFieldsForType (all conforming entries scrubbed when false)
CSL.parseNoteFieldHacks(Item,false,this.opt.development_extensions.allow_field_hack_date_override);}// not including locator-date
for(var key in Item){if(CSL.DATE_VARIABLES.indexOf(key.replace(/^alt-/,""))>-1){var dateobj=Item[key];if(dateobj){// raw date parsing is harmless, but can be disabled if desired
if(this.opt.development_extensions.raw_date_parsing){if(dateobj.raw&&(!dateobj["date-parts"]||dateobj["date-parts"].length===0)){dateobj=this.fun.dateparser.parseDateToObject(dateobj.raw);}}Item[key]=this.dateParseArray(dateobj);}}}if(this.opt.development_extensions.consolidate_legal_items){if(Item.type&&["bill","gazette","legislation","regulation","treaty"].indexOf(Item.type)>-1){var varname;var elements=["type","title","jurisdiction","genre","volume","container-title"];var legislation_id=[];for(var i=0,ilen=elements.length;i<ilen;i+=1){varname=elements[i];if(Item[varname]){legislation_id.push(Item[varname]);}}elements=["original-date","issued"];for(var i=0,ilen=elements.length;i<ilen;i+=1){varname=elements[i];if(Item[varname]&&Item[varname].year){var value=Item[varname].year;legislation_id.push(value);break;}}Item.legislation_id=legislation_id.join("::");}}if(this.bibliography.opt.track_container_items){if(this.bibliography.opt.track_container_items.indexOf(Item.type)>-1){var varname;var elements=["type","container-title","publisher","edition"];var container_id=[];for(var i=0,ilen=elements.length;i<ilen;i+=1){varname=elements[i];if(Item[varname]){container_id.push(Item[varname]);}}Item.container_id=container_id.join("::");}}// For authority to name shape in legal styles
if(this.opt.development_extensions.force_jurisdiction){if("string"===typeof Item.authority){Item.authority=[{literal:Item.authority,multi:{_key:{}}}];if(Item.multi&&Item.multi._keys&&Item.multi._keys.authority){Item.authority[0].multi._key={};for(var key in Item.multi._keys.authority){Item.authority[0].multi._key[key]={literal:Item.multi._keys.authority[key]};}}}}// Add getAbbreviation() call for title-short and container-title-short
if(!Item["title-short"]){Item["title-short"]=Item.shortTitle;}// Add support for main_title_from_short_title
if(this.opt.development_extensions.main_title_from_short_title){var narrowSpaceLocale=this.opt["default-locale"][0].slice(0,2).toLowerCase()==="fr";CSL.extractTitleAndSubtitle.call(this,Item,narrowSpaceLocale);}var isLegalType=["bill","legal_case","legislation","gazette","regulation"].indexOf(Item.type)>-1;if(this.opt.development_extensions.force_jurisdiction&&isLegalType){if(!Item.jurisdiction){Item.jurisdiction="us";}}var normalizedKey;if(!isLegalType&&Item.title&&this.sys.getAbbreviation){var noHints=false;if(!Item.jurisdiction){noHints=true;}if(this.sys.normalizeAbbrevsKey){normalizedKey=this.sys.normalizeAbbrevsKey("title",Item.title);}else{normalizedKey=Item.title;}var jurisdiction=this.transform.loadAbbreviation(Item.jurisdiction,"title",normalizedKey,Item.language);if(this.transform.abbrevs[jurisdiction].title){if(this.transform.abbrevs[jurisdiction].title[normalizedKey]){Item["title-short"]=this.transform.abbrevs[jurisdiction].title[normalizedKey];}}}if(!Item["container-title-short"]){Item["container-title-short"]=Item.journalAbbreviation;}if(Item["container-title"]&&this.sys.getAbbreviation){if(this.sys.normalizeAbbrevsKey){normalizedKey=this.sys.normalizeAbbrevsKey(Item["container-title"]);}else{normalizedKey=Item["container-title"];}var jurisdiction=this.transform.loadAbbreviation(Item.jurisdiction,"container-title",normalizedKey,Item.language);if(this.transform.abbrevs[jurisdiction]["container-title"]){if(this.transform.abbrevs[jurisdiction]["container-title"][normalizedKey]){Item["container-title-short"]=this.transform.abbrevs[jurisdiction]["container-title"][normalizedKey];}}}if(Item.jurisdiction){Item.country=Item.jurisdiction.split(":")[0];}if(this.registry.refhash[id]){if(JSON.stringify(this.registry.refhash[id])!=JSON.stringify(Item)){for(var key in this.registry.refhash[id]){delete this.registry.refhash[id][key];}this.tmp.taintedItemIDs[Item.id]=true;Object.assign(this.registry.refhash[id],Item);}}else{this.registry.refhash[id]=Item;}return this.registry.refhash[id];};CSL.Engine.prototype.refetchItem=function(id){return this.registry.refhash[id];};// Executed during style build
CSL.Engine.prototype.setOpt=function(token,name,value){if(token.name==="style"||token.name==="cslstyle"){this.opt.inheritedAttributes[name]=value;this.citation.opt.inheritedAttributes[name]=value;this.bibliography.opt.inheritedAttributes[name]=value;}else if(["citation","bibliography"].indexOf(token.name)>-1){this[token.name].opt.inheritedAttributes[name]=value;}else{token.strings[name]=value;}};// Executed at runtime, since macros can occur in the context of citation or bibliography
CSL.Engine.prototype.inheritOpt=function(token,attrname,parentname,defaultValue){if("undefined"!==typeof token.strings[attrname]){return token.strings[attrname];}else{var parentValue=this[this.tmp.root].opt.inheritedAttributes[parentname?parentname:attrname];if("undefined"!==typeof parentValue){return parentValue;}else{return defaultValue;}}};CSL.Engine.prototype.remapSectionVariable=function(inputList){// We have items with a value in the section field (on Item) that must
// be mapped to the locator field (on item). We simply prepend it as
// a string here, and handle all parsing of the resulting string
// in processNumber(). Plurals and numeric are set in processNumber().
// Because the target is in the citation item (lowercase), the
// remapping cannot take place when the Item data is received.
// Citation provides a list of Item/item pairs, hence the iteration
// used here.
for(var i=0,ilen=inputList.length;i<ilen;i+=1){var Item=inputList[i][0];var item=inputList[i][1];if(["bill","gazette","legislation","regulation","treaty"].indexOf(Item.type)>-1){// If a locator value exists, then
//   (a) Leave be an overriding label at the start of the locator field, defaulting to label value
if(item.locator){item.locator=item.locator.trim();var m=item.locator.match(CSL.STATUTE_SUBDIV_PLAIN_REGEX_FRONT);if(!m){if(item.label){item.locator=CSL.STATUTE_SUBDIV_STRINGS_REVERSE[item.label]+" "+item.locator;}else{item.locator="p. "+item.locator;}}}// If a section value exists, then
//   (a) Apply an overriding label at the start of the section field, defaulting to sec.
var sectionMasterLabel=null;if(Item.section){Item.section=Item.section.trim();var m=Item.section.match(CSL.STATUTE_SUBDIV_PLAIN_REGEX_FRONT);if(!m){Item.section="sec. "+Item.section;sectionMasterLabel="sec.";}else{sectionMasterLabel=m[0].trim();}}// If section is nil, then
//   (a) Do nothing
if(Item.section){// If section exists and locator is nil
//   (a) Set section string in locator field
if(!item.locator){item.locator=Item.section;}else{// If both section and locator exist, then
//   (a) If locator starts with p., remove p., merge with space or no-space, and set in locator field
//   (b) If locator starts with non-p., prepend section value to locator with space, and set in locator field
var m=item.locator.match(/^([^ ]*)\s*(.*)/);var space=" ";if(m){if(m[1]==="p."&&sectionMasterLabel!=="p."){item.locator=m[2];}if(["[","(",".",",",";",":","?"].indexOf(item.locator.slice(0,1))>-1){space="";}}else{space="";}item.locator=Item.section+space+item.locator;}//Item.section = "";
}item.label="";// And that's it. Pre-parse complete.
}}};CSL.Engine.prototype.setNumberLabels=function(Item){if(Item.number&&["bill","gazette","legislation","regulation","treaty"].indexOf(Item.type)>-1&&this.opt.development_extensions.consolidate_legal_items&&!this.tmp.shadow_numbers["number"]){this.tmp.shadow_numbers["number"]={};this.tmp.shadow_numbers["number"].values=[];this.tmp.shadow_numbers["number"].plural=0;this.tmp.shadow_numbers["number"].numeric=false;this.tmp.shadow_numbers["number"].label=false;// Labels embedded in number variable
var value=""+Item.number;value=value.split("\\").join("");// Get first word, parse out labels only if it parses
var firstword=value.split(/\s+/)[0];var firstlabel=CSL.STATUTE_SUBDIV_STRINGS[firstword];if(firstlabel){// Get list and match
var splt=value.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);if(splt.length>1){// Convert matches to localized form
var lst=[];for(var j=1,jlen=splt.length;j<jlen;j+=1){lst.push(splt[j].replace(/\s*$/,"").replace(/^\s*/,""));}// Preemptively save to shadow_numbers
value=lst.join(" ");}else{value=splt[0];}this.tmp.shadow_numbers["number"].label=firstlabel;this.tmp.shadow_numbers["number"].values.push(["Blob",value,false]);this.tmp.shadow_numbers["number"].numeric=false;}else{this.tmp.shadow_numbers["number"].values.push(["Blob",value,false]);this.tmp.shadow_numbers["number"].numeric=true;}}};/*global CSL: true */CSL.substituteOne=function(template){return function(state,list){if(!list){return"";}else{// ("string" === typeof list)
return template.replace("%%STRING%%",list);}};};/**
 * Two-tiered substitutions gadget.
 * <p>This is used for
 * options like (now defunct) "font-family", where the option value
 * cannot be determined until the attribute is processed.
 * Need for this function might be reviewed at some point ...</p>
 * @param {String} template A template containing
 * <code>%%STRING%%</code> and <code>%%PARAM%%</code>
 * placeholders.  See {@link CSL.Output.Formats.html} for
 * examples.
 */CSL.substituteTwo=function(template){return function(param){var template2=template.replace("%%PARAM%%",param);return function(state,list){if(!list){return"";}else{//("string" === typeof list){
return template2.replace("%%STRING%%",list);}};};};/**
 * Generate string functions for designated output mode.
 * <p>Only "html" (the default) is supported at present.</p>
 * @param {String} mode Either "html" or "rtf", eventually.
 */CSL.Mode=function(mode){var decorations,params,param,func,val,args;decorations={};params=CSL.Output.Formats[mode];for(param in params){if(true){if("@"!==param.slice(0,1)){decorations[param]=params[param];continue;}func=false;val=params[param];args=param.split('/');if(typeof val==="string"&&val.indexOf("%%STRING%%")>-1){if(val.indexOf("%%PARAM%%")>-1){func=CSL.substituteTwo(val);}else{func=CSL.substituteOne(val);}}else if(typeof val==="boolean"&&!val){func=CSL.Output.Formatters.passthrough;}else if(typeof val==="function"){func=val;}else{CSL.error("Bad "+mode+" config entry for "+param+": "+val);}if(args.length===1){decorations[args[0]]=func;}else if(args.length===2){if(!decorations[args[0]]){decorations[args[0]]={};}decorations[args[0]][args[1]]=func;}}}return decorations;};/**
 * Generate a separate list of formatting attributes.
 * <p>This generates a list of tuples containing attribute
 * information relevant to output formatting, in the order
 * fixed in the constant {@link CSL.FORMAT_KEY_SEQUENCE}.
 * This function is called during {@link CSL.Core.Build}.
 * Formatting hints are distilled to functions
 * later, in the second compilation pass ({@link CSL.Core.Configure}).</p>
 * @param {Object} state The state object returned by
 * {@link CSL.Engine}.
 * @param {Object} attributes The hash object containing
 * the attributes and values extracted from an XML node.
 */CSL.setDecorations=function(state,attributes){var ret,key,pos;// This applies a fixed processing sequence
ret=[];for(pos in CSL.FORMAT_KEY_SEQUENCE){if(true){var key=CSL.FORMAT_KEY_SEQUENCE[pos];if(attributes[key]){ret.push([key,attributes[key]]);delete attributes[key];}}}return ret;};CSL.Doppeler=function(rexStr,stringMangler){var matchRex=new RegExp("("+rexStr+")","g");var splitRex=new RegExp(rexStr,"g");this.split=function(str){// Normalize markup
if(stringMangler){str=stringMangler(str);}var match=str.match(matchRex);if(!match){return{tags:[],strings:[str]};}var split=str.split(splitRex);for(var i=match.length-1;i>-1;i--){if(typeof match[i]==="number"){match[i]="";}var tag=match[i];if(tag==="\'"&&split[i+1].length>0){// Fixes https://forums.zotero.org/discussion/comment/294317
split[i+1]=match[i]+split[i+1];match[i]="";}}return{tags:match,strings:split,origStrings:split.slice()};};this.join=function(obj){var lst=obj.strings.slice(-1);for(var i=obj.tags.length-1;i>-1;i--){lst.push(obj.tags[i]);lst.push(obj.strings[i]);}lst.reverse();return lst.join("");};};CSL.Engine.prototype.normalDecorIsOrphan=function(blob,params){//print("params: "+JSON.stringify(params));
if(params[1]==="normal"){var use_param=false;var all_the_decor;if(this.tmp.area==="citation"){all_the_decor=[this.citation.opt.layout_decorations].concat(blob.alldecor);}else{all_the_decor=blob.alldecor;}for(var k=all_the_decor.length-1;k>-1;k+=-1){//print("  all decor: "+JSON.stringify(all_the_decor[k]));
for(var n=all_the_decor[k].length-1;n>-1;n+=-1){//print("  superior param"+n+": "+all_the_decor[k][n][0]);
if(all_the_decor[k][n][0]===params[0]){//print("  HIT!");
if(all_the_decor[k][n][1]!=="normal"){use_param=true;}}}}if(!use_param){return true;}}return false;};/*global CSL: true */CSL.Engine.prototype.getCitationLabel=function(Item){var label="";var params=this.getTrigraphParams();var config=params[0];var myname=this.getTerm("reference","short",0);if("undefined"===typeof myname){myname="reference";}myname=myname.replace(".","");myname=myname.slice(0,1).toUpperCase()+myname.slice(1);for(var i=0,ilen=CSL.NAME_VARIABLES.length;i<ilen;i+=1){var n=CSL.NAME_VARIABLES[i];if(Item[n]){var names=Item[n];if(names.length>params.length){config=params[params.length-1];}else{config=params[names.length-1];}for(var j=0,jlen=names.length;j<jlen;j+=1){if(j===config.authors.length){break;}var res=this.nameOutput.getName(names[j],"locale-translit",true);var name=res.name;if(name&&name.family){myname=name.family;myname=myname.replace(/^([ \'\u2019a-z]+\s+)/,"");}else if(name&&name.literal){myname=name.literal;}var m=myname.toLowerCase().match(/^(a\s+|the\s+|an\s+)/);if(m){myname=myname.slice(m[1].length);}myname=myname.replace(CSL.ROMANESQUE_NOT_REGEXP,"");if(!myname){break;}myname=myname.slice(0,config.authors[j]);if(myname.length>1){myname=myname.slice(0,1).toUpperCase()+myname.slice(1).toLowerCase();}else if(myname.length===1){myname=myname.toUpperCase();}label+=myname;}break;}}if(!label){// Try for something using title
if(Item.title){var skipWords=this.locale[this.opt.lang].opts["skip-words"];var lst=Item.title.split(/\s+/);for(var i=lst.length-1;i>-1;i--){if(skipWords.indexOf(lst[i])>-1){lst=lst.slice(0,i).concat(lst.slice(i+1));}}var str=lst.join('');str=str.slice(0,params[0].authors[0]);if(str.length>1){str=str.slice(0,1).toUpperCase()+str.slice(1).toLowerCase();}else if(str.length===1){str=str.toUpperCase();}label=str;}}var year="0000";if(Item.issued){if(Item.issued.year){year=""+Item.issued.year;}}year=year.slice(config.year*-1);label=label+year;return label;};CSL.Engine.prototype.getTrigraphParams=function(){var params=[];var ilst=this.opt.trigraph.split(":");if(!this.opt.trigraph||this.opt.trigraph.slice(0,1)!=="A"){CSL.error("Bad trigraph definition: "+this.opt.trigraph);}for(var i=0,ilen=ilst.length;i<ilen;i+=1){var str=ilst[i];var config={authors:[],year:0};for(var j=0,jlen=str.length;j<jlen;j+=1){switch(str.slice(j,j+1)){case"A":config.authors.push(1);break;case"a":config.authors[config.authors.length-1]+=1;break;case"0":config.year+=1;break;default:CSL.error("Invalid character in trigraph definition: "+this.opt.trigraph);}}params.push(config);}return params;};/*global CSL: true */CSL.Engine.prototype.setOutputFormat=function(mode){this.opt.mode=mode;this.fun.decorate=CSL.Mode(mode);if(!this.output[mode]){this.output[mode]={};this.output[mode].tmp={};}};CSL.Engine.prototype.getSortFunc=function(){return function(a,b){a=a.split("-");b=b.split("-");if(a.length<b.length){return 1;}else if(a.length>b.length){return-1;}else{a=a.slice(-1)[0];b=b.slice(-1)[0];if(a.length<b.length){return 1;}else if(a.length>b.length){return-1;}else{return 0;}}};};CSL.Engine.prototype.setLangTagsForCslSort=function(tags){var i,ilen;if(tags){this.opt['locale-sort']=[];for(i=0,ilen=tags.length;i<ilen;i+=1){this.opt['locale-sort'].push(tags[i]);}}this.opt['locale-sort'].sort(this.getSortFunc());};CSL.Engine.prototype.setLangTagsForCslTransliteration=function(tags){var i,ilen;this.opt['locale-translit']=[];if(tags){for(i=0,ilen=tags.length;i<ilen;i+=1){this.opt['locale-translit'].push(tags[i]);}}this.opt['locale-translit'].sort(this.getSortFunc());};CSL.Engine.prototype.setLangTagsForCslTranslation=function(tags){var i,ilen;this.opt['locale-translat']=[];if(tags){for(i=0,ilen=tags.length;i<ilen;i+=1){this.opt['locale-translat'].push(tags[i]);}}this.opt['locale-translat'].sort(this.getSortFunc());};CSL.Engine.prototype.setLangPrefsForCites=function(obj,conv){var opt=this.opt['cite-lang-prefs'];if(!conv){conv=function(key){return key.toLowerCase();};}var segments=['Persons','Institutions','Titles','Journals','Publishers','Places'];// Set values in place
for(var i=0,ilen=segments.length;i<ilen;i+=1){var clientSegment=conv(segments[i]);var citeprocSegment=segments[i].toLowerCase();if(!obj[clientSegment]){continue;}//
// Normalize the sequence of secondary and tertiary
// in the provided obj segment list.
//
var supplements=[];while(obj[clientSegment].length>1){supplements.push(obj[clientSegment].pop());}var sortval={orig:1,translit:2,translat:3};if(supplements.length===2&&sortval[supplements[0]]<sortval[supplements[1]]){supplements.reverse();}while(supplements.length){obj[clientSegment].push(supplements.pop());}//
// normalization done.
//
var lst=opt[citeprocSegment];while(lst.length){lst.pop();}for(var j=0,jlen=obj[clientSegment].length;j<jlen;j+=1){lst.push(obj[clientSegment][j]);}}};CSL.Engine.prototype.setLangPrefsForCiteAffixes=function(affixList){if(affixList&&affixList.length===48){var affixes=this.opt.citeAffixes;var count=0;var settings=["persons","institutions","titles","journals","publishers","places"];var forms=["translit","orig","translit","translat"];var value;for(var i=0,ilen=settings.length;i<ilen;i+=1){for(var j=0,jlen=forms.length;j<jlen;j+=1){value="";if(count%8===4){if(!affixes[settings[i]]["locale-"+forms[j]].prefix&&!affixes[settings[i]]["locale-"+forms[j]].suffix){value=affixList[count]?affixList[count]:"";affixes[settings[i]]["locale-"+forms[j]].prefix=value;value=affixList[count]?affixList[count+1]:"";affixes[settings[i]]["locale-"+forms[j]].suffix=value;}}else{value=affixList[count]?affixList[count]:"";affixes[settings[i]]["locale-"+forms[j]].prefix=value;value=affixList[count]?affixList[count+1]:"";affixes[settings[i]]["locale-"+forms[j]].suffix=value;}count+=2;}}this.opt.citeAffixes=affixes;}};CSL.Engine.prototype.setAutoVietnameseNamesOption=function(arg){if(arg){this.opt["auto-vietnamese-names"]=true;}else{this.opt["auto-vietnamese-names"]=false;}};CSL.Engine.prototype.setAbbreviations=function(arg){if(this.sys.setAbbreviations){this.sys.setAbbreviations(arg);}};CSL.Engine.prototype.setSuppressTrailingPunctuation=function(arg){this.citation.opt.suppressTrailingPunctuation=!!arg;};/*global CSL: true */CSL.Output={};/**
 * Output queue object.
 * @class
 */CSL.Output.Queue=function(state){this.levelname=["top"];this.state=state;this.queue=[];this.empty=new CSL.Token("empty");var tokenstore={};tokenstore.empty=this.empty;this.formats=new CSL.Stack(tokenstore);this.current=new CSL.Stack(this.queue);};// XXX This works, but causes a mismatch in api_cite
// Could insert a placeholder
// Better to have a function that spits out an independent blob.
// Is that possible though?
// Okay. Use queue.append() with fake_queue instead.
CSL.Output.Queue.prototype.pop=function(){// For some reason, state.output.current.value() here can be an array, 
// not a blob ... ?
var drip=this.current.value();if(drip.length){return drip.pop();}else{return drip.blobs.pop();}};CSL.Output.Queue.prototype.getToken=function(name){var ret=this.formats.value()[name];return ret;};CSL.Output.Queue.prototype.mergeTokenStrings=function(base,modifier){var base_token,modifier_token,ret,key;base_token=this.formats.value()[base];modifier_token=this.formats.value()[modifier];ret=base_token;if(modifier_token){if(!base_token){base_token=new CSL.Token(base,CSL.SINGLETON);base_token.decorations=[];}ret=new CSL.Token(base,CSL.SINGLETON);var key="";for(var key in base_token.strings){if(base_token.strings.hasOwnProperty(key)){ret.strings[key]=base_token.strings[key];}}for(var key in modifier_token.strings){if(modifier_token.strings.hasOwnProperty(key)){ret.strings[key]=modifier_token.strings[key];}}ret.decorations=base_token.decorations.concat(modifier_token.decorations);}return ret;};// Store a new output format token based on another
CSL.Output.Queue.prototype.addToken=function(name,modifier,token){var newtok,attr;newtok=new CSL.Token("output");if("string"===typeof token){token=this.formats.value()[token];}if(token&&token.strings){for(attr in token.strings){if(token.strings.hasOwnProperty(attr)){newtok.strings[attr]=token.strings[attr];}}newtok.decorations=token.decorations;}if("string"===typeof modifier){newtok.strings.delimiter=modifier;}this.formats.value()[name]=newtok;};//
// newFormat adds a new bundle of formatting tokens to
// the queue's internal stack of such bundles
CSL.Output.Queue.prototype.pushFormats=function(tokenstore){if(!tokenstore){tokenstore={};}tokenstore.empty=this.empty;this.formats.push(tokenstore);};CSL.Output.Queue.prototype.popFormats=function(){this.formats.pop();};CSL.Output.Queue.prototype.startTag=function(name,token){var tokenstore={};if(this.state.tmp["doing-macro-with-date"]&&this.state.tmp.extension){token=this.empty;name="empty";}tokenstore[name]=token;this.pushFormats(tokenstore);this.openLevel(name);};CSL.Output.Queue.prototype.endTag=function(name){this.closeLevel(name);this.popFormats();};//
// newlevel adds a new blob object to the end of the current
// list, and adjusts the current pointer so that subsequent
// appends are made to blob list of the new object.
CSL.Output.Queue.prototype.openLevel=function(token){var blob,curr;if("object"===typeof token){// delimiter, prefix, suffix, decorations from token
blob=new CSL.Blob(undefined,token);}else if("undefined"===typeof token){blob=new CSL.Blob(undefined,this.formats.value().empty,"empty");}else{if(!this.formats.value()||!this.formats.value()[token]){CSL.error("CSL processor error: call to nonexistent format token \""+token+"\"");}// delimiter, prefix, suffix, decorations from token
blob=new CSL.Blob(undefined,this.formats.value()[token],token);}curr=this.current.value();if(!this.state.tmp.just_looking&&this.checkNestedBrace){blob.strings.prefix=this.checkNestedBrace.update(blob.strings.prefix);}curr.push(blob);this.current.push(blob);};/**
 * "merge" used to be real complicated, now it's real simple.
 */CSL.Output.Queue.prototype.closeLevel=function(name){// CLEANUP: Okay, so this.current.value() holds the blob at the
// end of the current list.  This is wrong.  It should
// be the parent, so that we have  the choice of reading
// the affixes and decorations, or appending to its
// content.  The code that manipulates blobs will be
// much simpler that way.
if(name&&name!==this.current.value().levelname){CSL.error("Level mismatch error:  wanted "+name+" but found "+this.current.value().levelname);}var blob=this.current.pop();if(!this.state.tmp.just_looking&&this.checkNestedBrace){blob.strings.suffix=this.checkNestedBrace.update(blob.strings.suffix);}};//
// append does the same thing as newlevel, except
// that the blob it pushes has text content,
// and the current pointer is not moved after the push.
CSL.Output.Queue.prototype.append=function(str,tokname,notSerious,ignorePredecessor,noStripPeriods){var token,blob,curr;var useblob=true;if(notSerious){ignorePredecessor=true;}// XXXXX Nasty workaround, but still an improvement
// over the reverse calls to the cs:date node build
// function that we had before.
if(this.state.tmp["doing-macro-with-date"]&&!notSerious){if(tokname!=="macro-with-date"){return false;}if(tokname==="macro-with-date"){tokname="empty";}}if("undefined"===typeof str){return false;}if("number"===typeof str){str=""+str;}if(!notSerious&&this.state.tmp.element_trace&&this.state.tmp.element_trace.value()==="suppress-me"){return false;}blob=false;if(!tokname){token=this.formats.value().empty;}else if(tokname==="literal"){token=true;useblob=false;}else if("string"===typeof tokname){token=this.formats.value()[tokname];}else{token=tokname;}if(!token){CSL.error("CSL processor error: unknown format token name: "+tokname);}// Unset delimiters must be left undefined until they reach the queue
// in order to discriminate unset from explicitly empty delimiters
// when inheriting a default value from a superior node. [??? really ???]
if(token.strings&&"undefined"===typeof token.strings.delimiter){token.strings.delimiter="";}if("string"===typeof str&&str.length){// Source (;?!»«): http://en.wikipedia.org/wiki/Space_(punctuation)#Breaking_and_non-breaking_spaces
// Source (:): http://forums.zotero.org/discussion/4933/localized-quotes/#Comment_88384
str=str.replace(/ ([:;?!\u00bb])/g,"\u202f$1").replace(/\u00ab /g,"\u00ab\u202f");this.last_char_rendered=str.slice(-1);// This, and not the str argument below on flipflop, is the
// source of the flipflopper string source.
str=str.replace(/\s+'/g," \'");if(!notSerious){// this condition for sort_LeadingApostropheOnNameParticle
str=str.replace(/^'/g," \'");}// signal whether we end with terminal punctuation?
if(!ignorePredecessor){this.state.tmp.term_predecessor=true;this.state.tmp.in_cite_predecessor=true;}else if(notSerious){this.state.tmp.term_predecessor_name=true;}}blob=new CSL.Blob(str,token);curr=this.current.value();if("undefined"===typeof curr&&this.current.mystack.length===0){// XXXX An operation like this is missing somewhere, this should NOT be necessary.
// Addresses error triggered in multi-layouts.
this.current.mystack.push([]);curr=this.current.value();}if("string"===typeof blob.blobs){if(!ignorePredecessor){this.state.tmp.term_predecessor=true;this.state.tmp.in_cite_predecessor=true;}else if(notSerious){this.state.tmp.term_predecessor_name=true;}}//
// Caution: The parallel detection machinery will blow up if tracking
// variables are not properly initialized elsewhere.
//
if("string"===typeof str){if("string"===typeof blob.blobs){if(blob.blobs.slice(0,1)!==" "){var blobPrefix="";var blobBlobs=blob.blobs;while(CSL.TERMINAL_PUNCTUATION.indexOf(blobBlobs.slice(0,1))>-1){blobPrefix=blobPrefix+blobBlobs.slice(0,1);blobBlobs=blobBlobs.slice(1);}if(blobBlobs&&blobPrefix){blob.strings.prefix=blob.strings.prefix+blobPrefix;blob.blobs=blobBlobs;}}}if(blob.strings["text-case"]){//
// This one is _particularly_ hard to follow.  It's not obvious,
// but the blob already contains the input string at this
// point, as blob.blobs -- it's a terminal node, as it were.
// The str variable also contains the input string, but
// that copy is not used for onward processing.  We have to
// apply our changes to the blob copy.
//
blob.blobs=CSL.Output.Formatters[blob.strings["text-case"]](this.state,str);}if(this.state.tmp.strip_periods&&!noStripPeriods){blob.blobs=blob.blobs.replace(/\.([^a-z]|$)/g,"$1");}for(var i=blob.decorations.length-1;i>-1;i+=-1){if(blob.decorations[i][0]==="@quotes"&&blob.decorations[i][1]!=="false"){blob.punctuation_in_quote=this.state.getOpt("punctuation-in-quote");}if(!blob.blobs.match(CSL.ROMANESQUE_REGEXP)){if(blob.decorations[i][0]==="@font-style"){blob.decorations=blob.decorations.slice(0,i).concat(blob.decorations.slice(i+1));}}}//
// XXX: Beware superfluous code in your code.  str in this
// case is not the source of the final rendered string.
// See note above.
//
curr.push(blob);this.state.fun.flipflopper.processTags(blob);}else if(useblob){curr.push(blob);}else{curr.push(str);}return true;};CSL.Output.Queue.prototype.string=function(state,myblobs,blob){var i,ilen,j,jlen,b;//if (blob && blob.strings.delimiter) {
//    print("DELIMITER: "+blob.strings.delimiter+" on "+[x.blobs[0].num for each (x in myblobs)]);
//}
//var blobs, ret, blob_delimiter, i, params, blobjr, last_str, last_char, b, use_suffix, qres, addtoret, span_split, j, res, blobs_start, blobs_end, key, pos, len, ppos, llen, ttype, ltype, terminal, leading, delimiters, use_prefix, txt_esc;
var txt_esc=CSL.getSafeEscape(this.state);var blobs=myblobs.slice();var ret=[];if(blobs.length===0){return ret;}var blob_delimiter="";if(blob){blob_delimiter=blob.strings.delimiter;}else{//print("=== Setting false to start ===");
state.tmp.count_offset_characters=false;state.tmp.offset_characters=0;}if(blob&&blob.new_locale){blob.old_locale=state.opt.lang;state.opt.lang=blob.new_locale;}var blobjr,use_suffix,use_prefix,params;for(var i=0,ilen=blobs.length;i<ilen;i+=1){blobjr=blobs[i];if(blobjr.strings.first_blob){// Being the Item.id of the the entry being rendered.
//print("  -- turning on counting");
state.tmp.count_offset_characters=blobjr.strings.first_blob;}if("string"===typeof blobjr.blobs){if("number"===typeof blobjr.num){ret.push(blobjr);}else if(blobjr.blobs){if(blobjr.particle){blobjr.blobs=blobjr.particle+blobjr.blobs;blobjr.particle="";}// (skips empty strings)
//b = txt_esc(blobjr.blobs);
b=txt_esc(blobjr.blobs);var blen=b.length;if(!state.tmp.suppress_decorations){for(j=0,jlen=blobjr.decorations.length;j<jlen;j+=1){params=blobjr.decorations[j];if(params[0]==="@showid"){continue;}if(state.normalDecorIsOrphan(blobjr,params)){continue;}b=state.fun.decorate[params[0]][params[1]].call(blobjr,state,b,params[2]);}}//
// because we will rip out portions of the output
// queue before rendering, group wrappers need
// to produce no output if they are found to be
// empty.
if(b&&b.length){b=txt_esc(blobjr.strings.prefix)+b+txt_esc(blobjr.strings.suffix);if(state.opt.development_extensions.csl_reverse_lookup_support&&!state.tmp.suppress_decorations){for(j=0,jlen=blobjr.decorations.length;j<jlen;j+=1){params=blobjr.decorations[j];if(params[0]==="@showid"){b=state.fun.decorate[params[0]][params[1]].call(blobjr,state,b,params[2]);}}}ret.push(b);if(state.tmp.count_offset_characters){state.tmp.offset_characters+=blen+blobjr.strings.suffix.length+blobjr.strings.prefix.length;}}}}else if(blobjr.blobs.length){var addtoret=state.output.string(state,blobjr.blobs,blobjr);if(blob){// Patch up world-class weird bug in the ill-constructed code of mine.
if("string"!==addtoret&&addtoret.length>1&&blobjr.strings.delimiter){var numberSeen=false;for(var j=0,jlen=addtoret.length;j<jlen;j++){if("string"!==typeof addtoret[j]){numberSeen=true;}else if(numberSeen){addtoret[j]=blobjr.strings.delimiter+addtoret[j];}}}}ret=ret.concat(addtoret);}if(blobjr.strings.first_blob&&state.registry.registry[blobjr.strings.first_blob]){// The Item.id of the entry being rendered.
state.registry.registry[blobjr.strings.first_blob].offset=state.tmp.offset_characters;state.tmp.count_offset_characters=false;}}// Provide delimiters on adjacent numeric blobs
for(i=0,ilen=ret.length-1;i<ilen;i+=1){if("number"===typeof ret[i].num&&"number"===typeof ret[i+1].num&&!ret[i+1].UGLY_DELIMITER_SUPPRESS_HACK){// XXX watch this
ret[i].strings.suffix=ret[i].strings.suffix+(blob_delimiter?blob_delimiter:"");ret[i+1].successor_prefix="";ret[i+1].UGLY_DELIMITER_SUPPRESS_HACK=true;}}var span_split=0;for(var i=0,ilen=ret.length;i<ilen;i+=1){if("string"===typeof ret[i]){span_split=parseInt(i,10)+1;if(i<ret.length-1&&"object"===typeof ret[i+1]){if(blob_delimiter&&!ret[i+1].UGLY_DELIMITER_SUPPRESS_HACK){ret[i]+=txt_esc(blob_delimiter);}// One bite of the apple
ret[i+1].UGLY_DELIMITER_SUPPRESS_HACK=true;}//span_split = ret.length;
//print("XXX ret: "+ret+" -- "+blob_delimiter);
}}/*
    if (blob && (blob.decorations.length || blob.strings.suffix || blob.strings.prefix)) {
        span_split = ret.length;
    }
*/if(blob&&(blob.decorations.length||blob.strings.suffix)){span_split=ret.length;}else if(blob&&blob.strings.prefix){for(var i=0,ilen=ret.length;i<ilen;i++){if("undefined"!==typeof ret[i].num){span_split=i;if(i===0){ret[i].strings.prefix=blob.strings.prefix+ret[i].strings.prefix;}break;}}}var blobs_start=state.output.renderBlobs(ret.slice(0,span_split),blob_delimiter,false,blob);if(blobs_start&&blob&&(blob.decorations.length||blob.strings.suffix||blob.strings.prefix)){if(!state.tmp.suppress_decorations){for(var i=0,ilen=blob.decorations.length;i<ilen;i+=1){params=blob.decorations[i];if(["@cite","@bibliography","@display","@showid"].indexOf(params[0])>-1){continue;}if(state.normalDecorIsOrphan(blobjr,params)){continue;}if(!params[0])continue;if("string"===typeof blobs_start){blobs_start=state.fun.decorate[params[0]][params[1]].call(blob,state,blobs_start,params[2]);}}}//
// XXXX: cut-and-paste warning.  same as a code block above.
//
b=blobs_start;use_suffix=blob.strings.suffix;if(b&&b.length){use_prefix=blob.strings.prefix;b=txt_esc(use_prefix)+b+txt_esc(use_suffix);if(state.tmp.count_offset_characters){state.tmp.offset_characters+=use_prefix.length+use_suffix.length;}}blobs_start=b;if(!state.tmp.suppress_decorations){for(var i=0,ilen=blob.decorations.length;i<ilen;i+=1){params=blob.decorations[i];if(["@cite","@bibliography","@display","@showid"].indexOf(params[0])===-1){continue;}if("string"===typeof blobs_start){blobs_start=state.fun.decorate[params[0]][params[1]].call(blob,state,blobs_start,params[2]);}}}}var blobs_end=ret.slice(span_split,ret.length);if(!blobs_end.length&&blobs_start){ret=[blobs_start];}else if(blobs_end.length&&!blobs_start){ret=blobs_end;}else if(blobs_start&&blobs_end.length){ret=[blobs_start].concat(blobs_end);}//
// Blobs is now definitely a string with
// trailing blobs.  Return it.
if("undefined"===typeof blob){this.queue=[];this.current.mystack=[];this.current.mystack.push(this.queue);if(state.tmp.suppress_decorations){ret=state.output.renderBlobs(ret,undefined,false);}}else if("boolean"===typeof blob){ret=state.output.renderBlobs(ret,undefined,true);}if(blob&&blob.new_locale){state.opt.lang=blob.old_locale;}//if (!blob && !state.tmp.just_looking) {
//  print("QUEUE ("+ state.tmp.just_looking +"): "+JSON.stringify(state.output.queue, ["num", "strings", "decorations", "blobs", "prefix", "suffix", "delimiter"], 2));
//}
return ret;};CSL.Output.Queue.prototype.clearlevel=function(){var blob,pos,len;blob=this.current.value();len=blob.blobs.length;for(pos=0;pos<len;pos+=1){blob.blobs.pop();}};CSL.Output.Queue.prototype.renderBlobs=function(blobs,delim,in_cite,parent){var state,ret,ret_last_char,use_delim,blob,pos,len,ppos,llen,str,params,txt_esc;txt_esc=CSL.getSafeEscape(this.state);if(!delim){delim="";}state=this.state;ret="";ret_last_char=[];use_delim="";len=blobs.length;if(this.state.tmp.area==="citation"&&!this.state.tmp.just_looking&&len===1&&typeof blobs[0]==="object"&&parent){blobs[0].strings.prefix=parent.strings.prefix+blobs[0].strings.prefix;blobs[0].strings.suffix=blobs[0].strings.suffix+parent.strings.suffix;blobs[0].decorations=blobs[0].decorations.concat(parent.decorations);blobs[0].params=parent.params;return blobs[0];}var start=true;for(pos=0;pos<len;pos+=1){if(blobs[pos].checkNext){blobs[pos].checkNext(blobs[pos+1],start);start=false;}else if(blobs[pos+1]&&blobs[pos+1].splice_prefix){start=false;//blobs[pos+1].checkNext(blobs[pos + 1],start);
}else{start=true;}}// print("LEN="+len+" "+JSON.stringify(blobs, null, 2));
// Fix last non-range join
var doit=true;for(pos=blobs.length-1;pos>0;pos+=-1){if(blobs[pos].checkLast){if(doit&&blobs[pos].checkLast(blobs[pos-1])){doit=false;}}else{doit=true;}}len=blobs.length;for(pos=0;pos<len;pos+=1){blob=blobs[pos];if(ret){use_delim=delim;}if("string"===typeof blob){ret+=txt_esc(use_delim);// XXX Blob should be run through flipflop and flattened here.
// (I think it must be a fragment of text around a numeric
// variable)
ret+=blob;if(state.tmp.count_offset_characters){//state.tmp.offset_characters += (use_delim.length + blob.length);
state.tmp.offset_characters+=use_delim.length;}}else if(in_cite){// pass
// Okay, so this does it -- but we're now not able to return a string!
if(ret){ret=[ret,blob];}else{ret=[blob];}}else if(blob.status!==CSL.SUPPRESS){if(blob.particle){str=blob.particle+blob.num;}else{str=blob.formatter.format(blob.num,blob.gender);}// Workaround to get a more or less accurate value.
var strlen=str.replace(/<[^>]*>/g,"").length;// notSerious
this.append(str,"empty",true);var str_blob=this.pop();var count_offset_characters=state.tmp.count_offset_characters;str=this.string(state,[str_blob],false);state.tmp.count_offset_characters=count_offset_characters;if(blob.strings["text-case"]){str=CSL.Output.Formatters[blob.strings["text-case"]](this.state,str);}if(str&&this.state.tmp.strip_periods){str=str.replace(/\.([^a-z]|$)/g,"$1");}if(!state.tmp.suppress_decorations){llen=blob.decorations.length;for(ppos=0;ppos<llen;ppos+=1){params=blob.decorations[ppos];if(state.normalDecorIsOrphan(blob,params)){continue;}str=state.fun.decorate[params[0]][params[1]].call(blob,state,str,params[2]);}}str=txt_esc(blob.strings.prefix)+str+txt_esc(blob.strings.suffix);var addme="";if(blob.status===CSL.END){//print("  CSL.END");
addme=txt_esc(blob.range_prefix);}else if(blob.status===CSL.SUCCESSOR){//print("  CSL.SUCCESSOR");
addme=txt_esc(blob.successor_prefix);}else if(blob.status===CSL.START){//print("  CSL.START");
if(pos>0&&!blob.suppress_splice_prefix){addme=txt_esc(blob.splice_prefix);}else{addme="";}}else if(blob.status===CSL.SEEN){//print("  CSL.SEEN");
// THIS IS NOT THE PROPER FUNCTION OF CSL.SEEN, IS IT?
addme=txt_esc(blob.splice_prefix);}ret+=addme;ret+=str;if(state.tmp.count_offset_characters){state.tmp.offset_characters+=addme.length+blob.strings.prefix.length+strlen+blob.strings.suffix.length;}}}return ret;};CSL.Output.Queue.purgeEmptyBlobs=function(parent){//print("START1");
if("object"!==typeof parent||"object"!==typeof parent.blobs||!parent.blobs.length){return;}// back-to-front, bottom-first
for(var i=parent.blobs.length-1;i>-1;i--){CSL.Output.Queue.purgeEmptyBlobs(parent.blobs[i]);var child=parent.blobs[i];if(!child||!child.blobs||!child.blobs.length){var buf=[];while(parent.blobs.length-1>i){buf.push(parent.blobs.pop());}parent.blobs.pop();while(buf.length){parent.blobs.push(buf.pop());}}}//print("   end");
};// Adjustments to be made:
//
// * Never migrate beyond a @quotes node
// * Never migrate into a num node.
CSL.Output.Queue.adjust=function(punctInQuote){var NO_SWAP_IN={";":true,":":true};var NO_SWAP_OUT={".":true,"!":true,"?":true};var LtoR_MAP={"!":{".":"!","?":"!?",":":"!",",":"!,",";":"!;"},"?":{"!":"?!",".":"?",":":"?",",":"?,",";":"?;"},".":{"!":".!","?":".?",":":".:",",":".,",";":".;"},":":{"!":"!","?":"?",".":":",",":":,",";":":;"},",":{"!":",!","?":",?",":":",:",".":",.",";":",;"},";":{"!":"!","?":"?",":":";",",":";,",".":";"}};var SWAP_IN={};var SWAP_OUT={};var PUNCT={};var PUNCT_OR_SPACE={};for(var key in LtoR_MAP){PUNCT[key]=true;PUNCT_OR_SPACE[key]=true;if(!NO_SWAP_IN[key]){SWAP_IN[key]=true;}if(!NO_SWAP_OUT[key]){SWAP_OUT[key]=true;}}PUNCT_OR_SPACE[" "]=true;PUNCT_OR_SPACE[" "]=true;var RtoL_MAP={};for(var key in LtoR_MAP){for(var subkey in LtoR_MAP[key]){if(!RtoL_MAP[subkey]){RtoL_MAP[subkey]={};}RtoL_MAP[subkey][key]=LtoR_MAP[key][subkey];}}function blobIsNumber(blob){return"number"===typeof blob.num||blob.blobs&&blob.blobs.length===1&&"number"===typeof blob.blobs[0].num;}function blobEndsInNumber(blob){if("number"===typeof blob.num){return true;}if(!blob.blobs||"object"!==typeof blob.blobs){return false;}if(blobEndsInNumber(blob.blobs[blob.blobs.length-1])){return true;}}function blobHasDecorations(blob,includeQuotes){var ret=false;var decorlist=['@font-style','@font-variant','@font-weight','@text-decoration','@vertical-align'];if(includeQuotes){decorlist.push('@quotes');}if(blob.decorations){for(var i=0,ilen=blob.decorations.length;i<ilen;i++){if(decorlist.indexOf(blob.decorations[i][0])>-1){ret=true;break;}}}return ret;}function blobHasDescendantQuotes(blob){if(blob.decorations){for(var i=0,ilen=blob.decorations.length;i<ilen;i++){if(blob.decorations[i][0]==='@quotes'&&blob.decorations[i][1]!=="false"){return true;}}}if("object"!==typeof blob.blobs){return false;}return blobHasDescendantQuotes(blob.blobs[blob.blobs.length-1]);//if (blobHasDescendantQuotes(blob.blobs[blob.blobs.length-1])) {
//    return true
//};
//return false;
}function blobHasDescendantMergingPunctuation(parentChar,blob){var childChar=blob.strings.suffix.slice(-1);if(!childChar&&"string"===typeof blob.blobs){childChar=blob.blobs.slice(-1);}var mergedChars=RtoL_MAP[parentChar][childChar];if(mergedChars&&mergedChars.length===1){return true;}if("object"!==typeof blob.blobs){return false;}if(blobHasDescendantMergingPunctuation(parentChar,blob.blobs[blob.blobs.length-1])){return true;}return false;}function matchLastChar(blob,chr){if(!PUNCT[chr]){return false;}if("string"===typeof blob.blobs){if(blob.blobs.slice(-1)===chr){return true;}else{return false;}}else{var child=blob.blobs[blob.blobs.length-1];if(child){var childChar=child.strings.suffix.slice(-1);if(!childChar){return matchLastChar(child,chr);}else if(child.strings.suffix.slice(-1)==chr){return true;}else{return false;}}else{return false;}}}function mergeChars(First,first,Second,second,merge_right){var FirstStrings="blobs"===first?First:First.strings;var SecondStrings="blobs"===second?Second:Second.strings;var firstChar=FirstStrings[first].slice(-1);var secondChar=SecondStrings[second].slice(0,1);function cullRight(){SecondStrings[second]=SecondStrings[second].slice(1);}function cullLeft(){FirstStrings[first]=FirstStrings[first].slice(0,-1);}function addRight(chr){SecondStrings[second]=chr+SecondStrings[second];}function addLeft(chr){FirstStrings[first]+=chr;}var cull=merge_right?cullLeft:cullRight;function matchOnRight(){return RtoL_MAP[secondChar];}function matchOnLeft(){return LtoR_MAP[firstChar];}var match=merge_right?matchOnLeft:matchOnRight;function mergeToRight(){var chr=LtoR_MAP[firstChar][secondChar];if("string"===typeof chr){cullLeft();cullRight();addRight(chr);}else{addRight(firstChar);cullLeft();}}function mergeToLeft(){var chr=RtoL_MAP[secondChar][firstChar];if("string"===typeof chr){cullLeft();cullRight();addLeft(chr);}else{addLeft(secondChar);cullRight();}}var merge=merge_right?mergeToRight:mergeToLeft;var isDuplicate=firstChar===secondChar;if(isDuplicate){cull();}else{if(match()){merge();}}}function upward(parent){//print("START2");
// Terminus if no blobs
if(parent.blobs&&"string"==typeof parent.blobs){if(PUNCT[parent.strings.suffix.slice(0,1)]&&parent.strings.suffix.slice(0,1)===parent.blobs.slice(-1)){parent.strings.suffix=parent.strings.suffix.slice(1);}return;}else if("object"!==typeof parent||"object"!==typeof parent.blobs||!parent.blobs.length){return;}// back-to-front, bottom-first
var parentDecorations=blobHasDecorations(parent,true);for(var i=parent.blobs.length-1;i>-1;i--){this.upward(parent.blobs[i]);var parentStrings=parent.strings;var childStrings=parent.blobs[i].strings;if(i===0){// Remove leading space on first-position child node prefix if there is a trailing space on the node prefix above 
if(" "===parentStrings.prefix.slice(-1)&&" "===childStrings.prefix.slice(0,1)){childStrings.prefix=childStrings.prefix.slice(1);}// Migrate leading punctuation or space on a first-position prefix upward
var childChar=childStrings.prefix.slice(0,1);if(!parentDecorations&&PUNCT_OR_SPACE[childChar]&&!parentStrings.prefix){parentStrings.prefix+=childChar;childStrings.prefix=childStrings.prefix.slice(1);}}if(i===parent.blobs.length-1){// Migrate trailing space ONLY on a last-position suffix upward, controlling for duplicates
var childChar=childStrings.suffix.slice(-1);// ZZZ Loosened to fix initialized names wrapped in a span and followed by a period
if(!parentDecorations&&[" "].indexOf(childChar)>-1){if(parentStrings.suffix.slice(0,1)!==childChar){parentStrings.suffix=childChar+parentStrings.suffix;}childStrings.suffix=childStrings.suffix.slice(0,-1);}}if(parentStrings.delimiter&&i>0){// Remove leading space on mid-position child node prefix if there is a trailing space on delimiter above
if(PUNCT_OR_SPACE[parentStrings.delimiter.slice(-1)]&&parentStrings.delimiter.slice(-1)===childStrings.prefix.slice(0,1)){childStrings.prefix=childStrings.prefix.slice(1);}}// Siblings are handled in adjustNearsideSuffixes()
}//print("   end");
}function leftward(parent){// Terminus if no blobs
if("object"!==typeof parent||"object"!==typeof parent.blobs||!parent.blobs.length){return;}for(var i=parent.blobs.length-1;i>-1;i--){this.leftward(parent.blobs[i]);// This is a delicate one.
//
// Migrate if:
// * there is no umbrella delimiter [ok]
// * neither the child nor its sibling is a number [ok]
// * decorations exist neither on the child nor on the sibling [ok]
// * sibling prefix char is a swapping char [ok]
//
// Suppress without migration if:
// * sibling prefix char matches child suffix char or
// * child suffix is empty and sibling prefix char match last field char
if(i<parent.blobs.length-1&&!parent.strings.delimiter){// If there is a trailing swappable character on a sibling prefix with no intervening delimiter, copy it to suffix,
// controlling for duplicates
var child=parent.blobs[i];var childChar=child.strings.suffix.slice(-1);var sibling=parent.blobs[i+1];var siblingChar=sibling.strings.prefix.slice(0,1);var hasDecorations=blobHasDecorations(child)||blobHasDecorations(sibling);var hasNumber="number"===typeof childChar||"number"===typeof siblingChar;if(!hasDecorations&&!hasNumber&&PUNCT[siblingChar]&&!hasNumber){var suffixAndPrefixMatch=siblingChar===child.strings.suffix.slice(-1);var suffixAndFieldMatch=!child.strings.suffix&&"string"===typeof child.blobs&&child.blobs.slice(-1)===siblingChar;if(!suffixAndPrefixMatch&&!suffixAndFieldMatch){mergeChars(child,'suffix',sibling,'prefix');//child.strings.suffix += siblingChar;
}else{sibling.strings.prefix=sibling.strings.prefix.slice(1);}}}}}function downward(parent){//print("START3");
// Terminus if no blobs
if(parent.blobs&&"string"==typeof parent.blobs){if(PUNCT[parent.strings.suffix.slice(0,1)]&&parent.strings.suffix.slice(0,1)===parent.blobs.slice(-1)){parent.strings.suffix=parent.strings.suffix.slice(1);}return;}else if("object"!==typeof parent||"object"!==typeof parent.blobs||!parent.blobs.length){return;}//if (top) {
//    print("JSON "+JSON.stringify(parent, ["strings", "decorations", "blobs", "prefix", "suffix", "delimiter"], 2));
//}
var parentStrings=parent.strings;// Check for numeric child
var someChildrenAreNumbers=false;for(var i=0,ilen=parent.blobs.length;i<ilen;i++){if(blobIsNumber(parent.blobs[i])){someChildrenAreNumbers=true;break;}}if(true){// If there is a leading swappable character on delimiter, copy it to suffixes IFF none of the targets are numbers
if(parentStrings.delimiter&&PUNCT[parentStrings.delimiter.slice(0,1)]){var delimChar=parentStrings.delimiter.slice(0,1);for(var i=parent.blobs.length-2;i>-1;i--){var childStrings=parent.blobs[i].strings;if(childStrings.suffix.slice(-1)!==delimChar){childStrings.suffix+=delimChar;}}parentStrings.delimiter=parentStrings.delimiter.slice(1);}}// back-to-front, top-first
for(var i=parent.blobs.length-1;i>-1;i--){var child=parent.blobs[i];var childStrings=parent.blobs[i].strings;var childDecorations=blobHasDecorations(child,true);var childIsNumber=blobIsNumber(child);if(i===parent.blobs.length-1){//if (blobHasDescendantQuotes(child)) {
//    print("JSON "+JSON.stringify(parent, ["strings", "decorations", "blobs", "prefix", "suffix", "delimiter"]));
//}
if(true){// If we have decorations, drill down to see if there are quotes below.
// If so, we allow migration anyway.
// Original discussion is here:
// https://forums.zotero.org/discussion/37091/citeproc-bug-punctuation-in-quotes/
var parentChar=parentStrings.suffix.slice(0,1);// Hmm.
// Consider writing out the matching child from blobHasDescendant functions.
// It should save some cycles, and produce the same result.
var allowMigration=false;if(PUNCT[parentChar]){allowMigration=blobHasDescendantMergingPunctuation(parentChar,child);if(!allowMigration&&punctInQuote){allowMigration=blobHasDescendantQuotes(child);}}if(allowMigration){if(PUNCT[parentChar]){if(!blobEndsInNumber(child)){if("string"===typeof child.blobs){mergeChars(child,'blobs',parent,'suffix');}else{mergeChars(child,'suffix',parent,'suffix');}if(parentStrings.suffix.slice(0,1)==="."){childStrings.suffix+=parentStrings.suffix.slice(0,1);parentStrings.suffix=parentStrings.suffix.slice(1);}}}}if(childStrings.suffix.slice(-1)===" "&&parentStrings.suffix.slice(0,1)===" "){parentStrings.suffix=parentStrings.suffix.slice(1);}// More duplicates control
if(PUNCT_OR_SPACE[childStrings.suffix.slice(0,1)]){if("string"===typeof child.blobs&&child.blobs.slice(-1)===childStrings.suffix.slice(0,1)){// Remove parent punctuation of it duplicates the last character of a field
childStrings.suffix=childStrings.suffix.slice(1);}if(childStrings.suffix.slice(-1)===parentStrings.suffix.slice(0,1)){// Remove duplicate punctuation on child suffix
parentStrings.suffix=parentStrings.suffix.slice(0,-1);}}}// Squash dupes
if(matchLastChar(parent,parent.strings.suffix.slice(0,1))){parent.strings.suffix=parent.strings.suffix.slice(1);}}else if(parentStrings.delimiter){// Remove trailing space on mid-position child node suffix if there is a leading space on delimiter above
if(PUNCT_OR_SPACE[parentStrings.delimiter.slice(0,1)]&&parentStrings.delimiter.slice(0,1)===childStrings.suffix.slice(-1)){parent.blobs[i].strings.suffix=parent.blobs[i].strings.suffix.slice(0,-1);}}else{// Otherwise it's a sibling. We don't care about moving spaces here, just suppress a duplicate
var siblingStrings=parent.blobs[i+1].strings;if(!blobIsNumber(child)&&!childDecorations&&PUNCT_OR_SPACE[childStrings.suffix.slice(-1)]&&childStrings.suffix.slice(-1)===siblingStrings.prefix.slice(0,1)){siblingStrings.prefix=siblingStrings.prefix.slice(1);}}// If field content ends with swappable punctuation, suppress swappable punctuation in style suffix.
if(!childIsNumber&&!childDecorations&&PUNCT[childStrings.suffix.slice(0,1)]&&"string"===typeof child.blobs){mergeChars(child,'blobs',child,'suffix');}this.downward(parent.blobs[i]);}/*
        if (top) {

            var seen = [];
            print(JSON.stringify(parent, function(key, val) {
                if (!val || key === 'alldecor') return;
                if (typeof val == "object") {
                    if (seen.indexOf(val) >= 0)
                        return
                    seen.push(val)
                }
                return val
            },2));
        }
*/ //print("  end");
}// Abstract out a couple of utility functions, used in fix() below.
function swapToTheLeft(child){var childChar=child.strings.suffix.slice(0,1);if("string"===typeof child.blobs){while(SWAP_IN[childChar]){mergeChars(child,'blobs',child,'suffix');childChar=child.strings.suffix.slice(0,1);}}else{while(SWAP_IN[childChar]){mergeChars(child.blobs[child.blobs.length-1],'suffix',child,'suffix');childChar=child.strings.suffix.slice(0,1);}}}function swapToTheRight(child){if("string"===typeof child.blobs){var childChar=child.blobs.slice(-1);while(SWAP_OUT[childChar]){mergeChars(child,'blobs',child,'suffix',true);childChar=child.blobs.slice(-1);}}else{var childChar=child.blobs[child.blobs.length-1].strings.suffix.slice(-1);while(SWAP_OUT[childChar]){mergeChars(child.blobs[child.blobs.length-1],'suffix',child,'suffix',true);childChar=child.blobs[child.blobs.length-1].strings.suffix.slice(-1);}}}function fix(parent){// Terminus if no blobs
if("object"!==typeof parent||"object"!==typeof parent.blobs||!parent.blobs.length){return;}//print("START4");
// Do the swap, front-to-back, bottom-first
var lastChar;// XXX Two things to fix with this:
// XXX (1) Stalls after one character
// XXX (2) Moves colon and semicolon, both of which SHOULD stall
for(var i=0,ilen=parent.blobs.length;i<ilen;i++){var child=parent.blobs[i];var quoteSwap=false;for(var j=0,jlen=child.decorations.length;j<jlen;j++){var decoration=child.decorations[j];if(decoration[0]==="@quotes"&&decoration[1]!=="false"){quoteSwap=true;}}if(quoteSwap){if(punctInQuote){swapToTheLeft(child);}else{swapToTheRight(child);}}lastChar=this.fix(parent.blobs[i]);if(child.blobs&&"string"===typeof child.blobs){lastChar=child.blobs.slice(-1);}}return lastChar;}this.upward=upward;this.leftward=leftward;this.downward=downward;this.fix=fix;};/*global CSL: true */CSL.Engine.Opt=function(){this.parallel={enable:false},this.has_disambiguate=false;this.mode="html";this.dates={};this.jurisdictions_seen={};this.suppressedJurisdictions={};this.inheritedAttributes={};this["locale-sort"]=[];this["locale-translit"]=[];this["locale-translat"]=[];this.citeAffixes={persons:{"locale-orig":{prefix:"",suffix:""},"locale-translit":{prefix:"",suffix:""},"locale-translat":{prefix:"",suffix:""}},institutions:{"locale-orig":{prefix:"",suffix:""},"locale-translit":{prefix:"",suffix:""},"locale-translat":{prefix:"",suffix:""}},titles:{"locale-orig":{prefix:"",suffix:""},"locale-translit":{prefix:"",suffix:""},"locale-translat":{prefix:"",suffix:""}},journals:{"locale-orig":{prefix:"",suffix:""},"locale-translit":{prefix:"",suffix:""},"locale-translat":{prefix:"",suffix:""}},publishers:{"locale-orig":{prefix:"",suffix:""},"locale-translit":{prefix:"",suffix:""},"locale-translat":{prefix:"",suffix:""}},places:{"locale-orig":{prefix:"",suffix:""},"locale-translit":{prefix:"",suffix:""},"locale-translat":{prefix:"",suffix:""}}};this["default-locale"]=[];this.update_mode=CSL.NONE;this.bib_mode=CSL.NONE;this.sort_citations=false;/*
     * Default values.
     * The various et-al values are set globally,
     * and the appropriate value is set by the names start
     * tag at runtime, depending on whether the Item is a
     * first or a subsequent reference.
     */this["et-al-min"]=0;this["et-al-use-first"]=1;this["et-al-use-last"]=false;this["et-al-subsequent-min"]=false;this["et-al-subsequent-use-first"]=false;this["demote-non-dropping-particle"]="display-and-sort";// default of true, because none of our consuming
// applications so far store the various prefixes and 
// suffixes we support in separate fields.
this["parse-names"]=true;// this["auto-vietnamese-names"] = true;
this.citation_number_slug=false;this.trigraph="Aaaa00:AaAa00:AaAA00:AAAA00";this.nodenames=[];this.gender={};this['cite-lang-prefs']={persons:['orig'],institutions:['orig'],titles:['orig'],journals:['orig'],publishers:['orig'],places:['orig'],number:['orig']};this.has_layout_locale=false;this.disable_duplicate_year_suppression=[];this.use_context_condition=false;this.jurisdiction_fallbacks={};this.development_extensions={};this.development_extensions.field_hack=true;this.development_extensions.allow_field_hack_date_override=true;this.development_extensions.locator_date_and_revision=true;this.development_extensions.locator_label_parse=true;this.development_extensions.raw_date_parsing=true;this.development_extensions.clean_up_csl_flaws=true;this.development_extensions.consolidate_legal_items=false;this.development_extensions.csl_reverse_lookup_support=false;this.development_extensions.wrap_url_and_doi=false;this.development_extensions.thin_non_breaking_space_html_hack=false;this.development_extensions.apply_citation_wrapper=false;this.development_extensions.main_title_from_short_title=false;this.development_extensions.uppercase_subtitles=false;this.development_extensions.normalize_lang_keys_to_lowercase=false;this.development_extensions.strict_text_case_locales=false;this.development_extensions.expect_and_symbol_form=false;this.development_extensions.require_explicit_legal_case_title_short=false;this.development_extensions.spoof_institutional_affiliations=false;this.development_extensions.force_jurisdiction=false;this.development_extensions.parse_names=true;this.development_extensions.hanging_indent_legacy_number=false;this.development_extensions.throw_on_empty=false;this.development_extensions.strict_inputs=true;this.development_extensions.prioritize_disambiguate_condition=false;this.development_extensions.force_short_title_casing_alignment=true;this.development_extensions.implicit_short_title=false;this.development_extensions.force_title_abbrev_fallback=false;this.development_extensions.split_container_title=false;this.development_extensions.legacy_institution_name_ordering=false;this.development_extensions.etal_min_etal_usefirst_hack=false;};CSL.Engine.Tmp=function(){//
// scratch variable to display the total
// number of names in all rendered variables
// in a cite.  initialized to zero by the
// citation element, incremented by each
// name variable actually rendered
this.names_max=new CSL.Stack();this.names_base=new CSL.Stack();this.givens_base=new CSL.Stack();//
// this holds the field values collected by the @value
// and @variable attributes, for processing by the
// element functions.
this.value=[];/**
     * Object to hold the decorations declared by a name-part
     * element.
     */this.namepart_decorations={};/**
     * String variable to hold the type of a name-part
     * element.
     */this.namepart_type=false;//
// scratch variable to flag whether we are processing
// a citation or a bibiliography.  this diverts token and
// configuration to the appropriateo objects inside
// state.  the default is "citation".
this.area="citation";this.root="citation";this.extension="";//
// controls the implicit conditional wrappers applied
// to top-level elements inside a names substitute span.
// false by default, names start tag pushes a new true level,
// names end tag pops it.  Output value check in @variable
// function of attributes.js sets level to false.  closing names
// tag maps a false value to superior level.
this.can_substitute=new CSL.Stack(0,CSL.LITERAL);//
// notes whether the formatted elements of a date span
// rendered anything.  controls whether literal fallback
// is used.
this.element_rendered_ok=false;//
// element_trace keeps a record of rendered elements.
// used to implement author-only.
//
this.element_trace=new CSL.Stack("style");//
// counter for total namesets
this.nameset_counter=0;//
/////  this.fun.check_for_output = CSL.check_for_output;
//
// stack flag used for term handling.  Set to true
// if at least one variable has tried to render, and
// no variables had content.
this.group_context=new CSL.Stack({term_intended:false,variable_attempt:false,variable_success:false,output_tip:undefined,label_form:undefined,parallel_first:undefined,parallel_last:undefined,parallel_delimiter_override:undefined,condition:false,force_suppress:false,done_vars:[]});//
// boolean flag used to control first-letter capitalization
// of terms.  Set to true if any item preceding the term
// being handled has rendered successfully, otherwise
// false.
this.term_predecessor=false;//
// boolean flag to control use of layout delimiter
// immediately before numbers. This hack is needed for
// some numeric styles.
this.in_cite_predecessor=false;//
// stack flag used to control jumps in the closing
// token of a conditional.
this.jump=new CSL.Stack(0,CSL.LITERAL);//
// holds string parameters for group formatting, between
// the start of a group and the closing token.
this.decorations=new CSL.Stack();//
// token store stack.
this.tokenstore_stack=new CSL.Stack();// for collapsing
this.last_suffix_used="";this.last_names_used=[];this.last_years_used=[];this.years_used=[];this.names_used=[];this.taintedItemIDs={};this.taintedCitationIDs={};//
// scratch stack containing initialize-with strings or null values
this.initialize_with=new CSL.Stack();//
// this is used to set a requested set of
// disambiguation parameters in the output.
// for the array elements, the base array
// (either zero for each nameset, or full-up
// if givens are already used) is set
// during names processing, if no value
// is set in the processor before a rendering
// run.  to simplify things for the calling
// function, these are just bog-standard arrays,
// and can be safely overwritten.
this.disambig_request=false;//
// scratch variable to toggle an attempt to set a
// name in sort order rather than display
// order.
this["name-as-sort-order"]=false;//
// suppress decorations (used for generating
// sort keys and disambiguation keys)
this.suppress_decorations=false;//
// empty settings array, used to report settings used
// if disambig_request is not set at runtime
this.disambig_settings=new CSL.AmbigConfig();//
// sort key array
this.bib_sort_keys=[];//
// holds the prefix between the start of a group
// and the closing token.
this.prefix=new CSL.Stack("",CSL.LITERAL);//
// holds the suffix between the start of a group
// and the closing token.
this.suffix=new CSL.Stack("",CSL.LITERAL);//
// holds the group delimiter between the start of a group
// and the closing token.
this.delimiter=new CSL.Stack("",CSL.LITERAL);//
// Used for conditional locale switching.
this.cite_locales=[];this.cite_affixes={citation:false,bibliography:false,citation_sort:false,bibliography_sort:false};this.strip_periods=0;this.shadow_numbers={};this.authority_stop_last=0;this.loadedItemIDs={};//
// Push/pop array for set/unset of opt.lang setting, used
// in if locale="XX" to force terms to language of item.
// @locale tests track their nesting level in a counter,
// and push the current value of state.opt.lang to one array,
// and the counter value to another. On the way back up,
// closing node decrements the counter, compares its value
// with the trailing value on the array, and pops both
// arrays, resetting state.opt.lang to the previous value.
// A hack to solve a surprisingly difficult problem caused
// by the use of an execution stack for the nested structure.
this.condition_counter=0;//incremented/decremented on ALL conditions
this.condition_lang_val_arr=[];this.condition_lang_counter_arr=[];};CSL.Engine.Fun=function(state){//
// matcher
this.match=new CSL.Util.Match();//
// utility to get standard suffixes for disambiguation
this.suffixator=new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);//
// utility to romanize a numeric value
this.romanizer=new CSL.Util.Romanizer();//
// utility to make an ordinal form of a number
this.ordinalizer=new CSL.Util.Ordinalizer(state);//
// utility to make the long ordinal form of a number, if possible
this.long_ordinalizer=new CSL.Util.LongOrdinalizer();};CSL.Engine.Build=function(){// Alternate et-al term
// Holds the localization key of the alternative term
// to be used for et-al in a names environment.  Reduced
// to a term object when the element tag is processed during
// Build.
this["alternate-term"]=false;//
// flags that we are in the bibliography area.
// used by sort.
this.in_bibliography=false;//
// scratch variable to alter behaviour when processing
// locale files
this.in_style=false;//
// used to ignore info
this.skip=false;//
// the macro ATTRIBUTE stores a macro name on this
// scratch variable anywhere outside the layout area
// during build.  The macro name is picked up when
// the token is encountered inside the layout area,
// either through a direct call, or as part of a nested
// macro expansion, and the macro content is exploded
// into the token list.
this.postponed_macro=false;//
// used especially for controlling macro expansion
// during Build.
this.layout_flag=false;//
// (was buffer_name)
// scratch variable to hold the name of a macro
// or a term until its children have been collected.
this.name=false;this.names_variables=[[]];this.name_label=[{}];//
// scratch variable to hold the value of a form
// attribute until other attributes needed for
// processing have been collected.
this.form=false;this.term=false;//
// the macros themselves are discarded after Build
this.macro={};//
// the macro build stack.  used to raise an error
// when macros would attempt to call themselves.
this.macro_stack=[];//
// stores the content of an XML text node during processing
this.text=false;//
// this is a scratch variable for holding an attribute
// value during processing
this.lang=false;//
// should be able to run uninitialized; may attract some
// cruft this way.
this.area="citation";this.root="citation";this.extension="";//
// controls the application of implicit conditional wrappers
// to top-level elements inside a names substitute span.
// zero by default, build of names tag pushes a
// new level with value 1.  group start tag increments by 1,
// group end tag decrements by 1.  conditional wrappers are
// only applied if value is exactly 1.
this.substitute_level=new CSL.Stack(0,CSL.LITERAL);this.names_level=0;this.render_nesting_level=0;this.render_seen=false;this.bibliography_key_pos=0;};CSL.Engine.Configure=function(){//
// the fail and succeed arrays are used for stack
// processing during configure.
this.tests=[];this.fail=[];this.succeed=[];};CSL.Engine.Citation=function(state){// Citation options area.
// Holds a mixture of persistent and ephemeral
// options and scratch data used during processing of
// a citation.</p>
this.opt={inheritedAttributes:{}};this.tokens=[];// Placeholder function
this.srt=new CSL.Registry.Comparifier(state,"citation_sort");//
// configuration array to hold the collapse
// options, if any.
this.opt.collapse=[];//
// disambiguate options
this.opt["disambiguate-add-names"]=false;this.opt["disambiguate-add-givenname"]=false;this.opt["disambiguate-add-year-suffix"]=false;this.opt["givenname-disambiguation-rule"]="by-cite";this.opt["near-note-distance"]=5;this.opt.topdecor=[];this.opt.layout_decorations=[];this.opt.layout_prefix="";this.opt.layout_suffix="";this.opt.layout_delimiter="";//
// sorting
this.opt.sort_locales=[];this.opt.max_number_of_names=0;this.root="citation";};CSL.Engine.Bibliography=function(){this.opt={inheritedAttributes:{}};this.tokens=[];this.opt.collapse=[];this.opt.topdecor=[];this.opt.layout_decorations=[];this.opt.layout_prefix="";this.opt.layout_suffix="";this.opt.layout_delimiter="";this.opt["line-spacing"]=1;this.opt["entry-spacing"]=1;//
// sorting
this.opt.sort_locales=[];this.opt.max_number_of_names=0;this.root="bibliography";};CSL.Engine.BibliographySort=function(){this.tokens=[];this.opt={};this.opt.sort_directions=[];this.opt.topdecor=[];// Holds the final citation-number sort direction, for use
// in applying numbers in cs:citation and cs:bibliography.
// Value is exclusively controlled by cs:key in bibliography_sort
this.opt.citation_number_sort_direction=CSL.ASCENDING;this.opt.citation_number_secondary=false;this.tmp={};this.keys=[];this.root="bibliography";};CSL.Engine.CitationSort=function(){this.tokens=[];this.opt={};this.opt.sort_directions=[];this.keys=[];this.opt.topdecor=[];this.root="citation";};CSL.Engine.InText=function(){// InText options area.
// Holds a mixture of persistent and ephemeral
// options and scratch data used during processing of
// a citation.</p>
this.opt={inheritedAttributes:{}};this.tokens=[];// Placeholder function
//this.srt = new CSL.Registry.Comparifier(state, "citation_sort");
//
// configuration array to hold the collapse
// options, if any.
this.opt.collapse=[];//
// disambiguate options
this.opt["disambiguate-add-names"]=false;this.opt["disambiguate-add-givenname"]=false;this.opt["disambiguate-add-year-suffix"]=false;this.opt["givenname-disambiguation-rule"]="by-cite";this.opt["near-note-distance"]=5;this.opt.topdecor=[];this.opt.layout_decorations=[];this.opt.layout_prefix="";this.opt.layout_suffix="";this.opt.layout_delimiter="";//
// sorting
this.opt.sort_locales=[];this.opt.max_number_of_names=0;this.root="intext";};/*global CSL: true */CSL.Engine.prototype.previewCitationCluster=function(citation,citationsPre,citationsPost,newMode){// Generate output for a hypothetical citation at the current position,
// Leave the registry in the same state in which it was found.
//print("################### previewCitationCluster() #################");
var oldMode=this.opt.mode;this.setOutputFormat(newMode);// Avoids generating unwanted ibids, if the citationID already exists in document
if(citation.citationID){delete citation.citationID;}var ret=this.processCitationCluster(citation,citationsPre,citationsPost,CSL.PREVIEW);this.setOutputFormat(oldMode);return ret[1];};CSL.Engine.prototype.appendCitationCluster=function(citation){var citationsPre=[];var len=this.registry.citationreg.citationByIndex.length;for(var pos=0;pos<len;pos+=1){var c=this.registry.citationreg.citationByIndex[pos];citationsPre.push([""+c.citationID,c.properties.noteIndex]);}// Drop the data segment to return a list of pos/string pairs.
return this.processCitationCluster(citation,citationsPre,[])[1];};CSL.Engine.prototype.processCitationCluster=function(citation,citationsPre,citationsPost,flag){var c,preCitation,postCitation,i,ilen,j,jlen,k,klen,n,nlen,key,Item,item,noteCitations,textCitations,m,citationsInNote;this.debug=false;this.tmp.loadedItemIDs={};// Revert citation dereference from 2ffc4664ae
//citation = JSON.parse(JSON.stringify(citation));
//print("################### processCitationCluster() #################");
this.tmp.citation_errors=[];this.registry.return_data={"bibchange":false};// make sure this citation has a unique ID, and register it in citationById.
this.setCitationId(citation);var oldCitationList;var oldItemList;var oldAmbigs;if(flag===CSL.PREVIEW){//SNIP-START
if(this.debug){CSL.debug("****** start state save *********");}//SNIP-END
//
// Simplify.
// Take a slice of existing citations.
oldCitationList=this.registry.citationreg.citationByIndex.slice();// Take a slice of current items, for later use with update.
oldItemList=this.registry.reflist.slice();// Make a list of preview citation ref objects. Omit the current
// citation, because it will not exist in registry if: (a) this is
// a new citation; or (b) the calling application is assigning
// new citationIDs for every transaction.
var newCitationList=citationsPre.concat(citationsPost);// Make a full list of desired ids, for use in preview update,
// and a hash list of same while we're at it.
// First step through known citations, then step through
// the items in the citation for preview.
var newItemIds={};var newItemIdsList=[];for(var i=0,ilen=newCitationList.length;i<ilen;i+=1){c=this.registry.citationreg.citationById[newCitationList[i][0]];for(j=0,jlen=c.citationItems.length;j<jlen;j+=1){newItemIds[c.citationItems[j].id]=true;newItemIdsList.push(""+c.citationItems[j].id);}}for(j=0,jlen=citation.citationItems.length;j<jlen;j+=1){newItemIds[citation.citationItems[j].id]=true;newItemIdsList.push(""+citation.citationItems[j].id);}// Clone and save off disambigs of items that will be lost.
oldAmbigs={};for(var i=0,ilen=oldItemList.length;i<ilen;i+=1){if(!newItemIds[oldItemList[i].id]){var oldAkey=this.registry.registry[oldItemList[i].id].ambig;var ids=this.registry.ambigcites[oldAkey];if(ids){for(j=0,jlen=ids.length;j<jlen;j+=1){oldAmbigs[ids[j]]=CSL.cloneAmbigConfig(this.registry.registry[ids[j]].disambig);}}}}// Update items.  This will produce the base name data and sort things.
// Possibly unnecessary?
//this.updateItems(this.registry.mylist.concat(tmpItems));
//SNIP-START
if(this.debug){CSL.debug("****** end state save *********");}//SNIP-END
}this.tmp.taintedCitationIDs={};var sortedItems=[];// Styles that use note backreferencing with a by-cite
// givenname disambiguation rule include the note number
// in the cite for disambiguation purposes. Correct resolution
// of disambiguate="true" conditions on first-reference cites 
// in certain editing scenarios (e.g. where a cite is moved across
// notes) requires that disambiguation be rerun on cites
// affected by the edit.
var rerunAkeys={};// retrieve item data and compose items for use in rendering
// attach pointer to item data to shared copy for good measure
for(var i=0,ilen=citation.citationItems.length;i<ilen;i+=1){// Protect against caller-side overwrites to locator strings etc
item={};for(var key in citation.citationItems[i]){item[key]=citation.citationItems[i][key];}Item=this.retrieveItem(""+item.id);if(Item.id){this.transform.loadAbbreviation("default","hereinafter",Item.id,Item.language);}item=CSL.parseLocator.call(this,item);if(this.opt.development_extensions.consolidate_legal_items){this.remapSectionVariable([[Item,item]]);}if(this.opt.development_extensions.locator_label_parse){if(item.locator&&["bill","gazette","legislation","regulation","treaty"].indexOf(Item.type)===-1&&(!item.label||item.label==='page')){var m=CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);if(m){var tryLabel=CSL.LOCATOR_LABELS_MAP[m[2]];if(this.getTerm(tryLabel)){item.label=tryLabel;item.locator=m[3];}}}}var newitem=[Item,item];sortedItems.push(newitem);citation.citationItems[i].item=Item;}// ZZZ sort stuff moved from here.
// attach the sorted list to the citation item
citation.sortedItems=sortedItems;// build reconstituted citations list in current document order
var citationByIndex=[];var citationById={};var lastNotePos;for(i=0,ilen=citationsPre.length;i<ilen;i+=1){preCitation=citationsPre[i];if(this.opt.development_extensions.strict_inputs){if(citationById[preCitation[0]]){CSL.error("Previously referenced citationID "+preCitation[0]+" encountered in citationsPre");}if(preCitation[1]){if(lastNotePos>preCitation[1]){CSL.debug("Note index sequence is not sane at citationsPre["+i+"]");}lastNotePos=preCitation[1];}}this.registry.citationreg.citationById[preCitation[0]].properties.noteIndex=preCitation[1];citationByIndex.push(this.registry.citationreg.citationById[preCitation[0]]);citationById[preCitation[0]]=this.registry.citationreg.citationById[preCitation[0]];}if(!citation.properties){citation.properties={noteIndex:0};}if(this.opt.development_extensions.strict_inputs){if(citationById[citation.citationID]){CSL.error("Citation with previously referenced citationID "+citation.citationID);}if(citation.properties.noteIndex){if(lastNotePos>citation.properties.noteIndex){CSL.debug("Note index sequence is not sane for citation "+citation.citationID);}lastNotePos=citation.properties.noteIndex;}}citationByIndex.push(citation);citationById[citation.citationID]=citation;for(i=0,ilen=citationsPost.length;i<ilen;i+=1){postCitation=citationsPost[i];if(this.opt.development_extensions.strict_inputs){if(citationById[postCitation[0]]){CSL.error("Previously referenced citationID "+postCitation[0]+" encountered in citationsPost");}if(postCitation[1]){if(lastNotePos>postCitation[1]){CSL.debug("Note index sequence is not sane at postCitation["+i+"]");}lastNotePos=postCitation[1];}}this.registry.citationreg.citationById[postCitation[0]].properties.noteIndex=postCitation[1];citationByIndex.push(this.registry.citationreg.citationById[postCitation[0]]);citationById[postCitation[0]]=this.registry.citationreg.citationById[postCitation[0]];}this.registry.citationreg.citationByIndex=citationByIndex;this.registry.citationreg.citationById=citationById;//
// The processor provides three facilities to support
// updates following position reevaluation.
//
// (1) The updateItems() function reports tainted ItemIDs
// to state.tmp.taintedItemIDs.
//
// (2) The processor memos the type of style referencing as
// CSL.NONE, CSL.NUMERIC or CSL.POSITION in state.opt.update_mode.
//
// XXXX: NO LONGER
// (3) For citations containing cites with backreference note numbers,
// a string image of the rendered citation is held in
// citation.properties.backref_citation, and a list of
// ItemIDs to be used to update the backreference note numbers
// is memoed at citation.properties.backref_index.  When such
// citations change position, they can be updated with a
// series of simple find and replace operations, without
// need for rerendering.
//
//
// Position evaluation!
//
// set positions in reconstituted list, noting taints
this.registry.citationreg.citationsByItemId={};if(this.opt.update_mode===CSL.POSITION){textCitations=[];noteCitations=[];citationsInNote={};}var update_items=[];for(var i=0,ilen=citationByIndex.length;i<ilen;i+=1){citationByIndex[i].properties.index=i;for(j=0,jlen=citationByIndex[i].sortedItems.length;j<jlen;j+=1){item=citationByIndex[i].sortedItems[j];if(!this.registry.citationreg.citationsByItemId[item[1].id]){this.registry.citationreg.citationsByItemId[item[1].id]=[];update_items.push(""+item[1].id);}if(this.registry.citationreg.citationsByItemId[item[1].id].indexOf(citationByIndex[i])===-1){this.registry.citationreg.citationsByItemId[item[1].id].push(citationByIndex[i]);}}if(this.opt.update_mode===CSL.POSITION){if(citationByIndex[i].properties.noteIndex){noteCitations.push(citationByIndex[i]);}else{citationByIndex[i].properties.noteIndex=0;textCitations.push(citationByIndex[i]);}}}//
// update bibliography items here
//
if(flag!==CSL.ASSUME_ALL_ITEMS_REGISTERED){//SNIP-START
if(this.debug){CSL.debug("****** start update items *********");}//SNIP-END
// true signals implicit updateItems (will not rerun sys.retrieveItem())
this.updateItems(update_items,null,null,true);//SNIP-START
if(this.debug){CSL.debug("****** endo update items *********");}//SNIP-END
}if(!this.opt.citation_number_sort&&sortedItems&&sortedItems.length>1&&this.citation_sort.tokens.length>0){for(var i=0,ilen=sortedItems.length;i<ilen;i+=1){sortedItems[i][1].sortkeys=CSL.getSortKeys.call(this,sortedItems[i][0],"citation_sort");}/* 
         * Grouped sort stuff (start)
         */if(this.opt.grouped_sort&&!citation.properties.unsorted){// Insert authorstring as key.
for(var i=0,ilen=sortedItems.length;i<ilen;i+=1){var sortkeys=sortedItems[i][1].sortkeys;this.tmp.authorstring_request=true;// Run getAmbiguousCite() with the current disambig
// parameters, and pick up authorstring from the registry.
var mydisambig=this.registry.registry[sortedItems[i][0].id].disambig;this.tmp.authorstring_request=true;CSL.getAmbiguousCite.call(this,sortedItems[i][0],mydisambig);var authorstring=this.registry.authorstrings[sortedItems[i][0].id];this.tmp.authorstring_request=false;sortedItems[i][1].sortkeys=[authorstring].concat(sortkeys);}sortedItems.sort(this.citation.srt.compareCompositeKeys);// Replace authorstring key in items with same (authorstring) with the 
// keystring of first normal key. This forces grouped sorts,
// as discussed here:
// https://github.com/citation-style-language/schema/issues/40
var lastauthor=false;var thiskey=false;var thisauthor=false;for(var i=0,ilen=sortedItems.length;i<ilen;i+=1){if(sortedItems[i][1].sortkeys[0]!==lastauthor){thisauthor=sortedItems[i][1].sortkeys[0];thiskey=sortedItems[i][1].sortkeys[1];}sortedItems[i][1].sortkeys[0]=""+thiskey+i;lastauthor=thisauthor;}}/*
         * Grouped sort stuff (end)
         */if(!citation.properties.unsorted){sortedItems.sort(this.citation.srt.compareCompositeKeys);}}// evaluate parallels
if(this.opt.parallel.enable){this.parallel.StartCitation(citation.sortedItems);}var citations;if(this.opt.update_mode===CSL.POSITION){for(var i=0;i<2;i+=1){var first_ref={};var last_ref={};var first_container_ref={};citations=[textCitations,noteCitations][i];for(j=0,jlen=citations.length;j<jlen;j+=1){var onecitation=citations[j];if(!citations[j].properties.noteIndex){citations[j].properties.noteIndex=0;}citations[j].properties.noteIndex=parseInt(citations[j].properties.noteIndex,10);if(j>0&&onecitation.properties.noteIndex&&citations[j-1].properties.noteIndex>onecitation.properties.noteIndex){citationsInNote={};first_ref={};last_ref={};first_container_ref={};}for(k=0,klen=onecitation.sortedItems.length;k<klen;k+=1){if(onecitation.sortedItems[k][1].parallel&&onecitation.sortedItems[k][1].parallel!=="first"){continue;}if(!citationsInNote[onecitation.properties.noteIndex]){citationsInNote[onecitation.properties.noteIndex]=1;}else{citationsInNote[onecitation.properties.noteIndex]+=1;}}// Set the following:
//
// (1) position as required (as per current Zotero)
// (2) first-reference-note-number as required (on onecitation item)
// (3) near-note as required (on onecitation item, according to
//     state.opt["near-note-distance"] parameter)
// (4) state.registry.citationreg.citationsByItemId.
//
// Any state changes caused by unsetting or resetting should
// trigger a single entry for the citations in
// state.tmp.taintedCitationIDs (can block on presence of
// state.registry.citationreg.citationsByItemId).
//
for(k=0,klen=citations[j].sortedItems.length;k<klen;k+=1){item=citations[j].sortedItems[k];// Okay ...
// We set up three IDs for use in position evaluation.
// item_id is the real Item.id
// first_id is the legislation_id or Item.id (so statutes backref to first in set, chapters to specific chapter)
// last_id is the legislation_id or container_id (so statute AND chapter distance is from any ref in set)
// (replaces myid)
var item_id=item[0].id;var first_id=item[0].legislation_id?item[0].legislation_id:item[0].id;var last_id=item[0].legislation_id?item[0].legislation_id:item[0].container_id?item[0].container_id:item[0].id;var myxloc=item[1]["locator-extra"];var mylocator=item[1].locator;var mylabel=item[1].label;var incitationid;var incitationxloc;if(k>0){// incitationid is only reached in the else branch
// following "undefined" === typeof first_ref[myid]
// below
if(onecitation.sortedItems[k-1][0].legislation_id){incitationid=onecitation.sortedItems[k-1][0].legislation_id;}else{incitationid=onecitation.sortedItems[k-1][1].id;incitationxloc=onecitation.sortedItems[k-1][1]["locator-extra"];//if (onecitation.sortedItems[k-1][1].parallel === "last") {
for(var l=k-2;l>-1;l--){if(onecitation.sortedItems[l][1].parallel==="first"){incitationid=onecitation.sortedItems[l][1].id;incitationxloc=onecitation.sortedItems[l][1]["locator-extra"];}}//}
}}// Don't touch item data of other cites when previewing
if(flag===CSL.PREVIEW){if(onecitation.citationID!=citation.citationID){if("undefined"===typeof first_ref[item[1].id]){first_ref[first_id]=onecitation.properties.noteIndex;last_ref[last_id]=onecitation.properties.noteIndex;}else{last_ref[last_id]=onecitation.properties.noteIndex;}continue;}}var oldvalue={};oldvalue.position=item[1].position;oldvalue["first-reference-note-number"]=item[1]["first-reference-note-number"];oldvalue["first-container-reference-note-number"]=item[1]["first-container-reference-note-number"];oldvalue["near-note"]=item[1]["near-note"];item[1]["first-reference-note-number"]=0;item[1]["first-container-reference-note-number"]=0;item[1]["near-note"]=false;if(this.registry.citationreg.citationsByItemId[item_id]){if(this.opt.xclass==='note'&&this.opt.has_disambiguate){var oldCount=this.registry.registry[item[0].id]["citation-count"];var newCount=this.registry.citationreg.citationsByItemId[item_id].length;this.registry.registry[item[0].id]["citation-count"]=this.registry.citationreg.citationsByItemId[item_id].length;if("number"===typeof oldCount){var oldCountCheck=oldCount<2;var newCountCheck=newCount<2;if(oldCountCheck!==newCountCheck){for(var l=0,llen=this.registry.citationreg.citationsByItemId[item_id].length;l<llen;l++){rerunAkeys[this.registry.registry[item[0].id].ambig]=true;this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[item_id][l].citationID]=true;}}}else{for(var l=0,llen=this.registry.citationreg.citationsByItemId[item_id].length;l<llen;l++){rerunAkeys[this.registry.registry[item[0].id].ambig]=true;this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[item_id][l].citationID]=true;}}}}var oldlastid;var oldlastxloc;// Okay, chill.
// The first test needs to be for presence of last_ref[last_id]. Everything
// after in subsequent evaluation depends on that.
// HOWEVER, despite starting with this test, we need to catch every member
// of the set, and set its first-container-reference-note-number to point at the
// first.
// ALSO, despite starting with this test, we need to set first-reference-note-number
// on every item.
// So ... we run an independent test on first_ref[first_id]], and let this ride.
if("undefined"===typeof last_ref[last_id]&&onecitation.properties.mode!=="author-only"){first_ref[first_id]=onecitation.properties.noteIndex;last_ref[last_id]=onecitation.properties.noteIndex;first_container_ref[last_id]=onecitation.properties.noteIndex;item[1].position=CSL.POSITION_FIRST;}else{//
// backward-looking position evaluation happens here.
//
//
//
var ibidme=false;var suprame=false;var prevCitation=null;if(j>0){var prevCitation=citations[j-1];}var thisCitation=citations[j];// XXX Ugly, but This is used in the second else-if branch condition below.
if(j>0){var old_last_id_offset=1;if(prevCitation.properties.mode==="author-only"&&j>1){old_last_id_offset=2;}var adjusted_offset=j-old_last_id_offset;if(citations[adjusted_offset].sortedItems.length){oldlastid=citations[adjusted_offset].sortedItems.slice(-1)[0][1].id;oldlastxloc=citations[j-old_last_id_offset].sortedItems.slice(-1)[0][1]["locator-extra"];}if(prevCitation.sortedItems.length){if(prevCitation.sortedItems[0].slice(-1)[0].legislation_id){oldlastid=prevCitation.sortedItems[0].slice(-1)[0].legislation_id;}}}if(j>0&&k===0&&prevCitation.properties.noteIndex!==thisCitation.properties.noteIndex){// Case 1: source in previous onecitation
// (1) Threshold conditions
//     (a) there must be a previous onecitation with one item
//     (b) this item must be the first in this onecitation
//     (c) the previous onecitation must contain a reference
//         to the same item ...
//     (d) the note numbers must be the same or consecutive.
// (this has some jiggery-pokery in it for parallels)
var useme=false;// XXX Can oldid be equated with oldlastid, I wonder ...
var oldid=prevCitation.sortedItems[0][0].id;if(prevCitation.sortedItems[0][0].legislation_id){oldid=prevCitation.sortedItems[0][0].legislation_id;}if(oldid==first_id&&prevCitation.properties.noteIndex>=thisCitation.properties.noteIndex-1){var prevxloc=prevCitation.sortedItems[0][1]["locator-extra"];var thisxloc=thisCitation.sortedItems[0][1]["locator-extra"];if((citationsInNote[prevCitation.properties.noteIndex]===1||prevCitation.properties.noteIndex===0)&&prevxloc===thisxloc){useme=true;}}if(useme){ibidme=true;}else{suprame=true;}}else if(k>0&&incitationid==first_id&&incitationxloc==myxloc){// Case 2: immediately preceding source in this onecitation
// (1) Threshold conditions
//     (a) there must be an imediately preceding reference to  the
//         same item in this onecitation; and
ibidme=true;}else if(k===0&&j>0&&prevCitation.properties.noteIndex==thisCitation.properties.noteIndex&&prevCitation.sortedItems.length&&oldlastid==first_id&&oldlastxloc==myxloc){// ... in case there are separate citations in the same note ...
// Case 2 [take 2]: immediately preceding source in this onecitation
// (1) Threshold conditions
//     (a) there must be an imediately preceding reference to  the
//         same item in this onecitation; and
ibidme=true;}else{// everything else is definitely subsequent
suprame=true;}// conditions
var prev,prev_locator,prev_label,curr_locator,curr_label;if(ibidme){if(k>0){prev=onecitation.sortedItems[k-1][1];}else{prev=citations[j-1].sortedItems[0][1];}if(prev.locator){if(prev.label){prev_label=prev.label;}else{prev_label="";}prev_locator=""+prev.locator+prev_label;}else{prev_locator=prev.locator;}if(mylocator){if(mylabel){curr_label=mylabel;}else{curr_label="";}curr_locator=""+mylocator+curr_label;}else{curr_locator=mylocator;}}// triage
if(ibidme&&prev_locator&&!curr_locator){ibidme=false;suprame=true;}if(ibidme){if(!prev_locator&&curr_locator){//     (a) if the previous onecitation had no locator
//         and this onecitation has one, use ibid+pages
item[1].position=CSL.POSITION_IBID_WITH_LOCATOR;}else if(!prev_locator&&!curr_locator){//     (b) if the previous onecitation had no locator
//         and this onecitation also has none, use ibid
item[1].position=CSL.POSITION_IBID;//print("setting ibid in cmd_cite()");
}else if(prev_locator&&curr_locator===prev_locator){//     (c) if the previous onecitation had a locator
//         (page number, etc.) and this onecitation has
//         a locator that is identical, use ibid
item[1].position=CSL.POSITION_IBID;//print("setting ibid in cmd_cite() [2]");
}else if(prev_locator&&curr_locator&&curr_locator!==prev_locator){//     (d) if the previous onecitation had a locator,
//         and this onecitation has one that differs,
//         use ibid+pages
item[1].position=CSL.POSITION_IBID_WITH_LOCATOR;}else{//     (e) if the previous onecitation had a locator
//         and this onecitation has none, use subsequent
//
//     ... and everything else would be subsequent also
ibidme=false;// just to be clear
suprame=true;}}if(suprame){item[1].position=CSL.POSITION_CONTAINER_SUBSEQUENT;if("undefined"===typeof first_ref[first_id]){first_ref[first_id]=onecitation.properties.noteIndex;}else{item[1].position=CSL.POSITION_SUBSEQUENT;}}if(suprame||ibidme){if(onecitation.properties.mode==="author-only"){item[1].position=CSL.POSITION_FIRST;}if(first_container_ref[last_id]!=onecitation.properties.noteIndex){item[1]['first-container-reference-note-number']=first_container_ref[last_id];if(this.registry.registry[item[0].id]){this.registry.registry[item[0].id]['first-container-reference-note-number']=first_container_ref[last_id];}}if(first_ref[first_id]!=onecitation.properties.noteIndex){item[1]["first-reference-note-number"]=first_ref[first_id];if(this.registry.registry[item[0].id]){// This is either the earliest recorded number, or the number of the current citation, whichever is smaller.
/*
                                    var oldFirst = this.registry.citationreg.citationsByItemId[item_id][0].properties.noteIndex;
                                    var newFirst = onecitation.properties.noteIndex;
                                    this.registry.registry[item[0].id]['first-reference-note-number'] = newFirst < oldFirst ? newFirst: oldFirst;
                                     */ // Try this instead?
this.registry.registry[item[0].id]['first-reference-note-number']=first_ref[first_id];}}}}if(onecitation.properties.noteIndex){var note_distance=parseInt(onecitation.properties.noteIndex,10)-parseInt(last_ref[last_id],10);if(item[1].position!==CSL.POSITION_FIRST&&note_distance<=this.citation.opt["near-note-distance"]){item[1]["near-note"]=true;}last_ref[last_id]=onecitation.properties.noteIndex;}else if(item[1].position!==CSL.POSITION_FIRST){item[1]["near-note"]=true;}if(onecitation.citationID!=citation.citationID){for(n=0,nlen=CSL.POSITION_TEST_VARS.length;n<nlen;n+=1){var param=CSL.POSITION_TEST_VARS[n];if(item[1][param]!==oldvalue[param]){if(this.registry.registry[item[0].id]){if(param==='first-reference-note-number'){rerunAkeys[this.registry.registry[item[0].id].ambig]=true;this.tmp.taintedItemIDs[item[0].id]=true;}}this.tmp.taintedCitationIDs[onecitation.citationID]=true;}}}if(this.sys.variableWrapper){item[1].index=onecitation.properties.index;item[1].noteIndex=onecitation.properties.noteIndex;}}}}}if(this.opt.citation_number_sort&&sortedItems&&sortedItems.length>1&&this.citation_sort.tokens.length>0){if(!citation.properties.unsorted){for(var i=0,ilen=sortedItems.length;i<ilen;i+=1){sortedItems[i][1].sortkeys=CSL.getSortKeys.call(this,sortedItems[i][0],"citation_sort");}sortedItems.sort(this.citation.srt.compareCompositeKeys);}}for(var key in this.tmp.taintedItemIDs){if(this.tmp.taintedItemIDs.hasOwnProperty(key)){citations=this.registry.citationreg.citationsByItemId[key];// Current citation may be tainted but will not exist
// during previewing.
if(citations){for(var i=0,ilen=citations.length;i<ilen;i+=1){this.tmp.taintedCitationIDs[citations[i].citationID]=true;}}}}var ret=[];if(flag===CSL.PREVIEW){// If previewing, return only a rendered string
//SNIP-START
if(this.debug){CSL.debug("****** start run processor *********");}//SNIP-END
try{ret=this.process_CitationCluster.call(this,citation.sortedItems,citation);}catch(e){CSL.error("Error running CSL processor for preview: "+e);}//SNIP-START
if(this.debug){CSL.debug("****** end run processor *********");CSL.debug("****** start state restore *********");}//SNIP-END
// Wind out anything related to new items added for the preview.
// This means (1) names, (2) disambig state for affected items,
// (3) keys registered in the ambigs pool arrays, and (4) registry
// items.
//
// restore sliced citations
this.registry.citationreg.citationByIndex=oldCitationList;this.registry.citationreg.citationById={};for(var i=0,ilen=oldCitationList.length;i<ilen;i+=1){this.registry.citationreg.citationById[oldCitationList[i].citationID]=oldCitationList[i];}//SNIP-START
if(this.debug){CSL.debug("****** start final update *********");}//SNIP-END
var oldItemIds=[];for(var i=0,ilen=oldItemList.length;i<ilen;i+=1){oldItemIds.push(""+oldItemList[i].id);}this.updateItems(oldItemIds,null,null,true);//SNIP-START
if(this.debug){CSL.debug("****** end final update *********");}//SNIP-END
// Roll back disambig states
for(var key in oldAmbigs){if(oldAmbigs.hasOwnProperty(key)){this.registry.registry[key].disambig=oldAmbigs[key];}}//SNIP-START
if(this.debug){CSL.debug("****** end state restore *********");}//SNIP-END
}else{// Rerun cites that have moved across citations or had a change
// in their number of subsequent references, so that disambiguate
// and subsequent-reference-count conditions are applied
// correctly in output.
for(var rerunAkey in rerunAkeys){this.disambiguate.run(rerunAkey,citation);}// Run taints only if not previewing
//
// Push taints to the return object
//
var obj;for(var key in this.tmp.taintedCitationIDs){if(key==citation.citationID){continue;}var mycitation=this.registry.citationreg.citationById[key];if(!mycitation.properties.unsorted){for(var i=0,ilen=mycitation.sortedItems.length;i<ilen;i+=1){mycitation.sortedItems[i][1].sortkeys=CSL.getSortKeys.call(this,mycitation.sortedItems[i][0],"citation_sort");}mycitation.sortedItems.sort(this.citation.srt.compareCompositeKeys);}// For error reporting
this.tmp.citation_pos=mycitation.properties.index;this.tmp.citation_note_index=mycitation.properties.noteIndex;this.tmp.citation_id=""+mycitation.citationID;obj=[];obj.push(mycitation.properties.index);obj.push(this.process_CitationCluster.call(this,mycitation.sortedItems,mycitation));obj.push(mycitation.citationID);ret.push(obj);}this.tmp.taintedItemIDs={};this.tmp.taintedCitationIDs={};// For error reporting again
this.tmp.citation_pos=citation.properties.index;this.tmp.citation_note_index=citation.properties.noteIndex;this.tmp.citation_id=""+citation.citationID;obj=[];obj.push(citationsPre.length);obj.push(this.process_CitationCluster.call(this,sortedItems,citation));obj.push(citation.citationID);ret.push(obj);//
// note for posterity: Rhino and Spidermonkey produce different
// sort results for items with matching keys.  That discrepancy
// turned up a subtle bug in the parallel detection code, trapped
// at line 266, above, and in line 94 of util_parallel.js.
//
ret.sort(function(a,b){if(a[0]>b[0]){return 1;}else if(a[0]<b[0]){return-1;}else{return 0;}});//
// In normal rendering, return is a list of two-part arrays, with the first element
// a citation index number, and the second the text to be inserted.
//
}this.registry.return_data.citation_errors=this.tmp.citation_errors.slice();return[this.registry.return_data,ret];};CSL.Engine.prototype.process_CitationCluster=function(sortedItems,citation){var str="";if(citation&&citation.properties&&citation.properties.mode==="composite"){citation.properties.mode="author-only";var firstChunk=CSL.getCitationCluster.call(this,sortedItems,citation);citation.properties.mode="suppress-author";var secondChunk="";if(citation.properties.infix){this.output.append(citation.properties.infix);secondChunk=this.output.string(this,this.output.queue);// Had no idea this could return a single-element array! Go figure.
if("object"===typeof secondChunk){secondChunk=secondChunk.join("");}}var thirdChunk=CSL.getCitationCluster.call(this,sortedItems,citation);citation.properties.mode="composite";if(firstChunk&&secondChunk&&CSL.SWAPPING_PUNCTUATION.concat(["\u2019","\'"]).indexOf(secondChunk[0])>-1){firstChunk+=secondChunk;secondChunk=false;}str=[firstChunk,secondChunk,thirdChunk].filter(function(obj){return obj;}).join(" ");}else{str=CSL.getCitationCluster.call(this,sortedItems,citation);}return str;};CSL.Engine.prototype.makeCitationCluster=function(rawList){var inputList,newitem,str,pos,len,item,Item;inputList=[];len=rawList.length;for(pos=0;pos<len;pos+=1){item={};for(var key in rawList[pos]){item[key]=rawList[pos][key];}Item=this.retrieveItem(""+item.id);// Code block is copied from processCitationCluster() above
if(this.opt.development_extensions.locator_label_parse){if(item.locator&&["bill","gazette","legislation","regulation","treaty"].indexOf(Item.type)===-1&&(!item.label||item.label==='page')){var m=CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);if(m){var tryLabel=CSL.LOCATOR_LABELS_MAP[m[2]];if(this.getTerm(tryLabel)){item.label=tryLabel;item.locator=m[3];}}}}if(item.locator){item.locator=(""+item.locator).replace(/\s+$/,'');}newitem=[Item,item];inputList.push(newitem);}if(this.opt.development_extensions.consolidate_legal_items){this.remapSectionVariable(inputList);}if(inputList&&inputList.length>1&&this.citation_sort.tokens.length>0){len=inputList.length;for(pos=0;pos<len;pos+=1){inputList[pos][1].sortkeys=CSL.getSortKeys.call(this,inputList[pos][0],"citation_sort");}inputList.sort(this.citation.srt.compareCompositeKeys);}this.tmp.citation_errors=[];var str=CSL.getCitationCluster.call(this,inputList);return str;};/**
 * Get the undisambiguated version of a cite, without decorations
 * <p>This is used internally by the Registry.</p>
 *
 * [object] CSL Item
 * [object] disambiguation parameters
 * [boolean] If true, include first-reference-note-number value in cite
 */CSL.getAmbiguousCite=function(Item,disambig,visualForm,item){var ret;var flags=this.tmp.group_context.tip;var oldTermSiblingLayer={term_intended:flags.term_intended,variable_attempt:flags.variable_attempt,variable_success:flags.variable_success,output_tip:flags.output_tip,label_form:flags.label_form,non_parallel:flags.non_parallel,parallel_last:flags.parallel_last,parallel_first:flags.parallel_first,parallel_last_override:flags.parallel_last_override,parallel_delimiter_override:flags.parallel_delimiter_override,parallel_delimiter_override_on_suppress:flags.parallel_delimiter_override_on_suppress,condition:flags.condition,force_suppress:flags.force_suppress,done_vars:flags.done_vars.slice()};if(disambig){this.tmp.disambig_request=disambig;}else{this.tmp.disambig_request=false;}var itemSupp={position:CSL.POSITION_SUBSEQUENT,"near-note":true};if(item){itemSupp.locator=item.locator;itemSupp.label=item.label;}if(this.registry.registry[Item.id]&&this.registry.citationreg.citationsByItemId&&this.registry.citationreg.citationsByItemId[Item.id]&&this.registry.citationreg.citationsByItemId[Item.id].length&&visualForm){if(this.citation.opt["givenname-disambiguation-rule"]==="by-cite"){itemSupp['first-reference-note-number']=this.registry.registry[Item.id]['first-reference-note-number'];}}this.tmp.area="citation";this.tmp.root="citation";var origSuppressDecorations=this.tmp.suppress_decorations;this.tmp.suppress_decorations=true;this.tmp.just_looking=true;CSL.getCite.call(this,Item,itemSupp,null,false);// !!!
for(var i=0,ilen=this.output.queue.length;i<ilen;i+=1){CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);}if(this.opt.development_extensions.clean_up_csl_flaws){for(var j=0,jlen=this.output.queue.length;j<jlen;j+=1){this.output.adjust.upward(this.output.queue[j]);this.output.adjust.leftward(this.output.queue[j]);this.output.adjust.downward(this.output.queue[j]);this.output.adjust.fix(this.output.queue[j]);}}var ret=this.output.string(this,this.output.queue);this.tmp.just_looking=false;this.tmp.suppress_decorations=origSuppressDecorations;// Cache the result.
this.tmp.group_context.replace(oldTermSiblingLayer);return ret;};/**
 * Return delimiter for use in join
 * <p>Splice evaluation is done during cite
 * rendering, and this method returns the
 * result.  Evaluation requires three items
 * of information from the preceding cite, if
 * one is present: the names used; the years
 * used; and the suffix appended to the
 * citation.  These details are copied into
 * the state object before processing begins,
 * and are cleared by the processor on
 * completion of the run.</p>
 */CSL.getSpliceDelimiter=function(last_locator,last_collapsed,pos){//print(pos +  " after-collapse-delimiter="+this.citation.opt["after-collapse-delimiter"] + "\n  cite_group_delimiter=" + this.tmp.use_cite_group_delimiter + "\n  last_collapsed=" +last_collapsed + "\n  have_collapsed=" +this.tmp.have_collapsed + "\n  last_locator=" + last_locator)
if(undefined!==this.citation.opt["after-collapse-delimiter"]){if(last_locator){this.tmp.splice_delimiter=this.citation.opt["after-collapse-delimiter"];}else if(last_collapsed&&!this.tmp.have_collapsed){this.tmp.splice_delimiter=this.citation.opt["after-collapse-delimiter"];}else if(!last_collapsed&&!this.tmp.have_collapsed&&this.citation.opt.collapse!=="year-suffix"){this.tmp.splice_delimiter=this.citation.opt["after-collapse-delimiter"];}else{this.tmp.splice_delimiter=this.citation.opt.layout_delimiter;}}else if(this.tmp.use_cite_group_delimiter){this.tmp.splice_delimiter=this.citation.opt.cite_group_delimiter;}else{if(this.tmp.have_collapsed&&this.opt.xclass==="in-text"&&this.opt.update_mode!==CSL.NUMERIC){this.tmp.splice_delimiter=", ";}else if(this.tmp.cite_locales[pos-1]){//
// Must have a value to take effect.  Use zero width space to force empty delimiter.
var alt_affixes=this.tmp.cite_affixes[this.tmp.area][this.tmp.cite_locales[pos-1]];if(alt_affixes&&alt_affixes.delimiter){this.tmp.splice_delimiter=alt_affixes.delimiter;}}else if(!this.tmp.splice_delimiter){// This happens when no delimiter is set on cs:layout under cs:citation
this.tmp.splice_delimiter="";}}/*
    if (last_locator && "string" === typeof this.citation.opt["after-collapse-delimiter"]) {
        this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
    } else if (last_collapsed && !this.tmp.have_collapsed && "string" === typeof this.citation.opt["after-collapse-delimiter"]) {
        this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
    } else if (!last_collapsed && !this.tmp.have_collapsed && "string" === typeof this.citation.opt["after-collapse-delimiter"] && !this.citation.opt.collapse === "year-suffix") {
        this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
    } else if (this.tmp.use_cite_group_delimiter) {
        this.tmp.splice_delimiter = this.citation.opt.cite_group_delimiter;
    } else if (this.tmp.have_collapsed && this.opt.xclass === "in-text" && this.opt.update_mode !== CSL.NUMERIC) {
        this.tmp.splice_delimiter = ", ";
    } else if (this.tmp.cite_locales[pos - 1]) {
        //
        // Must have a value to take effect.  Use zero width space to force empty delimiter.
        var alt_affixes = this.tmp.cite_affixes[this.tmp.area][this.tmp.cite_locales[pos - 1]];
        if (alt_affixes && alt_affixes.delimiter) {
            this.tmp.splice_delimiter = alt_affixes.delimiter;
        }
    } else if (!this.tmp.splice_delimiter) {
        // This happens when no delimiter is set on cs:layout under cs:citation
        this.tmp.splice_delimiter = "";
    }
*/ // Paranoia
//if (!this.tmp.splice_delimiter) {
//    this.tmp.splice_delimiter = "";
//}
return this.tmp.splice_delimiter;};/*
 * Compose individual cites into a single string, with
 * flexible inter-cite splicing.
 */CSL.getCitationCluster=function(inputList,citation){var result,objects,myparams,len,pos,item,last_collapsed,params,empties,composite,compie,myblobs,Item,llen,ppos,obj,preceding_item,txt_esc,error_object,citationID,authorOnly,suppressAuthor;var citation_prefix="";this.output.checkNestedBrace=new CSL.checkNestedBrace(this);if(citation){citationID=citation.citationID;authorOnly=citation.properties.mode==="author-only"?!!citation.properties.mode:false;if(this.opt.xclass!=="note"){suppressAuthor=citation.properties.mode==="suppress-author"?!!citation.properties.mode:false;}if(citation.properties.prefix){citation_prefix=CSL.checkPrefixSpaceAppend(this,citation.properties.prefix);}}inputList=inputList?inputList:[];this.tmp.last_primary_names_string=false;txt_esc=CSL.getSafeEscape(this);this.tmp.area="citation";this.tmp.root="citation";result="";objects=[];this.tmp.last_suffix_used="";this.tmp.last_names_used=[];this.tmp.last_years_used=[];this.tmp.backref_index=[];this.tmp.cite_locales=[];if(!this.tmp.just_looking){this.tmp.abbrev_trimmer={QUASHES:{}};}var use_layout_prefix=this.output.checkNestedBrace.update(this.citation.opt.layout_prefix+citation_prefix);//var use_layout_prefix = this.citation.opt.layout_prefix;
var suppressTrailingPunctuation=false;if(this.citation.opt.suppressTrailingPunctuation){suppressTrailingPunctuation=true;}if(citationID){//this.registry.citationreg.citationById[citationID].properties.backref_index = false;
//this.registry.citationreg.citationById[citationID].properties.backref_citation = false;
if(this.registry.citationreg.citationById[citationID].properties["suppress-trailing-punctuation"]){suppressTrailingPunctuation=true;}}// Adjust locator positions if that looks like a sensible thing to do.
if(this.opt.xclass==="note"){var parasets=[];var lastTitle=false;var lastPosition=false;var lastID=false;var lst=[];for(var i=0,ilen=inputList.length;i<ilen;i+=1){var type=inputList[i][0].type;var title=inputList[i][0].title;var position=inputList[i][1].position;var id=inputList[i][0].id;if(title&&type==="legal_case"&&id!==lastID&&position){// Start a fresh sublist if the item title does not match the last one
if(title!==lastTitle||parasets.length===0){lst=[];parasets.push(lst);}lst.push(inputList[i][1]);}lastTitle=title;lastPosition=position;lastID=id;}// We now have a list of sublists, each w/matching titles
for(i=0,ilen=parasets.length;i<ilen;i+=1){lst=parasets[i];if(lst.length<2){continue;}// Get the locator in last position, but only if it's the only one in the set.
var locatorInLastPosition=lst.slice(-1)[0].locator;if(locatorInLastPosition){for(var j=0,jlen=lst.length-1;j<jlen;j+=1){if(lst[j].locator){locatorInLastPosition=false;}}}// move the locator here, if it's called for.
if(locatorInLastPosition){lst[0].locator=locatorInLastPosition;delete lst.slice(-1)[0].locator;lst[0].label=lst.slice(-1)[0].label;if(lst.slice(-1)[0].label){delete lst.slice(-1)[0].label;}}}}myparams=[];len=inputList.length;if(inputList[0]&&inputList[0][1]){if(authorOnly){delete inputList[0][1]["suppress-author"];inputList[0][1]["author-only"]=true;}else if(suppressAuthor){delete inputList[0][1]["author-only"];inputList[0][1]["suppress-author"]=true;}}if(this.opt.parallel.enable){this.parallel.StartCitation(inputList);}for(pos=0;pos<len;pos+=1){// Also for parallels only
this.tmp.cite_index=pos;Item=inputList[pos][0];item=inputList[pos][1];item=CSL.parseLocator.call(this,item);last_collapsed=this.tmp.have_collapsed;var last_locator=false;if(pos>0&&inputList[pos-1][1]){last_locator=!!inputList[pos-1][1].locator;}params={};// Reset shadow_numbers here, suppress reset in getCite()
this.tmp.shadow_numbers={};if(!this.tmp.just_looking&&this.opt.hasPlaceholderTerm){var output=this.output;this.output=new CSL.Output.Queue(this);this.output.adjust=new CSL.Output.Queue.adjust();CSL.getAmbiguousCite.call(this,Item,null,false,item);this.output=output;}this.tmp.in_cite_predecessor=false;// true is to block reset of shadow numbers
if(pos>0){CSL.getCite.call(this,Item,item,""+inputList[pos-1][0].id,true);}else{this.tmp.term_predecessor=false;CSL.getCite.call(this,Item,item,null,true);}// Make a note of any errors
if(!this.tmp.cite_renders_content){error_object={citationID:""+this.tmp.citation_id,index:this.tmp.citation_pos,noteIndex:this.tmp.citation_note_index,itemID:""+Item.id,citationItems_pos:pos,error_code:CSL.ERROR_NO_RENDERED_FORM};this.tmp.citation_errors.push(error_object);}params.splice_delimiter=CSL.getSpliceDelimiter.call(this,last_locator,last_collapsed,pos);// XXX This appears to be superfluous.
if(item&&item["author-only"]){this.tmp.suppress_decorations=true;}if(pos>0){preceding_item=inputList[pos-1][1];// XXX OR if preceding suffix is empty, and the current prefix begins with a full stop.
var precedingEndsInPeriodOrComma=preceding_item.suffix&&[";",".",","].indexOf(preceding_item.suffix.slice(-1))>-1;var currentStartsWithPeriodOrComma=!preceding_item.suffix&&item.prefix&&[";",".",","].indexOf(item.prefix.slice(0,1))>-1;if(precedingEndsInPeriodOrComma||currentStartsWithPeriodOrComma){var spaceidx=params.splice_delimiter.indexOf(" ");if(spaceidx>-1&&!currentStartsWithPeriodOrComma){params.splice_delimiter=params.splice_delimiter.slice(spaceidx);}else{params.splice_delimiter="";}}}params.suppress_decorations=this.tmp.suppress_decorations;params.have_collapsed=this.tmp.have_collapsed;//
// XXXXX: capture parameters to an array, which
// will be of the same length as this.output.queue,
// corresponding to each element.
//
myparams.push(params);if(item["author-only"]){break;}}//
// output.queue is a simple array.  do a slice
// of it to get each cite item, setting params from
// the array that was built in the preceding loop.
//
empties=0;myblobs=this.output.queue.slice();var citation_suffix="";if(citation){citation_suffix=CSL.checkSuffixSpacePrepend(this,citation.properties.suffix);}var suffix=this.citation.opt.layout_suffix;var last_locale=this.tmp.cite_locales[this.tmp.cite_locales.length-1];//
// Must have a value to take effect.  Use zero width space to force empty suffix.
if(last_locale&&this.tmp.cite_affixes[this.tmp.area][last_locale]&&this.tmp.cite_affixes[this.tmp.area][last_locale].suffix){suffix=this.tmp.cite_affixes[this.tmp.area][last_locale].suffix;}if(CSL.TERMINAL_PUNCTUATION.slice(0,-1).indexOf(suffix.slice(0,1))>-1){suffix=suffix.slice(0,1);}//print("=== FROM CITE ===");
suffix=this.output.checkNestedBrace.update(citation_suffix+suffix);for(var i=0,ilen=this.output.queue.length;i<ilen;i+=1){CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);}if(!this.tmp.suppress_decorations&&this.output.queue.length){if(!(this.opt.development_extensions.apply_citation_wrapper&&this.sys.wrapCitationEntry&&!this.tmp.just_looking&&this.tmp.area==="citation")){if(!suppressTrailingPunctuation){this.output.queue[this.output.queue.length-1].strings.suffix=suffix;}this.output.queue[0].strings.prefix=use_layout_prefix;}}if(this.opt.development_extensions.clean_up_csl_flaws){for(var j=0,jlen=this.output.queue.length;j<jlen;j+=1){//print("OUTPUT[5]: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations'],2))
this.output.adjust.upward(this.output.queue[j]);//print("OUTPUT[4]: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations'],2))
this.output.adjust.leftward(this.output.queue[j]);//print("OUTPUT[3]: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations'],2))
this.output.adjust.downward(this.output.queue[j]);//print("OUTPUT[2]: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations'],2))
this.tmp.last_chr=this.output.adjust.fix(this.output.queue[j]);//print("OUTPUT[1]: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations','num'],2))
}}//print("this.tmp.last_chr="+this.tmp.last_chr);
for(pos=0,len=myblobs.length;pos<len;pos+=1){var buffer=[];this.output.queue=[myblobs[pos]];this.tmp.suppress_decorations=myparams[pos].suppress_decorations;this.tmp.splice_delimiter=myparams[pos].splice_delimiter;//
// oh, one last second thought on delimiters ...
//
if(myblobs[pos].parallel_delimiter){this.tmp.splice_delimiter=myblobs[pos].parallel_delimiter;}this.tmp.have_collapsed=myparams[pos].have_collapsed;composite=this.output.string(this,this.output.queue);this.tmp.suppress_decorations=false;// meaningless assignment
// this.tmp.handle_ranges = false;
if("string"===typeof composite){this.tmp.suppress_decorations=false;if(!composite){if(this.opt.development_extensions.throw_on_empty){CSL.error("Citation would render no content");}else{composite="[NO_PRINTED_FORM]";}}return composite;}if("object"===typeof composite&&composite.length===0&&!item["suppress-author"]){if(pos===0){var errStr="[CSL STYLE ERROR: reference with no printed form.]";var preStr=pos===0?txt_esc(this.citation.opt.layout_prefix):"";var sufStr=pos===myblobs.length-1?txt_esc(this.citation.opt.layout_suffix):"";composite.push(preStr+errStr+sufStr);}else if(pos===myblobs.length-1){var tmpobj=objects[objects.length-1];if(typeof tmpobj==="string"){objects[objects.length-1]+=txt_esc(this.citation.opt.layout_suffix);}else if(typeof tmpobj==="object"){tmpobj.strings.suffix+=txt_esc(this.citation.opt.layout_suffix);}}}if(buffer.length&&"string"===typeof composite[0]){composite.reverse();var tmpstr=composite.pop();if(tmpstr&&tmpstr.slice(0,1)===","){buffer.push(tmpstr);}else if("string"==typeof buffer.slice(-1)[0]&&buffer.slice(-1)[0].slice(-1)===","){buffer.push(" "+tmpstr);}else if(tmpstr){buffer.push(txt_esc(this.tmp.splice_delimiter)+tmpstr);}}else{composite.reverse();compie=composite.pop();if("undefined"!==typeof compie){if(buffer.length&&"string"===typeof buffer[buffer.length-1]){buffer[buffer.length-1]+=compie.successor_prefix;}buffer.push(compie);}}// Seems odd, but this was unnecessary and broken.
//composite.reverse();
llen=composite.length;for(ppos=0;ppos<llen;ppos+=1){obj=composite[ppos];if("string"===typeof obj){buffer.push(txt_esc(this.tmp.splice_delimiter)+obj);continue;}compie=composite.pop();if("undefined"!==typeof compie){buffer.push(compie);}}if(buffer.length===0&&!inputList[pos][1]["suppress-author"]){empties+=1;}if(buffer.length>1&&typeof buffer[0]!=="string"){buffer=[this.output.renderBlobs(buffer)];}if(buffer.length){if("string"===typeof buffer[0]){if(pos>0){buffer[0]=txt_esc(this.tmp.splice_delimiter)+buffer[0];}}else{if(pos>0){buffer[0].splice_prefix=this.tmp.splice_delimiter;}else{buffer[0].splice_prefix="";}}}objects=objects.concat(buffer);}// print("OBJECTS="+objects);
result+=this.output.renderBlobs(objects);if(result){//if (CSL.TERMINAL_PUNCTUATION.indexOf(this.tmp.last_chr) > -1 
//    && this.tmp.last_chr === use_layout_suffix.slice(0, 1)) {
//    use_layout_suffix = use_layout_suffix.slice(1);
//}
if(!this.tmp.suppress_decorations){len=this.citation.opt.layout_decorations.length;for(pos=0;pos<len;pos+=1){params=this.citation.opt.layout_decorations[pos];// The "normal" formats in some output modes expect
// a superior nested decoration environment, and
// so should produce no output here.
if(params[1]==="normal"){continue;}if(!item||!item["author-only"]){result=this.fun.decorate[params[0]][params[1]](this,result);}}}}this.tmp.suppress_decorations=false;if(!result){if(this.opt.development_extensions.throw_on_empty){CSL.error("Citation would render no content");}else{result="[NO_PRINTED_FORM]";}}return result;};/*
 * Render a single cite item.
 *
 * This is called on the state object, with a single
 * Item as input.  It iterates exactly once over the style
 * citation tokens, and leaves the result of rendering in
 * the top-level list in the relevant *.opt.output
 * stack, as a list item consisting of a single string.
 *
 * (This is dual-purposed for generating individual
 * entries in a bibliography.)
 */CSL.getCite=function(Item,item,prevItemID,blockShadowNumberReset){var next,error_object;var areaOrig=this.tmp.area;if(item&&item["author-only"]&&this.intext&&this.intext.tokens.length>0){this.tmp.area="intext";}this.tmp.cite_renders_content=false;this.tmp.probably_rendered_something=false;this.tmp.prevItemID=prevItemID;CSL.citeStart.call(this,Item,item,blockShadowNumberReset);next=0;this.tmp.name_node={};this.nameOutput=new CSL.NameOutput(this,Item,item);// rerun?
while(next<this[this.tmp.area].tokens.length){next=CSL.tokenExec.call(this,this[this.tmp.area].tokens[next],Item,item);}CSL.citeEnd.call(this,Item,item);// Odd place for this, but it seems to fit here
if(!this.tmp.cite_renders_content&&!this.tmp.just_looking){if(this.tmp.area==="bibliography"){error_object={index:this.tmp.bibliography_pos,itemID:""+Item.id,error_code:CSL.ERROR_NO_RENDERED_FORM};this.tmp.bibliography_errors.push(error_object);}}this.tmp.area=areaOrig;return""+Item.id;};CSL.citeStart=function(Item,item,blockShadowNumberReset){this.tmp.lang_array=[];if(Item.language){// Guard against garbage locales in user input
var m=Item.language.match(/^([a-zA-Z]+).*/);if(m){this.tmp.lang_array.push(m[1].toLowerCase());}}this.tmp.lang_array.push(this.opt.lang);if(!blockShadowNumberReset){this.tmp.shadow_numbers={};}this.tmp.disambiguate_count=0;this.tmp.disambiguate_maxMax=0;this.tmp.same_author_as_previous_cite=false;if(!this.tmp.suppress_decorations){this.tmp.subsequent_author_substitute_ok=true;}else{this.tmp.subsequent_author_substitute_ok=false;}this.tmp.lastchr="";if(this.tmp.area==="citation"&&this.citation.opt.collapse&&this.citation.opt.collapse.length){//this.tmp.have_collapsed = "year";
this.tmp.have_collapsed=true;}else{this.tmp.have_collapsed=false;}this.tmp.render_seen=false;if(this.tmp.disambig_request&&!this.tmp.disambig_override){this.tmp.disambig_settings=this.tmp.disambig_request;}else if(this.registry.registry[Item.id]&&!this.tmp.disambig_override){this.tmp.disambig_request=this.registry.registry[Item.id].disambig;this.tmp.disambig_settings=this.registry.registry[Item.id].disambig;}else{this.tmp.disambig_settings=new CSL.AmbigConfig();}if(this.tmp.area!=='citation'){if(!this.registry.registry[Item.id]){this.tmp.disambig_restore=new CSL.AmbigConfig();}else{this.tmp.disambig_restore=CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);if(this.tmp.area==='bibliography'&&this.tmp.disambig_settings&&this.tmp.disambig_override){if(this.opt["disambiguate-add-names"]){this.tmp.disambig_settings.names=this.registry.registry[Item.id].disambig.names.slice();if(this.tmp.disambig_request){this.tmp.disambig_request.names=this.registry.registry[Item.id].disambig.names.slice();}}if(this.opt["disambiguate-add-givenname"]){// This is weird and delicate and not fully understood
this.tmp.disambig_request=this.tmp.disambig_settings;this.tmp.disambig_settings.givens=this.registry.registry[Item.id].disambig.givens.slice();this.tmp.disambig_request.givens=this.registry.registry[Item.id].disambig.givens.slice();for(var i=0,ilen=this.tmp.disambig_settings.givens.length;i<ilen;i+=1){this.tmp.disambig_settings.givens[i]=this.registry.registry[Item.id].disambig.givens[i].slice();}for(var i=0,ilen=this.tmp.disambig_request.givens.length;i<ilen;i+=1){this.tmp.disambig_request.givens[i]=this.registry.registry[Item.id].disambig.givens[i].slice();}}}}}this.tmp.names_used=[];this.tmp.nameset_counter=0;this.tmp.years_used=[];this.tmp.names_max.clear();if(!this.tmp.just_looking){if(!item||item.parallel==="first"||!item.parallel){this.tmp.abbrev_trimmer={QUASHES:{}};}}this.tmp.splice_delimiter=this[this.tmp.area].opt.layout_delimiter;//this.tmp.splice_delimiter = this[this.tmp.area].opt.delimiter;
this.bibliography_sort.keys=[];this.citation_sort.keys=[];this.tmp.has_done_year_suffix=false;this.tmp.last_cite_locale=false;// SAVE PARAMETERS HERE, IF APPROPRIATE
// (promiscuous addition of global parameters => death by a thousand cuts)
if(!this.tmp.just_looking&&item&&!item.position&&this.registry.registry[Item.id]){this.tmp.disambig_restore=CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);}// XXX This only applied to the "number" variable itself? Huh?
//this.setNumberLabels(Item);
this.tmp.first_name_string=false;this.tmp.authority_stop_last=0;};CSL.citeEnd=function(Item,item){// RESTORE PARAMETERS IF APPROPRIATE
if(this.tmp.disambig_restore&&this.registry.registry[Item.id]){this.registry.registry[Item.id].disambig.names=this.tmp.disambig_restore.names.slice();this.registry.registry[Item.id].disambig.givens=this.tmp.disambig_restore.givens.slice();for(var i=0,ilen=this.registry.registry[Item.id].disambig.givens.length;i<ilen;i+=1){this.registry.registry[Item.id].disambig.givens[i]=this.tmp.disambig_restore.givens[i].slice();}}this.tmp.disambig_restore=false;if(item&&item.suffix){//this.tmp.last_suffix_used = this.tmp.suffix.value();
this.tmp.last_suffix_used=item.suffix;}else{this.tmp.last_suffix_used="";}this.tmp.last_years_used=this.tmp.years_used.slice();this.tmp.last_names_used=this.tmp.names_used.slice();this.tmp.cut_var=false;// This is a hack, in a way; I have lost track of where
// the disambig (name rendering) settings used for rendering work their way
// into the registry.  This resets defaults to the subsequent form,
// when first cites are rendered.
//if (this.tmp.disambig_restore && this.registry.registry[Item.id]) {
//    this.registry.registry[Item.id].disambig = this.tmp.disambig_restore;
//}
//this.tmp.disambig_restore = false;
this.tmp.disambig_request=false;this.tmp.cite_locales.push(this.tmp.last_cite_locale);if(this.tmp.issued_date&&this.tmp.renders_collection_number){var buf=[];for(var i=this.tmp.issued_date.list.length-1;i>this.tmp.issued_date.pos;i+=-1){buf.push(this.tmp.issued_date.list.pop());}// Throw away the unwanted blob
this.tmp.issued_date.list.pop();// Put the other stuff back
for(i=buf.length-1;i>-1;i+=-1){this.tmp.issued_date.list.push(buf.pop());}}this.tmp.issued_date=false;this.tmp.renders_collection_number=false;};/*global CSL: true */CSL.Engine.prototype.makeBibliography=function(bibsection){var debug,ret,params,maxoffset,item,len,pos,tok,tokk,tokkk,entry_ids,entry_strings;debug=false;if(!bibsection&&(this.bibliography.opt.exclude_types||this.bibliography.opt.exclude_with_fields)){bibsection={exclude:[]};if(this.bibliography.opt.exclude_types){for(var i in this.bibliography.opt.exclude_types){var val=this.bibliography.opt.exclude_types[i];bibsection.exclude.push({field:"type",value:val});}}if(this.bibliography.opt.exclude_with_fields){for(var i in this.bibliography.opt.exclude_with_fields){var field=this.bibliography.opt.exclude_with_fields[i];bibsection.exclude.push({field:field,value:true});}}}// API change: added in version 1.0.51
if(!this.bibliography.tokens.length){return false;}if("string"===typeof bibsection){this.opt.citation_number_slug=bibsection;bibsection=false;}//SNIP-START
if(debug){len=this.bibliography.tokens.length;for(pos=0;pos<len;pos+=1){tok=this.bibliography.tokens[pos];CSL.debug("bibtok: "+tok.name);}CSL.debug("---");len=this.citation.tokens.length;for(pos=0;pos<len;pos+=1){tokk=this.citation.tokens[pos];CSL.debug("cittok: "+tok.name);}CSL.debug("---");len=this.bibliography_sort.tokens.length;for(pos=0;pos<len;pos+=1){tokkk=this.bibliography_sort.tokens[pos];CSL.debug("bibsorttok: "+tok.name);}}//SNIP-END
// For paged returns
ret=CSL.getBibliographyEntries.call(this,bibsection);entry_ids=ret[0];entry_strings=ret[1];// For paged returns
var done=ret[2];params={"maxoffset":0,"entryspacing":this.bibliography.opt["entry-spacing"],"linespacing":this.bibliography.opt["line-spacing"],"second-field-align":false,"entry_ids":entry_ids,"bibliography_errors":this.tmp.bibliography_errors.slice(),"done":done};if(this.bibliography.opt["second-field-align"]){params["second-field-align"]=this.bibliography.opt["second-field-align"];}maxoffset=0;len=this.registry.reflist.length;for(pos=0;pos<len;pos+=1){item=this.registry.reflist[pos];if(item.offset>params.maxoffset){params.maxoffset=item.offset;}}if(this.bibliography.opt.hangingindent){params.hangingindent=this.bibliography.opt.hangingindent;}params.bibstart=this.fun.decorate.bibstart;params.bibend=this.fun.decorate.bibend;this.opt.citation_number_slug=false;return[params,entry_strings];};/*
 * Compose individual cites into a single string.
 */CSL.getBibliographyEntries=function(bibsection){var ret,input,include,anymatch,allmatch,bib_entry,res,item,spec,lllen,pppos,topblobs,entry_item_ids,debug,i,ilen,siblings,skips,sortedItems,eyetem,entry_item_data,j,jlen;ret=[];entry_item_data=[];this.tmp.area="bibliography";this.tmp.root="bibliography";this.tmp.last_rendered_name=false;this.tmp.bibliography_errors=[];this.tmp.bibliography_pos=0;// For paged returns: disable generated entries and
// do not fetch full items as a batch (input variable
// consists of ids only in this case)
if(bibsection&&bibsection.page_start&&bibsection.page_length){input=this.registry.getSortedIds();}else{input=this.refetchItems(this.registry.getSortedIds());}this.tmp.disambig_override=true;function eval_string(a,b){if(a===b){return true;}return false;}function eval_list(a,lst){lllen=lst.length;for(pppos=0;pppos<lllen;pppos+=1){if(eval_string(a,lst[pppos])){return true;}}return false;}function eval_spec(a,b){if("boolean"===typeof a||!a){if(a){return!!b;}else{return!b;}}else{if("string"===typeof b){return eval_string(a,b);}else if(!b){return false;}else{return eval_list(a,b);}}}skips={};// For paged returns
var page_item_count;if(bibsection&&bibsection.page_start&&bibsection.page_length){page_item_count=0;if(bibsection.page_start!==true){for(i=0,ilen=input.length;i<ilen;i+=1){skips[input[i]]=true;if(bibsection.page_start==input[i]){break;}}}}var processed_item_ids=[];var consolidatedIDs={};this.tmp.container_item_count={};input=input.filter(o=>{var ret=o;if(o.legislation_id){if(consolidatedIDs[o.legislation_id]){ret=false;}else{consolidatedIDs[o.legislation_id]=true;}}else if(o.container_id){if(!this.tmp.container_item_count[o.container_id]){this.tmp.container_item_count[o.container_id]=0;}this.tmp.container_item_count[o.container_id]++;if(this.bibliography.opt.consolidate_containers.indexOf(o.type)>-1){if(consolidatedIDs[o.container_id]){ret=false;}else{consolidatedIDs[o.container_id]=true;}}}return ret;});this.tmp.container_item_pos={};for(i=0,ilen=input.length;i<ilen;i+=1){// For paged returns
if(bibsection&&bibsection.page_start&&bibsection.page_length){if(skips[input[i]]){continue;}item=this.refetchItem(input[i]);if(page_item_count===bibsection.page_length){break;}}else{item=input[i];if(skips[item.id]){continue;}}if(bibsection){include=true;if(bibsection.include){//
// Opt-in: these are OR-ed.
//
include=false;for(j=0,jlen=bibsection.include.length;j<jlen;j+=1){spec=bibsection.include[j];if(eval_spec(spec.value,item[spec.field])){include=true;break;}}}else if(bibsection.exclude){//
// Opt-out: these are also OR-ed.
//
anymatch=false;for(j=0,jlen=bibsection.exclude.length;j<jlen;j+=1){spec=bibsection.exclude[j];if(eval_spec(spec.value,item[spec.field])){anymatch=true;break;}}if(anymatch){include=false;}}else if(bibsection.select){//
// Multiple condition opt-in: these are AND-ed.
//
include=false;allmatch=true;for(j=0,jlen=bibsection.select.length;j<jlen;j+=1){spec=bibsection.select[j];if(!eval_spec(spec.value,item[spec.field])){allmatch=false;}}if(allmatch){include=true;}}if(bibsection.quash){//
// Stop criteria: These are AND-ed.
//
allmatch=true;for(j=0,jlen=bibsection.quash.length;j<jlen;j+=1){spec=bibsection.quash[j];if(!eval_spec(spec.value,item[spec.field])){allmatch=false;}}if(allmatch){include=false;}}if(!include){continue;}}//SNIP-START
if(debug){CSL.debug("BIB: "+item.id);}if(item.container_id){if(!this.tmp.container_item_pos[item.container_id]){this.tmp.container_item_pos[item.container_id]=0;}this.tmp.container_item_pos[item.container_id]++;}//SNIP-END
bib_entry=new CSL.Token("group",CSL.START);bib_entry.decorations=[["@bibliography","entry"]].concat(this.bibliography.opt.layout_decorations);this.output.startTag("bib_entry",bib_entry);if(item.system_id&&this.sys.embedBibliographyEntry){this.output.current.value().item_id=item.system_id;}else{this.output.current.value().system_id=item.id;}// 2019-06-25 Hacked to conform to new parallels evaluation method
// 2020-04-25 Revised to work with latest, and final, parallel-first/parallel-last attributes
entry_item_ids=[];if(this.registry.registry[item.id].master&&!(bibsection&&bibsection.page_start&&bibsection.page_length)){// Fetch item content
sortedItems=[[item,{id:item.id}]];siblings=this.registry.registry[item.id].siblings;for(var j=0,jlen=siblings.length;j<jlen;j++){sortedItems.push([this.refetchItem(siblings[j]),{id:siblings[j]}]);}// Adjust parameters
this.parallel.StartCitation(sortedItems);if(this.registry.registry[item.id].parallel_delimiter_override){this.output.queue[0].strings.delimiter=this.registry.registry[item.id].parallel_delimiter_override;}else{this.output.queue[0].strings.delimiter=", ";}this.tmp.term_predecessor=false;this.tmp.cite_index=0;// Run cites
for(j=0,jlen=sortedItems.length;j<jlen;j+=1){if(j<sortedItems.length-1){this.tmp.parallel_and_not_last=true;}else{delete this.tmp.parallel_and_not_last;}entry_item_ids.push(""+CSL.getCite.call(this,sortedItems[j][0],sortedItems[j][1]));this.tmp.cite_index++;skips[sortedItems[j][0].id]=true;}}else if(!this.registry.registry[item.id].siblings){this.tmp.term_predecessor=false;this.tmp.cite_index=0;entry_item_ids.push(""+CSL.getCite.call(this,item));if(bibsection&&bibsection.page_start&&bibsection.page_length){page_item_count+=1;}//skips[item.id] = true;
}// For RDF support
entry_item_data.push("");this.tmp.bibliography_pos+=1;processed_item_ids.push(entry_item_ids);//
// XXX: loop to render parallels goes here
// XXX: just have to mark them somehow ...
//
this.output.endTag("bib_entry");//
// place layout prefix on first blob of each cite, and suffix
// on the last non-empty blob of each cite.  there be dragons
// here.
//
if(this.output.queue[0].blobs.length&&this.output.queue[0].blobs[0].blobs.length){// The output queue stuff needs cleaning up.  the result of
// output.current.value() is sometimes a blob, sometimes its list
// of blobs.  this inconsistency is a source of confusion, and
// should be cleaned up across the code base in the first
// instance, before making any other changes to output code.
if(!this.output.queue[0].blobs[0].blobs[0].strings){topblobs=this.output.queue[0].blobs;}else{topblobs=this.output.queue[0].blobs[0].blobs;}topblobs[0].strings.prefix=this.bibliography.opt.layout_prefix+topblobs[0].strings.prefix;}for(j=0,jlen=this.output.queue.length;j<jlen;j+=1){CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[j]);//print("XXX: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations'],2))
}for(j=0,jlen=this.output.queue.length;j<jlen;j+=1){this.output.adjust.upward(this.output.queue[j]);this.output.adjust.leftward(this.output.queue[j]);this.output.adjust.downward(this.output.queue[j],true);this.output.adjust.fix(this.output.queue[j]);//print("OUTPUT: "+JSON.stringify(this.output.queue[j],['strings','prefix','suffix','delimiter','blobs','decorations'],2))
}//print("DUMP "+JSON.stringify(this.output.queue, ["strings", "decorations", "prefix", "suffix", "delimiter", "blobs"], 2));
// XXX Need to account for numeric blobs in input.
// XXX No idea how this could have worked previously.
//print("BLOBS "+this.output.queue[0].blobs[0].blobs);
//print("JSON "+JSON.stringify(this.output.queue[0].blobs, null, 2));
res=this.output.string(this,this.output.queue)[0];if(!res&&this.opt.update_mode===CSL.NUMERIC){var err=ret.length+1+". [CSL STYLE ERROR: reference with no printed form.]";res=CSL.Output.Formats[this.opt.mode]["@bibliography/entry"](this,err);}if(res){ret.push(res);}}var done=false;if(bibsection&&bibsection.page_start&&bibsection.page_length){var last_expected_id=input.slice(-1)[0];var last_seen_id=processed_item_ids.slice(-1)[0];if(!last_expected_id||!last_seen_id||last_expected_id==last_seen_id){done=true;}}this.tmp.disambig_override=false;// XXX done
return[processed_item_ids,ret,done];};/*global CSL: true */CSL.Engine.prototype.setCitationId=function(citation,force){var ret,id,direction;ret=false;if(!citation.citationID||force){id=Math.floor(Math.random()*100000000000000);while(true){direction=0;if(!this.registry.citationreg.citationById[id]){// In case the ID is used as an HTML identifier in the
// calling application.
//   https://github.com/Juris-M/citeproc-js/issues/22
citation.citationID="a"+id.toString(32);break;}else if(!direction&&id<50000000000000){direction=1;}else{direction=-1;}if(direction===1){id+=1;}else{id+=-1;}}ret=""+id;}this.registry.citationreg.citationById[citation.citationID]=citation;return ret;};CSL.Engine.prototype.rebuildProcessorState=function(citations,mode,uncitedItemIDs){// Rebuilds the processor from scratch, based on a list of citation
// objects. In a dynamic application, once the internal state of processor
// is established, citations should edited with individual invocations
// of processCitationCluster().
// citations is a list of citation objects in document order.
// mode is one of "html", "text" or "rtf".
// uncitedItemIDs is a list of itemIDs or a JS object with itemIDs as keys.
// Returns a list of [citationID,noteIndex,string] triples in document order.
// Set citation.properties.noteIndex to 0 for in-text citations.
// It is not necessary to run updateItems() before this function.
if(!citations){citations=[];}if(!mode){mode='html';}var doneIDs={};var itemIDs=[];for(var i=0,ilen=citations.length;i<ilen;i+=1){for(var j=0,jlen=citations[i].citationItems.length;j<jlen;j+=1){var itemID=""+citations[i].citationItems[j].id;if(!doneIDs[itemID]){itemIDs.push(itemID);}doneIDs[itemID]=true;}}this.updateItems(itemIDs);var pre=[];var post=[];var ret=[];var oldMode=this.opt.mode;this.setOutputFormat(mode);for(var i=0,ilen=citations.length;i<ilen;i+=1){// res contains a result report and a list of [index,string] pairs
// index begins at 0
var res=this.processCitationCluster(citations[i],pre,post,CSL.ASSUME_ALL_ITEMS_REGISTERED);pre.push([citations[i].citationID,citations[i].properties.noteIndex]);for(var j=0,jlen=res[1].length;j<jlen;j+=1){var index=res[1][j][0];ret[index]=[pre[index][0],pre[index][1],res[1][j][1]];}}this.updateUncitedItems(uncitedItemIDs);this.setOutputFormat(oldMode);return ret;};CSL.Engine.prototype.restoreProcessorState=function(citations){var i,ilen,j,jlen,item,Item,newitem,citationList,itemList,sortedItems;// This function is deprecated.
// Use rebuildProcessorState() instead.
// Quickly restore state from citation details retained by
// calling application.
//
// if citations are provided, position details and sortkeys 
// on the citation objects are are assumed to be correct.  Item
// data is retrieved, and sortedItems arrays are created and
// sorted as required by the current style.
//
// If citations is an empty list or nil, reset processor to
// empty state.
citationList=[];itemList=[];if(!citations){citations=[];}// Adjust citationIDs to avoid duplicates, save off index numbers
var indexNumbers=[];var citationIds={};for(i=0,ilen=citations.length;i<ilen;i+=1){if(citationIds[citations[i].citationID]){this.setCitationId(citations[i],true);}citationIds[citations[i].citationID]=true;indexNumbers.push(citations[i].properties.index);}// Slice citations and sort by their declared index positions, if any,
// then reassign index and noteIndex numbers.
var oldCitations=citations.slice();oldCitations.sort(function(a,b){if(a.properties.index<b.properties.index){return-1;}else if(a.properties.index>b.properties.index){return 1;}else{return 0;}});for(i=0,ilen=oldCitations.length;i<ilen;i+=1){oldCitations[i].properties.index=i;}for(i=0,ilen=oldCitations.length;i<ilen;i+=1){sortedItems=[];for(j=0,jlen=oldCitations[i].citationItems.length;j<jlen;j+=1){item=oldCitations[i].citationItems[j];if("undefined"===typeof item.sortkeys){item.sortkeys=[];}Item=this.retrieveItem(""+item.id);newitem=[Item,item];sortedItems.push(newitem);oldCitations[i].citationItems[j].item=Item;itemList.push(""+item.id);}if(!oldCitations[i].properties.unsorted){sortedItems.sort(this.citation.srt.compareCompositeKeys);}oldCitations[i].sortedItems=sortedItems;// Save citation data in registry
this.registry.citationreg.citationById[oldCitations[i].citationID]=oldCitations[i];}// Register Items
this.updateItems(itemList);// Construct citationList from original copy
for(i=0,ilen=citations.length;i<ilen;i+=1){citationList.push([""+citations[i].citationID,citations[i].properties.noteIndex]);}var ret=[];if(citations&&citations.length){// Rendering one citation restores remainder of processor state.
// If citations is empty, rest to empty state.
ret=this.processCitationCluster(citations[0],[],citationList.slice(1));}else{this.registry=new CSL.Registry(this);this.tmp=new CSL.Engine.Tmp();this.disambiguate=new CSL.Disambiguation(this);}return ret;};CSL.Engine.prototype.updateItems=function(idList,nosort,rerun_ambigs,implicitUpdate){var debug=false;var oldArea=this.tmp.area;var oldRoot=this.tmp.root;var oldExtension=this.tmp.extension;if(this.bibliography_sort.tokens.length===0){nosort=true;}this.tmp.area="citation";this.tmp.root="citation";this.tmp.extension="";if(!implicitUpdate){this.tmp.loadedItemIDs={};}//CSL.debug = print
//SNIP-START
if(debug){CSL.debug("--> init <--");}//SNIP-END
this.registry.init(idList);if(rerun_ambigs){for(var ambig in this.registry.ambigcites){this.registry.ambigsTouched[ambig]=true;}}this.registry.dodeletes(this.registry.myhash);this.registry.doinserts(this.registry.mylist);this.registry.dorefreshes();// *** affects reflist
this.registry.rebuildlist(nosort);this.registry.setsortkeys();// taints always
this.registry.setdisambigs();// *** affects reflist
this.registry.sorttokens(nosort);// *** affects reflist
// taints if numbered style
this.registry.renumber();// taints always
//this.registry.yearsuffix();
this.tmp.extension=oldExtension;this.tmp.area=oldArea;this.tmp.root=oldRoot;return this.registry.getSortedIds();};CSL.Engine.prototype.updateUncitedItems=function(idList,nosort){var idHash;var oldArea=this.tmp.area;var oldRoot=this.tmp.root;var oldExtension=this.tmp.extension;if(this.bibliography_sort.tokens.length===0){nosort=true;}this.tmp.area="citation";this.tmp.root="citation";this.tmp.extension="";this.tmp.loadedItemIDs={};// This should be a utility function
if(!idList){idList=[];}if("object"==typeof idList){if("undefined"==typeof idList.length){idHash=idList;idList=[];for(var key in idHash){idList.push(key);}}else if("number"==typeof idList.length){idHash={};for(var i=0,ilen=idList.length;i<ilen;i+=1){idHash[idList[i]]=true;}}}// prepare extended list of items
this.registry.init(idList,true);// Use purge instead of delete.
// this.registry.dodeletes(this.registry.myhash);
this.registry.dopurge(idHash);// everything else is the same as updateItems()
this.registry.doinserts(this.registry.mylist);this.registry.dorefreshes();this.registry.rebuildlist(nosort);this.registry.setsortkeys();this.registry.setdisambigs();this.registry.sorttokens(nosort);this.registry.renumber();this.tmp.extension=oldExtension;this.tmp.area=oldArea;this.tmp.root=oldRoot;return this.registry.getSortedIds();};/*global CSL: true */CSL.localeResolve=function(langstr,defaultLocale){var ret,langlst;if(!defaultLocale){defaultLocale="en-US";}if(!langstr){langstr=defaultLocale;}ret={};//if ("undefined" === typeof langstr) {
//    langstr = "en_US";
//}
langlst=langstr.split(/[\-_]/);ret.base=CSL.LANG_BASES[langlst[0]];if("undefined"===typeof ret.base){//CSL.debug("Warning: unknown locale "+langstr+", setting fallback to "+defaultLocale);
return{base:defaultLocale,best:langstr,bare:langlst[0]};}if(langlst.length===1){ret.generic=true;}if(langlst.length===1||langlst[1]==="x"){ret.best=ret.base.replace("_","-");}else{ret.best=langlst.slice(0,2).join("-");}ret.base=ret.base.replace("_","-");ret.bare=langlst[0];return ret;};// Use call to invoke this.
CSL.Engine.prototype.localeConfigure=function(langspec,beShy){var localexml;if(beShy&&this.locale[langspec.best]){return;}if(langspec.best==="en-US"){localexml=CSL.setupXml(this.sys.retrieveLocale("en-US"));this.localeSet(localexml,"en-US",langspec.best);}else if(langspec.best!=="en-US"){if(langspec.base!==langspec.best){localexml=CSL.setupXml(this.sys.retrieveLocale(langspec.base));this.localeSet(localexml,langspec.base,langspec.best);}localexml=CSL.setupXml(this.sys.retrieveLocale(langspec.best));this.localeSet(localexml,langspec.best,langspec.best);}this.localeSet(this.cslXml,"",langspec.best);this.localeSet(this.cslXml,langspec.bare,langspec.best);if(langspec.base!==langspec.best){this.localeSet(this.cslXml,langspec.base,langspec.best);}this.localeSet(this.cslXml,langspec.best,langspec.best);if("undefined"===typeof this.locale[langspec.best].terms["page-range-delimiter"]){if(["fr","pt"].indexOf(langspec.best.slice(0,2).toLowerCase())>-1){this.locale[langspec.best].terms["page-range-delimiter"]="-";}else{this.locale[langspec.best].terms["page-range-delimiter"]="\u2013";}}if("undefined"===typeof this.locale[langspec.best].terms["year-range-delimiter"]){this.locale[langspec.best].terms["year-range-delimiter"]="\u2013";}if("undefined"===typeof this.locale[langspec.best].terms["citation-range-delimiter"]){this.locale[langspec.best].terms["citation-range-delimiter"]="\u2013";}if(this.opt.development_extensions.normalize_lang_keys_to_lowercase){var localeLists=["default-locale","locale-sort","locale-translit","locale-translat"];for(var i=0,ilen=localeLists.length;i<ilen;i+=1){for(var j=0,jlen=this.opt[localeLists[i]].length;j<jlen;j+=1){this.opt[localeLists[i]][j]=this.opt[localeLists[i]][j].toLowerCase();}}this.opt.lang=this.opt.lang.toLowerCase();}};//
// XXXXX: Got it.  The locales objects need to be reorganized,
// with a top-level local specifier, and terms, opts, dates
// below.
//
CSL.Engine.prototype.localeSet=function(myxml,lang_in,lang_out){var blob,locale,nodes,attributes,pos,term,form,termname,styleopts,date,attrname,len,genderform,target,i,ilen;lang_in=lang_in.replace("_","-");lang_out=lang_out.replace("_","-");if(this.opt.development_extensions.normalize_lang_keys_to_lowercase){lang_in=lang_in.toLowerCase();lang_out=lang_out.toLowerCase();}if(!this.locale[lang_out]){this.locale[lang_out]={};this.locale[lang_out].terms={};this.locale[lang_out].opts={};// Set default skip words. Can be overridden in locale by attribute on style-options node.
this.locale[lang_out].opts["skip-words"]=CSL.SKIP_WORDS;// Initialise leading noise word to false. Actual assignment is below. Empty by default, can be overridden in locale by attribute on style-options node.
if(!this.locale[lang_out].opts["leading-noise-words"]){this.locale[lang_out].opts["leading-noise-words"]=[];}this.locale[lang_out].dates={};// For ordinals
this.locale[lang_out].ord={'1.0.1':false,keys:{}};this.locale[lang_out]["noun-genders"]={};}//
// Xml: Test if node is "locale" (nb: ns declarations need to be invoked
// on every access to the xml object; bundle this with the functions
//
locale=myxml.makeXml();if(myxml.nodeNameIs(myxml.dataObj,'locale')){locale=myxml.dataObj;}else{//
// Xml: get a list of all "locale" nodes
//
nodes=myxml.getNodesByName(myxml.dataObj,"locale");var foundLocale=false;for(pos=0,len=myxml.numberofnodes(nodes);pos<len;pos+=1){blob=nodes[pos];//
// Xml: get locale xml:lang
//
// Iterate over all locales, but for non-matching nodes,
// we set jurisdiction_preference only (processing of the
// chosen one will process the attribute there,
// separately.
if(!foundLocale&&myxml.getAttributeValue(blob,'lang','xml')===lang_in){locale=blob;foundLocale=true;}else{var lang=myxml.getAttributeValue(blob,'lang','xml');var style_options=myxml.getNodesByName(blob,'style-options');if(lang&&style_options&&style_options.length){var jurispref=myxml.getAttributeValue(style_options[0],'jurisdiction-preference');if(jurispref){if(!this.locale[lang]){this.locale[lang]={opts:{}};}this.locale[lang].opts["jurisdiction-preference"]=jurispref.split(/\s+/);}}}}}//
// Xml: get a list of any cs:type nodes within locale
//
nodes=myxml.getNodesByName(locale,'type');for(i=0,ilen=myxml.numberofnodes(nodes);i<ilen;i+=1){var typenode=nodes[i];var type=myxml.getAttributeValue(typenode,'name');var gender=myxml.getAttributeValue(typenode,'gender');this.opt.gender[type]=gender;}//
// Xml: get a list of term nodes within locale
//
// If we are setting CSL 1.0.1 ordinals inside a style, wipe the
// slate clean and start over.
var hasCslOrdinals101=myxml.getNodesByName(locale,'term','ordinal').length;if(hasCslOrdinals101){for(var key in this.locale[lang_out].ord.keys){delete this.locale[lang_out].terms[key];}this.locale[lang_out].ord={"1.0.1":false,keys:{}};}nodes=myxml.getNodesByName(locale,'term');// Collect ordinals info as for 1.0.1, but save only if 1.0.1 toggle triggers
var ordinals101={"last-digit":{},"last-two-digits":{},"whole-number":{}};var ordinals101_toggle=false;var genderized_terms={};for(pos=0,len=myxml.numberofnodes(nodes);pos<len;pos+=1){term=nodes[pos];//
// Xml: get string value of attribute
//
termname=myxml.getAttributeValue(term,'name');if(termname==="sub verbo"){termname="sub-verbo";}if(termname.slice(0,7)==="ordinal"){if(termname==="ordinal"){ordinals101_toggle=true;}else{var match=myxml.getAttributeValue(term,'match');var termstub=termname.slice(8);var genderform=myxml.getAttributeValue(term,'gender-form');if(!genderform){genderform="neuter";}if(!match){match="last-two-digits";if(termstub.slice(0,1)==="0"){match="last-digit";}}if(termstub.slice(0,1)==="0"){termstub=termstub.slice(1);}if(!ordinals101[match][termstub]){ordinals101[match][termstub]={};}ordinals101[match][termstub][genderform]=termname;}this.locale[lang_out].ord.keys[termname]=true;}if("undefined"===typeof this.locale[lang_out].terms[termname]){this.locale[lang_out].terms[termname]={};}form="long";genderform=false;//
// Xml: get string value of form attribute, if any
//
if(myxml.getAttributeValue(term,'form')){form=myxml.getAttributeValue(term,'form');}//
// Xml: get string value of gender attribute, if any
// 
if(myxml.getAttributeValue(term,'gender-form')){genderform=myxml.getAttributeValue(term,'gender-form');}//
// Xml: set global gender assignment for variable associated
// with term name
// 
if(myxml.getAttributeValue(term,'gender')){this.locale[lang_out]["noun-genders"][termname]=myxml.getAttributeValue(term,'gender');}// Work on main segment or gender-specific sub-segment as appropriate
if(genderform){this.locale[lang_out].terms[termname][genderform]={};this.locale[lang_out].terms[termname][genderform][form]=[];target=this.locale[lang_out].terms[termname][genderform];genderized_terms[termname]=true;}else{this.locale[lang_out].terms[termname][form]=[];target=this.locale[lang_out].terms[termname];}//
// Xml: test of existence of node
//
if(myxml.numberofnodes(myxml.getNodesByName(term,'multiple'))){//
// Xml: get string value of attribute, plus
// Xml: get string value of node content
//
target[form][0]=myxml.getNodeValue(term,'single');if(target[form][0].indexOf("%s")>-1){this.opt.hasPlaceholderTerm=true;}//
// Xml: get string value of attribute, plus
// Xml: get string value of node content
//
target[form][1]=myxml.getNodeValue(term,'multiple');if(target[form][1].indexOf("%s")>-1){this.opt.hasPlaceholderTerm=true;}}else{//
// Xml: get string value of attribute, plus
// Xml: get string value of node content
//
target[form]=myxml.getNodeValue(term);if(target[form].indexOf("%s")>-1){this.opt.hasPlaceholderTerm=true;}}}if(!this.locale[lang_out].terms.supplement){this.locale[lang_out].terms.supplement={};}if(!this.locale[lang_out].terms.supplement["long"]){this.locale[lang_out].terms.supplement["long"]=["supplement","supplements"];}// If locale had a CSL 1.0.1-style ordinal definition, install the logic object
// and iterate over gendered terms, filling in default values for use by getTerm.
if(ordinals101_toggle){for(var ikey in genderized_terms){var gender_segments={};var form_segments=0;for(var jkey in this.locale[lang_out].terms[ikey]){if(["masculine","feminine"].indexOf(jkey)>-1){gender_segments[jkey]=this.locale[lang_out].terms[ikey][jkey];}else{form_segments+=1;}}if(!form_segments){if(gender_segments.feminine){// Link each feminine form segment to default
// (no need to filter, these will not have gender segments mixed in)
for(var jkey in gender_segments.feminine){this.locale[lang_out].terms[ikey][jkey]=gender_segments.feminine[jkey];}}else if(gender_segments.masculine){// Otherwise link each masculine form segment to default 
for(var jkey in gender_segments.masculine){this.locale[lang_out].terms[ikey][jkey]=gender_segments.masculine[jkey];}}}}this.locale[lang_out].ord['1.0.1']=ordinals101;}// Iterate over main segments, and fill in any holes in gender-specific data
// sub-segments
for(termname in this.locale[lang_out].terms){for(i=0,ilen=2;i<ilen;i+=1){genderform=CSL.GENDERS[i];if(this.locale[lang_out].terms[termname][genderform]){for(form in this.locale[lang_out].terms[termname]){if(!this.locale[lang_out].terms[termname][genderform][form]){this.locale[lang_out].terms[termname][genderform][form]=this.locale[lang_out].terms[termname][form];}}}}}//
// Xml: get list of nodes by node type
//
nodes=myxml.getNodesByName(locale,'style-options');for(pos=0,len=myxml.numberofnodes(nodes);pos<len;pos+=1){if(true){styleopts=nodes[pos];//
// Xml: get list of attributes on a node
//
attributes=myxml.attributes(styleopts);for(attrname in attributes){if(attributes.hasOwnProperty(attrname)){if(attrname==="@punctuation-in-quote"||attrname==="@limit-day-ordinals-to-day-1"){if(attributes[attrname]==="true"){// trim off leading @
this.locale[lang_out].opts[attrname.slice(1)]=true;}else{// trim off leading @
this.locale[lang_out].opts[attrname.slice(1)]=false;}}else if(attrname==="@jurisdiction-preference"){var jurisdiction_preference=attributes[attrname].split(/\s+/);this.locale[lang_out].opts[attrname.slice(1)]=jurisdiction_preference;}else if(attrname==="@skip-words"){var skip_words=attributes[attrname].split(/\s*,\s*/);this.locale[lang_out].opts[attrname.slice(1)]=skip_words;}else if(attrname==="@leading-noise-words"){var val=attributes[attrname].split(/\s*,\s*/);this.locale[lang_out].opts["leading-noise-words"]=val;}else if(attrname==="@name-as-sort-order"){// Fallback is okay here.
this.locale[lang_out].opts["name-as-sort-order"]={};var lst=attributes[attrname].split(/\s+/);for(var i=0,ilen=lst.length;i<ilen;i+=1){this.locale[lang_out].opts["name-as-sort-order"][lst[i]]=true;}}else if(attrname==="@name-as-reverse-order"){// Fallback is okay here.
this.locale[lang_out].opts["name-as-reverse-order"]={};var lst=attributes[attrname].split(/\s+/);for(var i=0,ilen=lst.length;i<ilen;i+=1){this.locale[lang_out].opts["name-as-reverse-order"][lst[i]]=true;}}else if(attrname==="@name-never-short"){// Here too.
this.locale[lang_out].opts["name-never-short"]={};var lst=attributes[attrname].split(/\s+/);for(var i=0,ilen=lst.length;i<ilen;i+=1){this.locale[lang_out].opts["name-never-short"][lst[i]]=true;}}}}}}//
// Xml: get list of nodes by type
//
nodes=myxml.getNodesByName(locale,'date');for(pos=0,len=myxml.numberofnodes(nodes);pos<len;pos+=1){if(true){var date=nodes[pos];//
// Xml: get string value of attribute
//
this.locale[lang_out].dates[myxml.getAttributeValue(date,"form")]=date;}}//
// Xml: get list of nodes by node type
//
CSL.SET_COURT_CLASSES(this,lang_out,myxml,locale);};CSL.getLocaleNames=function(myxml,preferredLocale){var stylexml=CSL.setupXml(myxml);function extendLocaleList(localeList,locale){var forms=["base","best"];if(locale){var normalizedLocale=CSL.localeResolve(locale);for(var i=0,ilen=forms.length;i<ilen;i++){if(normalizedLocale[forms[i]]&&localeList.indexOf(normalizedLocale[forms[i]])===-1){localeList.push(normalizedLocale[forms[i]]);}}}}var localeIDs=["en-US"];function sniffLocaleOnOneNodeName(nodeName){var nodes=stylexml.getNodesByName(stylexml.dataObj,nodeName);for(var i=0,ilen=nodes.length;i<ilen;i++){var nodeLocales=stylexml.getAttributeValue(nodes[i],"locale");if(nodeLocales){nodeLocales=nodeLocales.split(/ +/);for(var j=0,jlen=nodeLocales.length;j<jlen;j++){this.extendLocaleList(localeIDs,nodeLocales[j]);}}}}extendLocaleList(localeIDs,preferredLocale);var styleNode=stylexml.getNodesByName(stylexml.dataObj,"style")[0];var defaultLocale=stylexml.getAttributeValue(styleNode,"default-locale");extendLocaleList(localeIDs,defaultLocale);var nodeNames=["layout","if","else-if","condition"];for(var i=0,ilen=nodeNames.length;i<ilen;i++){sniffLocaleOnOneNodeName(stylexml,localeIDs,nodeNames[i]);}return localeIDs;};/*global CSL: true */CSL.Node={};CSL.Node.bibliography={build:function(state,target){if(this.tokentype===CSL.START){state.build.area="bibliography";state.build.root="bibliography";state.build.extension="";var func=function(state){state.tmp.area="bibliography";state.tmp.root="bibliography";state.tmp.extension="";};this.execs.push(func);}target.push(this);}};/*global CSL: true */CSL.Node.choose={build:function(state,target){var func;if(this.tokentype===CSL.START){//open condition
func=function(state){state.tmp.jump.push(undefined,CSL.LITERAL);};}if(this.tokentype===CSL.END){//close condition
func=function(state){state.tmp.jump.pop();};}this.execs.push(func);target.push(this);},configure:function(state,pos){if(this.tokentype===CSL.END){state.configure.fail.push(pos);state.configure.succeed.push(pos);}else{state.configure.fail.pop();state.configure.succeed.pop();}}};/*global CSL: true */CSL.Node.citation={build:function(state,target){if(this.tokentype===CSL.START){state.build.area="citation";state.build.root="citation";state.build.extension="";var func=function(state){state.tmp.area="citation";state.tmp.root="citation";state.tmp.extension="";};this.execs.push(func);/*
            state.build.root = "citation";

            OK state.fixOpt(this, "names-delimiter", "delimiter");
            OK state.fixOpt(this, "name-delimiter", "delimiter");
            OK state.fixOpt(this, "name-form", "form");
            OK state.fixOpt(this, "and", "and");
            OK state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
            OK state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
            OK state.fixOpt(this, "initialize-with", "initialize-with");
            OK state.fixOpt(this, "initialize", "initialize");
            OK state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
            OK state.fixOpt(this, "sort-separator", "sort-separator");

            OK state.fixOpt(this, "et-al-min", "et-al-min");
            OK state.fixOpt(this, "et-al-use-first", "et-al-use-first");
            OK state.fixOpt(this, "et-al-use-last", "et-al-use-last");
            state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
            state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
*/}if(this.tokentype===CSL.END){// Open an extra key at first position for use in
// grouped sorts.
// print("in cs:citation END");
state.opt.grouped_sort=state.opt.xclass==="in-text"&&state.citation.opt.collapse&&state.citation.opt.collapse.length||state.citation.opt.cite_group_delimiter&&state.citation.opt.cite_group_delimiter.length&&state.opt.update_mode!==CSL.POSITION&&state.opt.update_mode!==CSL.NUMERIC;if(state.opt.grouped_sort&&state.citation_sort.opt.sort_directions.length){var firstkey=state.citation_sort.opt.sort_directions[0].slice();//print("extending sort keys "+state.citation_sort.opt.sort_directions+" with "+firstkey);
state.citation_sort.opt.sort_directions=[firstkey].concat(state.citation_sort.opt.sort_directions);// print("new key directions in effect: "+state.citation_sort.opt.sort_directions);
}// print("creating new comparifier");
state.citation.srt=new CSL.Registry.Comparifier(state,"citation_sort");}target.push(this);}};/*global CSL: true */CSL.Node["#comment"]={// This is a comment in the CSL file.
build:function(){// Save some space in the log files -- no need to mention this, really.
// CSL.debug("CSL processor warning: comment node reached");
}};/*global CSL: true */CSL.Node.date={build:function(state,target){var func,date_obj,len,pos,part,dpx,parts,mypos,start,end;if(this.tokentype===CSL.START||this.tokentype===CSL.SINGLETON){// used to collect rendered date part names in node_datepart,
// for passing through to node_key, for use in dates embedded
// in macros
state.dateput.string(state,state.dateput.queue);state.tmp.date_token=CSL.Util.cloneToken(this);state.tmp.date_token.strings.prefix="";state.tmp.date_token.strings.suffix="";state.dateput.openLevel(this);state.build.date_parts=[];state.build.date_variables=this.variables;if(!state.build.extension){CSL.Util.substituteStart.call(this,state,target);}if(state.build.extension){func=CSL.dateMacroAsSortKey;}else{func=function(state,Item,item){var dp;state.tmp.element_rendered_ok=false;state.tmp.donesies=[];state.tmp.dateparts=[];dp=[];//if (this.variables.length && Item[this.variables[0]]){
if(this.variables.length&&!(state.tmp.just_looking&&this.variables[0]==="accessed")){date_obj=Item[this.variables[0]];if("undefined"===typeof date_obj){date_obj={"date-parts":[[0]]};if(state.opt.development_extensions.locator_date_and_revision){if(item&&this.variables[0]==="locator-date"&&item["locator-date"]){date_obj=item["locator-date"];}}}state.tmp.date_object=date_obj;//
// Call a function here to analyze the
// data and set the name of the date-part that
// should collapse for this range, if any.
//
// (1) build a filtered list, in y-m-d order,
// consisting only of items that are (a) in the
// date-parts and (b) in the *_end data.
// (note to self: remember that season is a
// fallback var when month and day are empty)
//if ("undefined" === typeof this.dateparts) {
//    this.dateparts = ["year", "month", "day"];
//}
len=this.dateparts.length;for(pos=0;pos<len;pos+=1){part=this.dateparts[pos];if("undefined"!==typeof state.tmp.date_object[part+"_end"]){dp.push(part);}else if(part==="month"&&"undefined"!==typeof state.tmp.date_object.season_end){dp.push(part);}}dpx=[];parts=["year","month","day"];len=parts.length;for(pos=0;pos<len;pos+=1){if(dp.indexOf(parts[pos])>-1){dpx.push(parts[pos]);}}dp=dpx.slice();//
// (2) Reverse the list and step through in
// reverse order, popping each item if the
// primary and *_end data match.
mypos=2;len=dp.length;for(pos=0;pos<len;pos+=1){part=dp[pos];start=state.tmp.date_object[part];end=state.tmp.date_object[part+"_end"];if(start!==end){mypos=pos;break;}}//
// (3) When finished, the first item in the
// list, if any, is the date-part where
// the collapse should occur.
// XXXXX: was that it?
state.tmp.date_collapse_at=dp.slice(mypos);//
// The collapse itself will be done by appending
// string output for the date, less suffix,
// placing a delimiter on output, then then
// doing the *_end of the range, dropping only
// the prefix.  That should give us concise expressions
// of ranges.
//
// Numeric dates should not collapse, though,
// and should probably use a slash delimiter.
// Scope for configurability will remain (all over
// the place), but this will do to get this feature
// started.
//
}else{state.tmp.date_object=false;}};}this.execs.push(func);// newoutput
func=function(state,Item){if(!Item[this.variables[0]]){return;}state.output.startTag("date",this);if(this.variables[0]==="issued"&&(Item.type==="legal_case"||Item.type==="legislation")&&state.opt.disable_duplicate_year_suppression.indexOf(Item.country)===-1&&!state.tmp.extension&&""+Item["collection-number"]===""+state.tmp.date_object.year&&this.dateparts.length===1&&this.dateparts[0]==="year"){// Set up to (maybe) suppress the year if we're not sorting, and
// it's the same as the collection-number, and we would render
// only the year, with not month or day, and this is a legal_case item.
// We save a pointer to the blob parent and its position here. The
// blob will be popped from output if at the end of processing for
// this cite we find that we have rendered the collection-number
// variable also.
for(var key in state.tmp.date_object){if(state.tmp.date_object.hasOwnProperty(key)){if(key.slice(0,4)==="year"){state.tmp.issued_date={};var lst=state.output.current.mystack.slice(-2)[0].blobs;state.tmp.issued_date.list=lst;state.tmp.issued_date.pos=lst.length-1;}}}}};this.execs.push(func);}if(!state.build.extension&&(this.tokentype===CSL.END||this.tokentype===CSL.SINGLETON)){// mergeoutput
func=function(state,Item){if(!Item[this.variables[0]]){return;}state.output.endTag();};this.execs.push(func);}target.push(this);if(this.tokentype===CSL.END||this.tokentype===CSL.SINGLETON){if(!state.build.extension){CSL.Util.substituteEnd.call(this,state,target);}}}};/*global CSL: true */CSL.Node["date-part"]={build:function(state,target){var func,pos,len,first_date,value,value_end,real,have_collapsed,invoked,precondition,known_year,bc,ad,bc_end,ad_end,ready,curr,dcurr,number,num,formatter,item;if(!this.strings.form){this.strings.form="long";}// used in node_date, to send a list of rendering date parts
// to node_key, for dates embedded in macros.
state.build.date_parts.push(this.strings.name);//
// Set delimiter here, if poss.
//
var date_variable=state.build.date_variables[0];function formatAndStrip(myform,gender,val){if(!val){return val;}val=""+CSL.Util.Dates[this.strings.name][myform](state,val,gender,this.default_locale);if("month"===this.strings.name){if(state.tmp.strip_periods){val=val.replace(/\./g,"");}else{for(var i=0,ilen=this.decorations.length;i<ilen;i+=1){if("@strip-periods"===this.decorations[i][0]&&"true"===this.decorations[i][1]){val=val.replace(/\./g,"");break;}}}}return val;}func=function(state,Item){if(!state.tmp.date_object){return;}else{state.tmp.probably_rendered_something=true;}var last_string_output="";first_date=true;value="";value_end="";state.tmp.donesies.push(this.strings.name);// Render literal only when year is included in date output
if(state.tmp.date_object.literal&&"year"===this.strings.name){last_string_output=state.tmp.date_object.literal;state.output.append(state.tmp.date_object.literal,this);}if(state.tmp.date_object){value=state.tmp.date_object[this.strings.name];value_end=state.tmp.date_object[this.strings.name+"_end"];}if("year"===this.strings.name&&value===0&&!state.tmp.suppress_decorations){value=false;}real=!state.tmp.suppress_decorations;have_collapsed=state.tmp.have_collapsed;invoked=state[state.tmp.area].opt.collapse==="year-suffix"||state[state.tmp.area].opt.collapse==="year-suffix-ranged";precondition=state.opt["disambiguate-add-year-suffix"];if(real&&precondition&&invoked){state.tmp.years_used.push(value);known_year=state.tmp.last_years_used.length>=state.tmp.years_used.length;if(known_year&&have_collapsed){if(state.tmp.last_years_used[state.tmp.years_used.length-1]===value){value=false;}}}if("undefined"!==typeof value){bc=false;ad=false;bc_end=false;ad_end=false;if("year"===this.strings.name){if(parseInt(value,10)<500&&parseInt(value,10)>0){ad=state.getTerm("ad");}if(parseInt(value,10)<0){bc=state.getTerm("bc");value=parseInt(value,10)*-1;}if(value_end){if(parseInt(value_end,10)<500&&parseInt(value_end,10)>0){ad_end=state.getTerm("ad");}if(parseInt(value_end,10)<0){bc_end=state.getTerm("bc");value_end=parseInt(value_end,10)*-1;}}}// For gendered locales
var monthnameid=""+state.tmp.date_object.month;while(monthnameid.length<2){monthnameid="0"+monthnameid;}monthnameid="month-"+monthnameid;var gender=state.locale[state.opt.lang]["noun-genders"][monthnameid];if(this.strings.form){var myform=this.strings.form;var myform_end=this.strings.form;if(this.strings.name==="day"){if(myform==="ordinal"&&state.locale[state.opt.lang].opts["limit-day-ordinals-to-day-1"]){if(value!=1){myform="numeric";}if(value_end!=1){myform_end="numeric";}}}value=formatAndStrip.call(this,myform,gender,value);value_end=formatAndStrip.call(this,myform_end,gender,value_end);}state.output.openLevel("empty");if(state.tmp.date_collapse_at.length){//state.output.startTag(this.strings.name,this);
ready=true;len=state.tmp.date_collapse_at.length;for(pos=0;pos<len;pos+=1){item=state.tmp.date_collapse_at[pos];if(state.tmp.donesies.indexOf(item)===-1){ready=false;break;}}if(ready){if(""+value_end!=="0"){if(state.dateput.queue.length===0){first_date=true;}// OK! So if the actual data has no month, day or season,
// and we reach this block, then we can combine the dates
// to a string, run minimial-two, and output the trailing
// year right here. No impact on other functionality.
if(state.opt["year-range-format"]&&state.opt["year-range-format"]!=="expanded"&&!state.tmp.date_object.day&&!state.tmp.date_object.month&&!state.tmp.date_object.season&&this.strings.name==="year"&&value&&value_end){// second argument adjusts collapse as required for years
// See OSCOLA section 1.3.2
value_end=state.fun.year_mangler(value+"-"+value_end,true);var range_delimiter=state.getTerm("year-range-delimiter");value_end=value_end.slice(value_end.indexOf(range_delimiter)+1);}last_string_output=value_end;state.dateput.append(value_end,this);if(first_date){state.dateput.current.value().blobs[0].strings.prefix="";}}last_string_output=value;state.output.append(value,this);curr=state.output.current.value();curr.blobs[curr.blobs.length-1].strings.suffix="";if(this.strings["range-delimiter"]){state.output.append(this.strings["range-delimiter"]);}else{state.output.append(state.getTerm("year-range-delimiter"),"empty");}state.dateput.closeLevel();dcurr=state.dateput.current.value();curr.blobs=curr.blobs.concat(dcurr);// This may leave the stack pointer on a lower level.
// It's not a problem because the stack will be clobbered
// when the queue is initialized by the next cs:date node.
state.dateput.string(state,state.dateput.queue);state.dateput.openLevel(state.tmp.date_token);state.tmp.date_collapse_at=[];}else{last_string_output=value;state.output.append(value,this);// print("collapse_at: "+state.tmp.date_collapse_at);
if(state.tmp.date_collapse_at.indexOf(this.strings.name)>-1){//
// Use ghost dateput queue
//
if(""+value_end!=="0"){//
// XXXXX: It's a workaround.  It's ugly.
// There's another one above.
//
if(state.dateput.queue.length===0){first_date=true;}state.dateput.openLevel("empty");last_string_output=value_end;state.dateput.append(value_end,this);if(first_date){state.dateput.current.value().blobs[0].strings.prefix="";}if(bc){last_string_output=bc;state.dateput.append(bc);}if(ad){last_string_output=ad;state.dateput.append(ad);}state.dateput.closeLevel();}}}}else{last_string_output=value;state.output.append(value,this);}if(bc){last_string_output=bc;state.output.append(bc);}if(ad){last_string_output=ad;state.output.append(ad);}state.output.closeLevel();//state.output.endTag();
}else if("month"===this.strings.name){// XXX The simpler solution here will be to
// directly install season and season_end on
// month, with a value of 13, 14, 15, 16, or
// (to allow correct ranging with Down Under
// dates) 17 or 18.  That will allow ranging
// to take place in the normal way.  With this
// "approach", it doesn't.
//
// No value for this target variable
//
if(state.tmp.date_object.season){value=""+state.tmp.date_object.season;if(value&&value.match(/^[1-4]$/)){// XXXXXXXXXXXXXXXXXXX was replace([false, false, true]);
//state.tmp.group_context.replace([false, false, true]);
state.tmp.group_context.tip.variable_success=true;last_string_output="winter";state.output.append(state.getTerm("season-0"+value),this);}else if(value){last_string_output=value;state.output.append(value,this);}}}state.tmp.value=[];if(Item[date_variable]&&(value||state.tmp.have_collapsed)&&!state.opt.has_year_suffix&&"year"===this.strings.name&&!state.tmp.just_looking){if(state.registry.registry[Item.id]&&state.registry.registry[Item.id].disambig.year_suffix!==false&&!state.tmp.has_done_year_suffix){state.tmp.has_done_year_suffix=true;last_string_output="x";num=parseInt(state.registry.registry[Item.id].disambig.year_suffix,10);// first argument is for number particle [a-zA-Z], never present on dates
number=new CSL.NumericBlob(false,num,this,Item.id);this.successor_prefix=state[state.build.area].opt.layout_delimiter;this.splice_prefix=state[state.build.area].opt.layout_delimiter;formatter=new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);number.setFormatter(formatter);if(state[state.tmp.area].opt.collapse==="year-suffix-ranged"){number.range_prefix=state.getTerm("citation-range-delimiter");}if(state[state.tmp.area].opt.cite_group_delimiter){number.successor_prefix=state[state.tmp.area].opt.cite_group_delimiter;}else if(state[state.tmp.area].opt["year-suffix-delimiter"]){number.successor_prefix=state[state.tmp.area].opt["year-suffix-delimiter"];}else{number.successor_prefix=state[state.tmp.area].opt.layout_delimiter;}number.UGLY_DELIMITER_SUPPRESS_HACK=true;state.output.append(number,"literal");}}if(last_string_output&&!state.tmp.group_context.tip.condition){state.tmp.just_did_number=last_string_output.match(/[0-9]$/);if(state.output.current.tip.strings.suffix){state.tmp.just_did_number=false;}}};this.execs.push(func);target.push(this);}};/*global CSL: true */CSL.Node["else-if"]={//
// these function are the same as those in if, might just clone
build:function(state,target){CSL.Conditions.TopNode.call(this,state,target);target.push(this);},configure:function(state,pos){CSL.Conditions.Configure.call(this,state,pos);}};/*global CSL: true */CSL.Node["else"]={build:function(state,target){target.push(this);},configure:function(state,pos){if(this.tokentype===CSL.START){state.configure.fail[state.configure.fail.length-1]=pos;}}};/*global CSL: true */CSL.Node["et-al"]={build:function(state,target){if(state.build.area==="citation"||state.build.area==="bibliography"){var func=function(state){state.tmp.etal_node=this;if("string"===typeof this.strings.term){state.tmp.etal_term=this.strings.term;}};this.execs.push(func);}target.push(this);}};/*global CSL: true */CSL.Node.group={build:function(state,target,realGroup){var func,execs;this.realGroup=realGroup;if(this.tokentype===CSL.START){CSL.Util.substituteStart.call(this,state,target);if(state.build.substitute_level.value()){state.build.substitute_level.replace(state.build.substitute_level.value()+1);}if(!this.juris){target.push(this);}// newoutput
func=function(state){state.output.startTag("group",this);if(this.strings.label_form_override){if(!state.tmp.group_context.tip.label_form){state.tmp.group_context.tip.label_form=this.strings.label_form_override;}}if(this.strings.label_capitalize_if_first_override){if(!state.tmp.group_context.tip.label_capitalize_if_first){state.tmp.group_context.tip.label_capitalize_if_first=this.strings.label_capitalize_if_first_override;}}if(this.realGroup){if(state.tmp.group_context.tip.condition){CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,this.strings.prefix,null,this);}var condition=false;var force_suppress=false;// XXX Can we do something better for length here?
if(state.tmp.group_context.mystack.length){state.output.current.value().parent=state.tmp.group_context.tip.output_tip;}// fieldcontextflag
var label_form=state.tmp.group_context.tip.label_form;if(!label_form){label_form=this.strings.label_form_override;}var label_capitalize_if_first=state.tmp.group_context.tip.label_capitalize_if_first;if(!label_capitalize_if_first){label_capitalize_if_first=this.strings.label_capitalize_if_first;}if(state.tmp.group_context.tip.condition){condition=state.tmp.group_context.tip.condition;force_suppress=state.tmp.group_context.tip.force_suppress;//force_suppress: false;
}else if(this.strings.reject){condition={test:this.strings.reject,not:true};}else if(this.strings.require){condition={test:this.strings.require,not:false};}var context={old_term_predecessor:state.tmp.term_predecessor,term_intended:false,variable_attempt:false,variable_success:false,variable_success_parent:state.tmp.group_context.tip.variable_success,output_tip:state.output.current.tip,label_form:label_form,label_static:state.tmp.group_context.tip.label_static,label_capitalize_if_first:label_capitalize_if_first,parallel_delimiter_override:this.strings.set_parallel_delimiter_override,parallel_delimiter_override_on_suppress:this.strings.set_parallel_delimiter_override_on_suppress,condition:condition,force_suppress:force_suppress,done_vars:state.tmp.group_context.tip.done_vars.slice()};if(this.non_parallel){var non_parallel=state.tmp.group_context.tip.non_parallel;if(!non_parallel){non_parallel={};}Object.assign(non_parallel,this.non_parallel);context.non_parallel=non_parallel;}if(this.parallel_first){var parallel_first=state.tmp.group_context.tip.parallel_first;if(!parallel_first){parallel_first={};}Object.assign(parallel_first,this.parallel_first);context.parallel_first=parallel_first;}if(this.parallel_last){var parallel_last=state.tmp.group_context.tip.parallel_last;if(!parallel_last){parallel_last={};}Object.assign(parallel_last,this.parallel_last);context.parallel_last=parallel_last;}if(state.tmp.abbrev_trimmer&&state.tmp.abbrev_trimmer.LAST_TO_FIRST&&context.parallel_last){if(!context.parallel_first){context.parallel_first={};}for(var varname in state.tmp.abbrev_trimmer.LAST_TO_FIRST){if(context.parallel_last[varname]){context.parallel_first[varname]=true;delete context.parallel_last[varname];}}}/*
                    if(this.parallel_last_override) {
                        var parallel_last_override = state.tmp.group_context.tip.parallel_last_override;
                        if (!parallel_last_override) {
                            parallel_last_override = {};
                        }
                        Object.assign(parallel_last_override, this.parallel_last_override);
                        context.parallel_last_override = parallel_last_override;
                    }
                     */state.tmp.group_context.push(context);if(state.tmp.abbrev_trimmer&&this.parallel_last_to_first){if(!state.tmp.abbrev_trimmer.LAST_TO_FIRST){state.tmp.abbrev_trimmer.LAST_TO_FIRST={};}for(var varname in this.parallel_last_to_first){state.tmp.abbrev_trimmer.LAST_TO_FIRST[varname]=true;}}//if (!state.tmp.just_looking) {
//    print("       flags="+JSON.stringify(state.tmp.group_context.tip, params))
//}
}};//
// Paranoia.  Assure that this init function is the first executed.
execs=[];execs.push(func);this.execs=execs.concat(this.execs);// "Special handling" for nodes that contain only
// publisher and place, with no affixes. For such
// nodes only, parallel publisher/place pairs
// will be parsed out and properly joined, piggybacking on
// join parameters set on cs:citation or cs:bibliography.
if(this.strings["has-publisher-and-publisher-place"]){// Pass variable string values to the closing
// tag via a global, iff they conform to expectations.
state.build["publisher-special"]=true;if(this.strings["subgroup-delimiter"]){// Set the handling function only if name-delimiter
// is set on the parent cs:citation or cs:bibliography
// node.
func=function(state,Item){if(Item.publisher&&Item["publisher-place"]){var publisher_lst=Item.publisher.split(/;\s*/);var publisher_place_lst=Item["publisher-place"].split(/;\s*/);if(publisher_lst.length>1&&publisher_lst.length===publisher_place_lst.length){state.publisherOutput=new CSL.PublisherOutput(state,this);state.publisherOutput["publisher-list"]=publisher_lst;state.publisherOutput["publisher-place-list"]=publisher_place_lst;}}};this.execs.push(func);}}if(this.juris){// "Special handling" for jurisdiction macros
// We try to instantiate these as standalone token lists.
// If available, the token list is executed,
// the result is written directly into output,
// and control returns here.
// So we'll have something like this:
// * expandMacro() in util_node.js flags juris- macros
//   on build. [DONE]
// * Those are picked up here, and
//   - A runtime function attempts to fetch and instantiate
//     the macros in separate token lists under a segment
//     opened for the jurisdiction. We assume that the
//     jurisdiction has a full set of macros. That will need
//     to be enforced by validation. [DONE HERE, function is TODO]
//   - Success or failure is marked in a runtime flag object
//     (in citeproc.opt). [DONE]
//   - After the instantiation function comes a test, for
//     juris- macros only, which either runs diverted code,
//     or proceeds as per normal through the token list. [TODO]
// I think that's all there is to it.
// Code for fetching an instantiating?
var choose_start=new CSL.Token("choose",CSL.START);CSL.Node.choose.build.call(choose_start,state,target);var if_start=new CSL.Token("if",CSL.START);func=function(macroName){return function(Item,item){return CSL.INIT_JURISDICTION_MACROS(state,Item,item,macroName);};}(this.juris);if_start.tests?{}:if_start.tests=[];if_start.tests.push(func);if_start.test=state.fun.match.any(if_start,state,if_start.tests);target.push(if_start);var text_node=new CSL.Token("text",CSL.SINGLETON);func=function(state,Item,item){// This will run the juris- token list.
var itemItem=Item;if(item&&item["best-jurisdiction"]&&this.juris==="juris-locator"){itemItem=item;}var next=0;if(state.juris[itemItem["best-jurisdiction"]][this.juris]){while(next<state.juris[itemItem["best-jurisdiction"]][this.juris].length){next=CSL.tokenExec.call(state,state.juris[itemItem["best-jurisdiction"]][this.juris][next],Item,item);}}};text_node.juris=this.juris;text_node.execs.push(func);target.push(text_node);var if_end=new CSL.Token("if",CSL.END);CSL.Node["if"].build.call(if_end,state,target);var else_start=new CSL.Token("else",CSL.START);CSL.Node["else"].build.call(else_start,state,target);}}if(this.tokentype===CSL.END){// Unbundle and print publisher lists
// Same constraints on creating the necessary function here
// as above. The full content of the group formatting token
// is apparently not available on the closing tag here,
// hence the global flag on state.build.
if(state.build["publisher-special"]){state.build["publisher-special"]=false;func=function(state){if(state.publisherOutput){state.publisherOutput.render();state.publisherOutput=false;}};this.execs.push(func);}// quashnonfields
func=function(state,Item,item){if(!state.tmp.group_context.tip.condition){if(state.output.current.tip.strings.suffix){state.tmp.just_did_number=false;}}state.output.endTag();if(this.realGroup){var flags=state.tmp.group_context.pop();if(flags.parallel_delimiter_override){state.tmp.group_context.tip.parallel_delimiter_override=flags.parallel_delimiter_override;if(!state.tmp.just_looking&&state.registry.registry[Item.id].master){state.registry.registry[Item.id].parallel_delimiter_override=flags.parallel_delimiter_override;}}if(flags.parallel_delimiter_override_on_suppress){state.tmp.group_context.tip.parallel_delimiter_override_on_suppress=flags.parallel_delimiter_override_on_suppress;}if(state.tmp.area==="bibliography_sort"){var citationNumberIdx=flags.done_vars.indexOf("citation-number");if(this.strings.sort_direction&&citationNumberIdx>-1&&state.tmp.group_context.length()==1){if(this.strings.sort_direction===CSL.DESCENDING){state.bibliography_sort.opt.citation_number_sort_direction=CSL.DESCENDING;}else{state.bibliography_sort.opt.citation_number_sort_direction=CSL.ASCENDING;}flags.done_vars=flags.done_vars.slice(0,citationNumberIdx).concat(flags.done_vars.slice(citationNumberIdx+1));}}//var params = ["condition", "variable_success", "force_suppress","term_intended", "variable_attempt"]
//if (!state.tmp.just_looking) {
//    print("POP parent="+JSON.stringify(state.tmp.group_context.tip, params))
//    print("    flags="+JSON.stringify(flags, params));
//}
if(flags.condition){flags.force_suppress=CSL.EVALUATE_GROUP_CONDITION(state,flags);}if(state.tmp.group_context.tip.condition){state.tmp.group_context.tip.force_suppress=flags.force_suppress;}if(!flags.force_suppress&&(flags.variable_success||flags.term_intended&&!flags.variable_attempt)){if(!this.isJurisLocatorLabel){state.tmp.group_context.tip.variable_success=true;}var blobs=state.output.current.value().blobs;var pos=state.output.current.value().blobs.length-1;if(!state.tmp.just_looking&&(flags.non_parallel||flags.parallel_last||flags.parallel_first||flags.parallel_delimiter_override||flags.parallel_delimiter_override_on_suppress)){// flags.parallel_last
// flags.parallel_first
// Returns true ONLY if all variables listed on this group are repeats.
var hasRepeat=state.parallel.checkRepeats(flags);if(hasRepeat){if(blobs){blobs.pop();}}if(state.tmp.cite_index>0&&(hasRepeat||!flags.parallel_first&&!flags.parallel_last&&!flags.non_parallel)){//state.sys.print(`${state.tmp.cite_index} ${JSON.stringify(state.tmp.suppress_repeats, null, 2)}`)
var info=state.tmp.suppress_repeats[state.tmp.cite_index-1];if(hasRepeat&&flags.parallel_delimiter_override_on_suppress&&(info.SIBLING||info.ORPHAN)){state.output.queue.slice(-1)[0].parallel_delimiter=flags.parallel_delimiter_override_on_suppress;}else if(flags.parallel_delimiter_override&&info.SIBLING){state.output.queue.slice(-1)[0].parallel_delimiter=flags.parallel_delimiter_override;}}}}else{state.tmp.term_predecessor=flags.old_term_predecessor;state.tmp.group_context.tip.variable_attempt=flags.variable_attempt;if(flags.force_suppress&&!state.tmp.group_context.tip.condition){state.tmp.group_context.tip.variable_attempt=true;state.tmp.group_context.tip.variable_success=flags.variable_success_parent;}if(flags.force_suppress){// 2019-04-15
// This is removing variables done within the group we're leaveing from global
// done_vars? How does that make sense?
// Ah. This is a FAILURE. So removing from done_vars allows it to re-render
// later in the cite if desired.
// Currently no tests fail from removing the condition, but leaving it in.
for(var i=0,ilen=flags.done_vars.length;i<ilen;i++){var doneVar=flags.done_vars[i];for(var j=0,jlen=state.tmp.done_vars.length;j<jlen;j++){if(state.tmp.done_vars[j]===doneVar){state.tmp.done_vars=state.tmp.done_vars.slice(0,j).concat(state.tmp.done_vars.slice(j+1));}}}}if(state.output.current.value().blobs){state.output.current.value().blobs.pop();}}}};this.execs.push(func);if(this.juris){var else_end=new CSL.Token("else",CSL.END);CSL.Node["else"].build.call(else_end,state,target);var choose_end=new CSL.Token("choose",CSL.END);CSL.Node.choose.build.call(choose_end,state,target);}}if(this.tokentype===CSL.END){if(!this.juris){target.push(this);}if(state.build.substitute_level.value()){state.build.substitute_level.replace(state.build.substitute_level.value()-1);}CSL.Util.substituteEnd.call(this,state,target);}}};/*global CSL: true */CSL.Node["if"]={build:function(state,target){CSL.Conditions.TopNode.call(this,state,target);target.push(this);},configure:function(state,pos){CSL.Conditions.Configure.call(this,state,pos);}};CSL.Node["conditions"]={build:function(state){if(this.tokentype===CSL.START){state.tmp.conditions.addMatch(this.match);}if(this.tokentype===CSL.END){state.tmp.conditions.matchCombine();}}};CSL.Node["condition"]={build:function(state){if(this.tokentype===CSL.SINGLETON){var test=state.fun.match[this.match](this,state,this.tests);state.tmp.conditions.addTest(test);}}};CSL.Conditions={};CSL.Conditions.TopNode=function(state){var func;if(this.tokentype===CSL.START||this.tokentype===CSL.SINGLETON){if(this.locale){state.opt.lang=this.locale;}if(!this.tests||!this.tests.length){// Set up the condition compiler with our current context
state.tmp.conditions=new CSL.Conditions.Engine(state,this);}else{// The usual.
this.test=state.fun.match[this.match](this,state,this.tests);}if(state.build.substitute_level.value()===0){func=function(state){state.tmp.condition_counter++;};this.execs.push(func);}}if(this.tokentype===CSL.END||this.tokentype===CSL.SINGLETON){if(state.build.substitute_level.value()===0){func=function(state){state.tmp.condition_counter--;if(state.tmp.condition_lang_counter_arr.length>0){var counter=state.tmp.condition_lang_counter_arr.slice(-1)[0];if(counter===state.tmp.condition_counter){state.opt.lang=state.tmp.condition_lang_val_arr.pop();state.tmp.condition_lang_counter_arr.pop();}}if(this.locale_default){// Open output tag with locale marker
state.output.current.value().old_locale=this.locale_default;state.output.closeLevel("empty");state.opt.lang=this.locale_default;}};this.execs.push(func);}// closingjump
func=function(state){var next=this[state.tmp.jump.value()];return next;};this.execs.push(func);if(this.locale_default){state.opt.lang=this.locale_default;}}};CSL.Conditions.Configure=function(state,pos){if(this.tokentype===CSL.START){// jump index on failure
this.fail=state.configure.fail.slice(-1)[0];this.succeed=this.next;state.configure.fail[state.configure.fail.length-1]=pos;}else if(this.tokentype===CSL.SINGLETON){// jump index on failure
this.fail=this.next;this.succeed=state.configure.succeed.slice(-1)[0];state.configure.fail[state.configure.fail.length-1]=pos;}else{// jump index on success
this.succeed=state.configure.succeed.slice(-1)[0];this.fail=this.next;}};CSL.Conditions.Engine=function(state,token){this.token=token;this.state=state;};CSL.Conditions.Engine.prototype.addTest=function(test){this.token.tests?{}:this.token.tests=[];this.token.tests.push(test);};CSL.Conditions.Engine.prototype.addMatch=function(match){this.token.match=match;};CSL.Conditions.Engine.prototype.matchCombine=function(){this.token.test=this.state.fun.match[this.token.match](this.token,this.state,this.token.tests);};/*global CSL: true */CSL.Node.info={build:function(state){if(this.tokentype===CSL.START){state.build.skip="info";}else{state.build.skip=false;}}};/*global CSL: true */CSL.Node.institution={build:function(state,target){if([CSL.SINGLETON,CSL.START].indexOf(this.tokentype)>-1){var func=function(state){if("string"===typeof this.strings.delimiter){state.tmp.institution_delimiter=this.strings.delimiter;}else{state.tmp.institution_delimiter=state.tmp.name_delimiter;}// This is the same code for the same result as in node_name.js, 
// but when cs:institution comes on stream, it may produce
// different results.
if("text"===state.inheritOpt(this,"and")){this.and_term=state.getTerm("and","long",0);}else if("symbol"===state.inheritOpt(this,"and")){if(state.opt.development_extensions.expect_and_symbol_form){this.and_term=state.getTerm("and","symbol",0);}else{this.and_term="&";}}else if("none"===state.inheritOpt(this,"and")){this.and_term=state.tmp.institution_delimiter;}if("undefined"===typeof this.and_term&&state.tmp.and_term){// this.and_term = state.getTerm("and", "long", 0);
this.and_term=state.tmp.and_term;}if(CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)){this.and_prefix_single=" ";this.and_prefix_multiple=", ";if("string"===typeof state.tmp.institution_delimiter){this.and_prefix_multiple=state.tmp.institution_delimiter;}this.and_suffix=" ";}else{this.and_prefix_single="";this.and_prefix_multiple="";this.and_suffix="";}if(state.inheritOpt(this,"delimiter-precedes-last")==="always"){this.and_prefix_single=state.tmp.institution_delimiter;}else if(state.inheritOpt(this,"delimiter-precedes-last")==="never"){// Slightly fragile: could test for charset here to make
// this more certain.
if(this.and_prefix_multiple){this.and_prefix_multiple=" ";}}this.and={};if("undefined"!==typeof this.and_term){state.output.append(this.and_term,"empty",true);this.and.single=state.output.pop();this.and.single.strings.prefix=this.and_prefix_single;this.and.single.strings.suffix=this.and_suffix;state.output.append(this.and_term,"empty",true);this.and.multiple=state.output.pop();this.and.multiple.strings.prefix=this.and_prefix_multiple;this.and.multiple.strings.suffix=this.and_suffix;}else if("undefined"!==this.strings.delimiter){this.and.single=new CSL.Blob(state.tmp.institution_delimiter);this.and.single.strings.prefix="";this.and.single.strings.suffix="";this.and.multiple=new CSL.Blob(state.tmp.institution_delimiter);this.and.multiple.strings.prefix="";this.and.multiple.strings.suffix="";}state.nameOutput.institution=this;};this.execs.push(func);}target.push(this);},configure:function(state){if([CSL.SINGLETON,CSL.START].indexOf(this.tokentype)>-1){state.build.has_institution=true;}}};/*global CSL: true */CSL.Node["institution-part"]={build:function(state,target){var func;if("long"===this.strings.name){if(this.strings["if-short"]){func=function(state){state.nameOutput.institutionpart["long-with-short"]=this;};}else{func=function(state){state.nameOutput.institutionpart["long"]=this;};}}else if("short"===this.strings.name){func=function(state){state.nameOutput.institutionpart["short"]=this;};}this.execs.push(func);target.push(this);}};/*global CSL: true */CSL.Node.key={build:function(state,target){target=state[state.build.root+"_sort"].tokens;var func;var debug=false;var start_key=new CSL.Token("key",CSL.START);state.tmp.root=state.build.root;// The params object for build and runtime (tmp) really shouldn't have been separated.
// Oh, well.
start_key.strings["et-al-min"]=state.inheritOpt(this,"et-al-min");start_key.strings["et-al-use-first"]=state.inheritOpt(this,"et-al-use-first");start_key.strings["et-al-use-last"]=state.inheritOpt(this,"et-al-use-last");// initialize done vars
func=function(state){state.tmp.done_vars=[];};start_key.execs.push(func);// initialize output queue
func=function(state){state.output.openLevel("empty");};start_key.execs.push(func);// sort direction
var sort_direction=[];if(this.strings.sort_direction===CSL.DESCENDING){//print("sort: descending on "+state.tmp.area);
sort_direction.push(1);sort_direction.push(-1);}else{//print("sort: ascending");
sort_direction.push(-1);sort_direction.push(1);}state[state.build.area].opt.sort_directions.push(sort_direction);if(CSL.DATE_VARIABLES.indexOf(this.variables[0])>-1){state.build.date_key=true;}// et al init
func=function(state){state.tmp.sort_key_flag=true;//print("== key node function ==");
if(state.inheritOpt(this,"et-al-min")){state.tmp["et-al-min"]=state.inheritOpt(this,"et-al-min");}if(state.inheritOpt(this,"et-al-use-first")){state.tmp["et-al-use-first"]=state.inheritOpt(this,"et-al-use-first");}if("boolean"===typeof state.inheritOpt(this,"et-al-use-last")){state.tmp["et-al-use-last"]=state.inheritOpt(this,"et-al-use-last");//print("  set tmp et-al-use-last: "+this.strings["et-al-use-last"])
}};start_key.execs.push(func);target.push(start_key);//
// ops to initialize the key's output structures
if(this.variables.length){var variable=this.variables[0];if(CSL.NAME_VARIABLES.indexOf(variable)>-1){//
// Start tag
var names_start_token=new CSL.Token("names",CSL.START);names_start_token.tokentype=CSL.START;names_start_token.variables=this.variables;CSL.Node.names.build.call(names_start_token,state,target);//
// Name tag
var name_token=new CSL.Token("name",CSL.SINGLETON);name_token.tokentype=CSL.SINGLETON;name_token.strings["name-as-sort-order"]="all";name_token.strings["sort-separator"]=" ";name_token.strings["et-al-use-last"]=state.inheritOpt(this,"et-al-use-last");name_token.strings["et-al-min"]=state.inheritOpt(this,"et-al-min");name_token.strings["et-al-use-first"]=state.inheritOpt(this,"et-al-use-first");CSL.Node.name.build.call(name_token,state,target);//
// Institution tag
var institution_token=new CSL.Token("institution",CSL.SINGLETON);institution_token.tokentype=CSL.SINGLETON;CSL.Node.institution.build.call(institution_token,state,target);//
// End tag
var names_end_token=new CSL.Token("names",CSL.END);names_end_token.tokentype=CSL.END;CSL.Node.names.build.call(names_end_token,state,target);}else{var single_text=new CSL.Token("text",CSL.SINGLETON);single_text.strings.sort_direction=this.strings.sort_direction;single_text.dateparts=this.dateparts;if(CSL.NUMERIC_VARIABLES.indexOf(variable)>-1){// citation-number is virtualized. As a sort key it has no effect on registry
// sort order per se, but if set to DESCENDING, it reverses the sequence of numbers representing
// bib entries.
if(variable==="citation-number"){func=function(state,Item){if(state.tmp.area==="bibliography_sort"){if(this.strings.sort_direction===CSL.DESCENDING){state.bibliography_sort.opt.citation_number_sort_direction=CSL.DESCENDING;}else{state.bibliography_sort.opt.citation_number_sort_direction=CSL.ASCENDING;}}if(state.tmp.area==="citation_sort"&&state.bibliography_sort.tmp.citation_number_map){var num=state.bibliography_sort.tmp.citation_number_map[state.registry.registry[Item.id].seq];}else{var num=state.registry.registry[Item.id].seq;}if(num){// Code currently in util_number.js
num=CSL.Util.padding(""+num);}state.output.append(num,this);};}else{func=function(state,Item){var num=false;num=Item[variable];// XXX What if this is NaN?
if(num){// Code currently in util_number.js
num=CSL.Util.padding(num);}state.output.append(num,this);};}}else if(variable==="citation-label"){func=function(state,Item){var trigraph=state.getCitationLabel(Item);state.output.append(trigraph,this);};}else if(CSL.DATE_VARIABLES.indexOf(variable)>-1){func=CSL.dateAsSortKey;single_text.variables=this.variables;}else if("title"===variable){var abbrevfam="title";var abbrfall=false;var altvar=false;var transfall=true;func=state.transform.getOutputFunction(this.variables,abbrevfam,abbrfall,altvar,transfall);}else if("court-class"===variable){func=function(state,Item,item){CSL.INIT_JURISDICTION_MACROS(state,Item,item,"juris-main");// true is for sortKey mode
var cls=CSL.GET_COURT_CLASS(state,Item,true);state.output.append(cls,"empty");};}else{func=function(state,Item){var varval=Item[variable];state.output.append(varval,"empty");};}single_text.execs.push(func);target.push(single_text);}}else{// macro
//
// if it's not a variable, it's a macro
var token=new CSL.Token("text",CSL.SINGLETON);token.strings.sort_direction=this.strings.sort_direction;token.postponed_macro=this.postponed_macro;CSL.expandMacro.call(state,token,target);}//
// ops to output the key string result to an array go
// on the closing "key" tag before it is pushed.
// Do not close the level.
var end_key=new CSL.Token("key",CSL.END);// Eliminated at revision 1.0.159.
// Was causing non-fatal error "wanted empty but found group".
// Possible contributor to weird "PAGES" bug?
//func = function (state, Item) {
//state.output.closeLevel("empty");
//};
//end_key.execs.push(func);
// store key for use
func=function(state){var keystring=state.output.string(state,state.output.queue);if(state.sys.normalizeUnicode){keystring=state.sys.normalizeUnicode(keystring);}keystring=keystring?keystring.split(" ").join(state.opt.sort_sep)+state.opt.sort_sep:"";//SNIP-START
if(debug){CSL.debug("keystring: "+keystring+" "+typeof keystring);}//print("keystring: (" + keystring + ") " + typeof keystring + " " + state.tmp.area);
//SNIP-END
//state.sys.print("keystring: (" + keystring + ") " + typeof keystring + " " + state.tmp.area);
if(""===keystring){keystring=undefined;}if("string"!==typeof keystring){keystring=undefined;//state.tmp.empty_date = false;
}state[state[state.tmp.area].root+"_sort"].keys.push(keystring);state.tmp.value=[];};end_key.execs.push(func);// Set year-suffix key on anything that looks like a date
if(state.build.date_key){if(state.build.area==="citation"&&state.build.extension==="_sort"){// ascending sort always
state[state.build.area].opt.sort_directions.push([-1,1]);func=function(state,Item){// year-suffix Key
var year_suffix=state.registry.registry[Item.id].disambig.year_suffix;if(!year_suffix){year_suffix=0;}var key=CSL.Util.padding(""+year_suffix);state[state.tmp.area].keys.push(key);};end_key.execs.push(func);}state.build.date_key=false;}// reset key params
func=function(state){// state.tmp.name_quash = new Object();
// XXX This should work, should be necessary, but doesn't and isn't.
//state.output.closeLevel("empty");
state.tmp["et-al-min"]=undefined;state.tmp["et-al-use-first"]=undefined;state.tmp["et-al-use-last"]=undefined;state.tmp.sort_key_flag=false;};end_key.execs.push(func);target.push(end_key);}};/*global CSL: true */CSL.Node.label={build:function(state,target){if(this.strings.term){// Non-names labels
var func=function(state,Item,item){// Must accomplish this without touching strings
// shared with the calling application: "sub verbo"
// and "sub-verbo" must both pass, as they stand.
//if (item && item.label === "sub verbo") {
//    item.label = "sub-verbo";
//}
// This is abstracted away, because the same
// logic must be run in cs:names.
var termtxt=CSL.evaluateLabel(this,state,Item,item);if(item&&this.strings.term==="locator"){item.section_form_override=this.strings.form;}if(termtxt){state.tmp.group_context.tip.term_intended=true;}CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,termtxt,null,this);if(termtxt.indexOf("%s")===-1){// ^ Suppress output here if we have an embedded term
if(this.strings.capitalize_if_first){if(!state.tmp.term_predecessor&&!(state.opt["class"]==="in-text"&&state.tmp.area==="citation")){termtxt=CSL.Output.Formatters["capitalize-first"](state,termtxt);}}state.output.append(termtxt,this);}};this.execs.push(func);}else{if(!this.strings.form){this.strings.form="long";}// Names labels
// Picked up in names END
var namevars=state.build.names_variables[state.build.names_variables.length-1];var namelabels=state.build.name_label[state.build.name_label.length-1];for(var i=0,ilen=namevars.length;i<ilen;i+=1){if(!namelabels[namevars[i]]){namelabels[namevars[i]]={};}}if(!state.build.name_flag){for(var i=0,ilen=namevars.length;i<ilen;i+=1){namelabels[namevars[i]].before=this;}}else{for(var i=0,ilen=namevars.length;i<ilen;i+=1){namelabels[namevars[i]].after=this;}}}target.push(this);}};/*global CSL: true */CSL.Node.layout={build:function(state,target){var func,prefix_token,suffix_token,tok;function setSuffix(){if(state.build.area==="bibliography"){suffix_token=new CSL.Token("text",CSL.SINGLETON);func=function(state){// Suppress suffix on all but the last item in bibliography parallels
if(!state.tmp.parallel_and_not_last){var suffix;if(state.tmp.cite_affixes[state.tmp.area][state.tmp.last_cite_locale]){suffix=state.tmp.cite_affixes[state.tmp.area][state.tmp.last_cite_locale].suffix;}else{suffix=state.bibliography.opt.layout_suffix;}// If @display is used, layout suffix is placed on the last
// immediate child of the layout, which we assume will be a
// @display group node.
var topblob=state.output.current.value();if(state.opt.using_display){topblob.blobs[topblob.blobs.length-1].strings.suffix=suffix;}else{topblob.strings.suffix=suffix;}}if(state.bibliography.opt["second-field-align"]){// closes bib_other
state.output.endTag("bib_other");}};suffix_token.execs.push(func);target.push(suffix_token);}}if(this.tokentype===CSL.START){if(this.locale_raw){state.build.current_default_locale=this.locale_raw;}else{state.build.current_default_locale=state.opt["default-locale"];}func=function(state,Item,item){if(state.opt.development_extensions.apply_citation_wrapper&&state.sys.wrapCitationEntry&&!state.tmp.just_looking&&Item.system_id&&state.tmp.area==="citation"){var cite_entry=new CSL.Token("group",CSL.START);cite_entry.decorations=[["@cite","entry"]];state.output.startTag("cite_entry",cite_entry);state.output.current.value().item_id=Item.system_id;if(item){state.output.current.value().locator_txt=item.locator_txt;state.output.current.value().suffix_txt=item.suffix_txt;}}};this.execs.push(func);}// XXX Works, but using state.tmp looks wrong here? We're in the build layer ...
if(this.tokentype===CSL.START&&!state.tmp.cite_affixes[state.build.area]){//
// done_vars is used to prevent the repeated
// rendering of variables
//
// initalize done vars
func=function(state,Item,item){state.tmp.done_vars=[];if(item&&item["author-only"]){state.tmp.done_vars.push("locator");}if(state.opt.suppressedJurisdictions[Item["country"]]&&Item["country"]&&["treaty","patent"].indexOf(Item.type)===-1){state.tmp.done_vars.push("country");}if(!state.tmp.just_looking&&state.registry.registry[Item.id]&&state.registry.registry[Item.id].parallel){state.tmp.done_vars.push("first-reference-note-number");}// trimmer is not available in getAmbiguousCite
if(!state.tmp.just_looking&&state.tmp.abbrev_trimmer&&Item.jurisdiction){for(var field in state.tmp.abbrev_trimmer.QUASHES[Item.jurisdiction]){state.tmp.done_vars.push(field);}}//CSL.debug(" === init rendered_name === ");
state.tmp.rendered_name=false;};this.execs.push(func);// set opt delimiter
func=function(state){// just in case
state.tmp.sort_key_flag=false;};this.execs.push(func);// reset nameset counter [all nodes]
func=function(state){state.tmp.nameset_counter=0;};this.execs.push(func);func=function(state,Item){var tok=new CSL.Token();state.output.openLevel(tok);};this.execs.push(func);target.push(this);if(state.build.area==="citation"){prefix_token=new CSL.Token("text",CSL.SINGLETON);func=function(state,Item,item){if(item&&item.prefix){var prefix=CSL.checkPrefixSpaceAppend(state,item.prefix);if(!state.tmp.just_looking){prefix=state.output.checkNestedBrace.update(prefix);}var ignorePredecessor=CSL.checkIgnorePredecessor(state,prefix);state.output.append(prefix,this,false,ignorePredecessor);}};prefix_token.execs.push(func);target.push(prefix_token);}}// Cast token to be used in one of the configurations below.
var my_tok;if(this.locale_raw){my_tok=new CSL.Token("dummy",CSL.START);my_tok.locale=this.locale_raw;my_tok.strings.delimiter=this.strings.delimiter;my_tok.strings.suffix=this.strings.suffix;if(!state.tmp.cite_affixes[state.build.area]){state.tmp.cite_affixes[state.build.area]={};}}if(this.tokentype===CSL.START){state.build.layout_flag=true;// Only run the following once, to set up the final layout node ...
if(!this.locale_raw){//
// save out decorations for flipflop processing [final node only]
//
state[state.tmp.area].opt.topdecor=[this.decorations];state[state.tmp.area+"_sort"].opt.topdecor=[this.decorations];state[state.build.area].opt.layout_prefix=this.strings.prefix;state[state.build.area].opt.layout_suffix=this.strings.suffix;state[state.build.area].opt.layout_delimiter=this.strings.delimiter;state[state.build.area].opt.layout_decorations=this.decorations;// Only do this if we're running conditionals
if(state.tmp.cite_affixes[state.build.area]){// if build_layout_locale_flag is true,
// write cs:else START to the token list.
tok=new CSL.Token("else",CSL.START);CSL.Node["else"].build.call(tok,state,target);}}// !this.locale_raw
// Conditionals
if(this.locale_raw){if(!state.build.layout_locale_flag){// if layout_locale_flag is untrue,
// write cs:choose START and cs:if START
// to the token list.
var choose_tok=new CSL.Token("choose",CSL.START);CSL.Node.choose.build.call(choose_tok,state,target);my_tok.name="if";CSL.Attributes["@locale-internal"].call(my_tok,state,this.locale_raw);CSL.Node["if"].build.call(my_tok,state,target);}else{// if build_layout_locale_flag is true,
// write cs:else-if START to the token list.
my_tok.name="else-if";CSL.Attributes["@locale-internal"].call(my_tok,state,this.locale_raw);CSL.Node["else-if"].build.call(my_tok,state,target);}// cite_affixes for this node
state.tmp.cite_affixes[state.build.area][my_tok.locale]={};state.tmp.cite_affixes[state.build.area][my_tok.locale].delimiter=this.strings.delimiter;state.tmp.cite_affixes[state.build.area][my_tok.locale].suffix=this.strings.suffix;}}if(this.tokentype===CSL.END){if(this.locale_raw){setSuffix();if(!state.build.layout_locale_flag){// If layout_locale_flag is untrue, write cs:if END
// to the token list.
my_tok.name="if";my_tok.tokentype=CSL.END;CSL.Attributes["@locale-internal"].call(my_tok,state,this.locale_raw);CSL.Node["if"].build.call(my_tok,state,target);state.build.layout_locale_flag=true;}else{// If layout_locale_flag is true, write cs:else-if END
// to the token list.
my_tok.name="else-if";my_tok.tokentype=CSL.END;CSL.Attributes["@locale-internal"].call(my_tok,state,this.locale_raw);CSL.Node["else-if"].build.call(my_tok,state,target);}}if(!this.locale_raw){setSuffix();// Only add this if we're running conditionals
if(state.tmp.cite_affixes[state.build.area]){// If layout_locale_flag is true, write cs:else END
// and cs:choose END to the token list.
if(state.build.layout_locale_flag){tok=new CSL.Token("else",CSL.END);CSL.Node["else"].build.call(tok,state,target);tok=new CSL.Token("choose",CSL.END);CSL.Node.choose.build.call(tok,state,target);}}state.build_layout_locale_flag=true;if(state.build.area==="citation"){suffix_token=new CSL.Token("text",CSL.SINGLETON);func=function(state,Item,item){var sp;if(item&&item.suffix){var suffix=CSL.checkSuffixSpacePrepend(state,item.suffix);if(!state.tmp.just_looking){suffix=state.output.checkNestedBrace.update(suffix);}state.output.append(suffix,this);}};suffix_token.execs.push(func);target.push(suffix_token);}// Closes wrapper token
func=function(state){state.output.closeLevel();};this.execs.push(func);func=function(state,Item){if(state.opt.development_extensions.apply_citation_wrapper&&state.sys.wrapCitationEntry&&!state.tmp.just_looking&&Item.system_id&&state.tmp.area==="citation"){state.output.endTag();// closes citation link wrapper
}};this.execs.push(func);target.push(this);state.build.layout_flag=false;state.build.layout_locale_flag=false;}// !this.layout_raw
}}};/*global CSL: true */CSL.Node.macro={build:function(){}};/*global CSL: true */CSL.Node.alternative={build:function(state,target){if(this.tokentype===CSL.START){var choose_tok=new CSL.Token("choose",CSL.START);CSL.Node["choose"].build.call(choose_tok,state,target);var if_tok=new CSL.Token("if",CSL.START);CSL.Attributes["@alternative-node-internal"].call(if_tok,state);CSL.Node["if"].build.call(if_tok,state,target);var func=function(state,Item){state.tmp.oldItem=Item;state.tmp.oldLang=state.opt.lang;state.tmp.abort_alternative=true;if(Item["language-name"]&&Item["language-name-original"]){var newItem=JSON.parse(JSON.stringify(Item));newItem.language=newItem["language-name"];var langspec=CSL.localeResolve(newItem.language,state.opt["default-locale"][0]);if(state.opt.multi_layout){for(var i in state.opt.multi_layout){var locale_list=state.opt.multi_layout[i];var gotlang=false;for(var j in locale_list){var tryspec=locale_list[j];if(langspec.best===tryspec.best||langspec.base===tryspec.base||langspec.bare===tryspec.bare){gotlang=locale_list[0].best;break;}}if(!gotlang){gotlang=state.opt["default-locale"][0];}state.opt.lang=gotlang;}}for(var key in newItem){if(["id","type","language","multi"].indexOf(key)===-1&&key.slice(0,4)!=="alt-"){if(newItem.multi&&newItem.multi._keys[key]){var deleteme=true;for(var lang in newItem.multi._keys[key]){if(langspec.bare===lang.replace(/^([a-zA-Z]+).*/,"$1")){deleteme=false;break;}}if(deleteme){delete newItem[key];}}else{delete newItem[key];}}}for(var key in newItem){if(key.slice(0,4)==="alt-"){newItem[key.slice(4)]=newItem[key];state.tmp.abort_alternative=false;}else{if(newItem.multi&&newItem.multi._keys){if(!newItem["alt-"+key]&&newItem.multi._keys[key]){if(newItem.multi._keys[key][langspec.best]){newItem[key]=newItem.multi._keys[key][langspec.best];state.tmp.abort_alternative=false;}else if(newItem.multi._keys[key][langspec.base]){newItem[key]=newItem.multi._keys[key][langspec.base];state.tmp.abort_alternative=false;}else if(newItem.multi._keys[key][langspec.bare]){newItem[key]=newItem.multi._keys[key][langspec.bare];state.tmp.abort_alternative=false;}}}}}}state.output.openLevel(this);state.registry.refhash[Item.id]=newItem;state.nameOutput=new CSL.NameOutput(state,newItem);};this.execs.push(func);target.push(this);var choose_tok=new CSL.Token("choose",CSL.START);CSL.Node["choose"].build.call(choose_tok,state,target);var if_tok=new CSL.Token("if",CSL.START);CSL.Attributes["@alternative-node-internal"].call(if_tok,state);var func=function(state){state.tmp.abort_alternative=true;};if_tok.execs.push(func);CSL.Node["if"].build.call(if_tok,state,target);}else if(this.tokentype===CSL.END){var if_tok=new CSL.Token("if",CSL.END);CSL.Node["if"].build.call(if_tok,state,target);var choose_tok=new CSL.Token("choose",CSL.END);CSL.Node["choose"].build.call(choose_tok,state,target);var func=function(state,Item){state.output.closeLevel();state.registry.refhash[Item.id]=state.tmp.oldItem;state.opt.lang=state.tmp.oldLang;state.nameOutput=new CSL.NameOutput(state,state.tmp.oldItem);state.tmp.abort_alternative=false;};this.execs.push(func);target.push(this);var if_tok=new CSL.Token("if",CSL.END);CSL.Node["if"].build.call(if_tok,state,target);var choose_tok=new CSL.Token("choose",CSL.END);CSL.Node["choose"].build.call(choose_tok,state,target);}}};CSL.Node["alternative-text"]={build:function(state,target){if(this.tokentype===CSL.SINGLETON){// do stuff
var func=function(state,Item){var Item=state.refetchItem(Item.id);CSL.getCite.call(state,Item);};this.execs.push(func);}target.push(this);}};/*global CSL: true */CSL.NameOutput=function(state,Item,item){this.debug=false;//SNIP-START
if(this.debug){print("(1)");}//SNIP-END
this.state=state;this.Item=Item;this.item=item;this.nameset_base=0;this.etal_spec={};this._first_creator_variable=false;this._please_chop=false;};CSL.NameOutput.prototype.init=function(names){this.requireMatch=names.requireMatch;if(this.state.tmp.term_predecessor){this.state.tmp.subsequent_author_substitute_ok=false;}if(this.nameset_offset){this.nameset_base=this.nameset_base+this.nameset_offset;}this.nameset_offset=0;this.names=names;this.variables=names.variables;this.state.tmp.value=[];this.state.tmp.rendered_name=[];this.state.tmp.label_blob=false;this.state.tmp.etal_node=false;this.state.tmp.etal_term=false;for(var i=0,ilen=this.variables.length;i<ilen;i+=1){if(this.Item[this.variables[i]]&&this.Item[this.variables[i]].length){this.state.tmp.value=this.state.tmp.value.concat(this.Item[this.variables[i]]);}}this["et-al"]=undefined;// REMOVE THIS
this["with"]=undefined;this.name=undefined;// long, long-with-short, short
this.institutionpart={};// family, given
//this.namepart = {};
// before, after
//this.label = {};
this.state.tmp.group_context.tip.variable_attempt=true;this.labelVariable=this.variables[0];if(!this.state.tmp.value.length){return;}// Abort and proceed to the next substitution if a match is required,
// two variables are called, and they do not match.
var checkCommonTerm=this.checkCommonAuthor(this.requireMatch);if(checkCommonTerm){this.state.tmp.can_substitute.pop();this.state.tmp.can_substitute.push(true);//this.state.tmp.group_context.mystack[this.state.tmp.group_context.mystack.length-1].variable_success = false;
for(var i in this.variables){var idx=this.state.tmp.done_vars.indexOf(this.variables[i]);if(idx>-1){this.state.tmp.done_vars=this.state.tmp.done_vars.slice(0,idx).concat(this.state.tmp.done_vars.slice(i+1));}}this.state.tmp.common_term_match_fail=true;this.variables=[];}};CSL.NameOutput.prototype.reinit=function(names,labelVariable){this.requireMatch=names.requireMatch;this.labelVariable=labelVariable;if(this.state.tmp.can_substitute.value()){this.nameset_offset=0;// What-all should be carried across from the subsidiary
// names node, and on what conditions? For each attribute,
// and decoration, is it an override, or is it additive?
this.variables=names.variables;// Not sure why this is necessary. Guards against a memory leak perhaps?
var oldval=this.state.tmp.value.slice();this.state.tmp.value=[];for(var i=0,ilen=this.variables.length;i<ilen;i+=1){if(this.Item[this.variables[i]]&&this.Item[this.variables[i]].length){this.state.tmp.value=this.state.tmp.value.concat(this.Item[this.variables[i]]);}}if(this.state.tmp.value.length){this.state.tmp.can_substitute.replace(false,CSL.LITERAL);}this.state.tmp.value=oldval;}// Abort and proceed to the next substitution if a match is required,
// two variables are called, and they do not match.
var checkCommonTerm=this.checkCommonAuthor(this.requireMatch);if(checkCommonTerm){this.state.tmp.can_substitute.pop();this.state.tmp.can_substitute.push(true);for(var i in this.variables){var idx=this.state.tmp.done_vars.indexOf(this.variables[i]);if(idx>-1){this.state.tmp.done_vars=this.state.tmp.done_vars.slice(0,idx).concat(this.state.tmp.done_vars.slice(i+1));}}this.variables=[];}};CSL.NameOutput.prototype.outputNames=function(){var i,ilen;var variables=this.variables;if(this.institution.and){if(!this.institution.and.single.blobs||!this.institution.and.single.blobs.length){this.institution.and.single.blobs=this.name.and.single.blobs;}if(!this.institution.and.multiple.blobs||!this.institution.and.multiple.blobs.length){this.institution.and.multiple.blobs=this.name.and.multiple.blobs;}}this.variable_offset={};if(this.family){this.family_decor=CSL.Util.cloneToken(this.family);this.family_decor.strings.prefix="";this.family_decor.strings.suffix="";// Sets text-case value (text-case="title" is suppressed for items
// non-English with non-English value in Item.language)
for(i=0,ilen=this.family.execs.length;i<ilen;i+=1){this.family.execs[i].call(this.family_decor,this.state,this.Item);}}else{this.family_decor=false;}if(this.given){this.given_decor=CSL.Util.cloneToken(this.given);this.given_decor.strings.prefix="";this.given_decor.strings.suffix="";// Sets text-case value (text-case="title" is suppressed for items
// non-English with non-English value in Item.language)
for(i=0,ilen=this.given.execs.length;i<ilen;i+=1){this.given.execs[i].call(this.given_decor,this.state,this.Item);}}else{this.given_decor=false;}//SNIP-START
if(this.debug){print("(2)");}//SNIP-END
// util_names_etalconfig.js
this.getEtAlConfig();//SNIP-START
if(this.debug){print("(3)");}//SNIP-END
// util_names_divide.js
this.divideAndTransliterateNames();//SNIP-START
if(this.debug){print("(4)");}//SNIP-END
// util_names_truncate.js
this.truncatePersonalNameLists();//SNIP-START
if(this.debug){print("(5)");}//SNIP-END
//SNIP-START
if(this.debug){print("(6)");}//SNIP-END
// util_names_disambig.js
this.disambigNames();// util_names_constraints.js
this.constrainNames();//SNIP-START
if(this.debug){print("(7)");}//SNIP-END
// form="count"
if(this.name.strings.form==="count"){if(this.state.tmp.extension||this.names_count!=0){this.state.output.append(this.names_count,"empty");this.state.tmp.group_context.tip.variable_success=true;}return;}//SNIP-START
if(this.debug){print("(8)");}//SNIP-END
this.setEtAlParameters();//SNIP-START
if(this.debug){print("(9)");}//SNIP-END
this.setCommonTerm(this.requireMatch);//SNIP-START
if(this.debug){print("(10)");}//SNIP-END
this.renderAllNames();//SNIP-START
if(this.debug){print("(11)");}//SNIP-END
var blob_list=[];for(i=0,ilen=variables.length;i<ilen;i+=1){var v=variables[i];var institution_sets=[];var institutions=false;var varblob=null;if(!this.state.opt.development_extensions.spoof_institutional_affiliations){varblob=this._join([this.freeters[v]],"");}else{//SNIP-START
if(this.debug){print("(11a)");}//SNIP-END
for(var j=0,jlen=this.institutions[v].length;j<jlen;j+=1){institution_sets.push(this.joinPersonsAndInstitutions([this.persons[v][j],this.institutions[v][j]]));}//SNIP-START
if(this.debug){print("(11b)");}//SNIP-END
if(this.institutions[v].length){var pos=this.nameset_base+this.variable_offset[v];if(this.freeters[v].length){pos+=1;}institutions=this.joinInstitutionSets(institution_sets,pos);}//SNIP-START
if(this.debug){print("(11c)");}//SNIP-END
var varblob=this.joinFreetersAndInstitutionSets([this.freeters[v],institutions]);//SNIP-START
if(this.debug){print("(11d)");}//SNIP-END
}if(varblob){// Apply labels, if any
if(!this.state.tmp.extension){varblob=this._applyLabels(varblob,v);}blob_list.push(varblob);}//SNIP-START
if(this.debug){print("(11e)");}//SNIP-END
if(this.common_term){break;}}//SNIP-START
if(this.debug){print("(12)");}//SNIP-END
this.state.output.openLevel("empty");this.state.output.current.value().strings.delimiter=this.state.inheritOpt(this.names,"delimiter","names-delimiter");//SNIP-START
if(this.debug){print("(13)");}//SNIP-END
for(i=0,ilen=blob_list.length;i<ilen;i+=1){// notSerious
this.state.output.append(blob_list[i],"literal",true);}if(!this.state.tmp.just_looking&&blob_list.length>0){this.state.tmp.probably_rendered_something=true;}//SNIP-START
if(this.debug){print("(14)");}//SNIP-END
this.state.output.closeLevel("empty");//SNIP-START
if(this.debug){print("(15)");}//SNIP-END
var blob=this.state.output.pop();this.state.tmp.name_node.top=blob;//SNIP-START
if(this.debug){print("(16)");}//SNIP-END
// Append will drop the names on the floor here if suppress-me is
// set on element_trace.
// Need to rescue the value for collapse comparison.
var namesToken=CSL.Util.cloneToken(this.names);if(this.state.tmp.group_context.tip.condition){CSL.UPDATE_GROUP_CONTEXT_CONDITION(this.state,this.names.strings.prefix,null,this.names);}this.state.output.append(blob,namesToken);if(this.state.tmp.term_predecessor_name){this.state.tmp.term_predecessor=true;}//SNIP-START
if(this.debug){print("(17)");}//SNIP-END
// Also used in CSL.Util.substituteEnd (which could do with
// some cleanup at this writing).
//SNIP-START
if(this.debug){print("(18)");}//SNIP-END
if(variables[0]!=="authority"){// Just grab the string values in the name
var name_node_string=[];var nameobjs=this.Item[variables[0]];if(nameobjs){for(var i=0,ilen=nameobjs.length;i<ilen;i+=1){var substring=CSL.Util.Names.getRawName(nameobjs[i]);if(substring){name_node_string.push(substring);}}}name_node_string=name_node_string.join(", ");if(name_node_string){this.state.tmp.name_node.string=name_node_string;}}// for classic support
// This may be more convoluted than it needs to be. Or maybe not.
//
// Check for classic abbreviation
//
// If found, then (1) suppress title rendering, (2) replace the node
// with the abbreviation output [and (3) do not run this._collapseAuthor() ?]
if(this.state.tmp.name_node.string&&!this.state.tmp.first_name_string){this.state.tmp.first_name_string=this.state.tmp.name_node.string;}if("classic"===this.Item.type){if(this.state.tmp.first_name_string){var author_title=[];author_title.push(this.state.tmp.first_name_string);if(this.Item.title){author_title.push(this.Item.title);}author_title=author_title.join(", ");if(author_title&&this.state.sys.getAbbreviation){if(this.state.sys.normalizeAbbrevsKey){author_title=this.state.sys.normalizeAbbrevsKey("classic",author_title);}this.state.transform.loadAbbreviation("default","classic",author_title,this.Item.language);if(this.state.transform.abbrevs["default"].classic[author_title]){this.state.tmp.done_vars.push("title");this.state.output.append(this.state.transform.abbrevs["default"].classic[author_title],"empty",true);blob=this.state.output.pop();this.state.tmp.name_node.top.blobs.pop();this.state.tmp.name_node.top.blobs.push(blob);}}}}// Let's try something clever here.
this._collapseAuthor();// For name_SubstituteOnNamesSpanNamesSpanFail
this.variables=[];// Reset stop-last after rendering
this.state.tmp.authority_stop_last=0;//SNIP-START
if(this.debug){print("(19)");}//SNIP-END
};CSL.NameOutput.prototype._applyLabels=function(blob,v){var txt;if(!this.label||!this.label[this.labelVariable]){return blob;}var plural=0;var num=this.freeters_count[v]+this.institutions_count[v];if(num>1){plural=1;}else{for(var i=0,ilen=this.persons[v].length;i<ilen;i+=1){num+=this.persons_count[v][i];}if(num>1){plural=1;}}// Some code duplication here, should be factored out.
if(this.label[this.labelVariable].before){if("number"===typeof this.label[this.labelVariable].before.strings.plural){plural=this.label[this.labelVariable].before.strings.plural;}txt=this._buildLabel(v,plural,"before",this.labelVariable);this.state.output.openLevel("empty");this.state.output.append(txt,this.label[this.labelVariable].before,true);this.state.output.append(blob,"literal",true);this.state.output.closeLevel("empty");blob=this.state.output.pop();}else if(this.label[this.labelVariable].after){if("number"===typeof this.label[this.labelVariable].after.strings.plural){plural=this.label[this.labelVariable].after.strings.plural;}txt=this._buildLabel(v,plural,"after",this.labelVariable);this.state.output.openLevel("empty");this.state.output.append(blob,"literal",true);this.state.output.append(txt,this.label[this.labelVariable].after,true);this.state.tmp.label_blob=this.state.output.pop();this.state.output.append(this.state.tmp.label_blob,"literal",true);this.state.output.closeLevel("empty");blob=this.state.output.pop();}return blob;};CSL.NameOutput.prototype._buildLabel=function(term,plural,position,v){if(this.common_term){term=this.common_term;}var ret=false;var node=this.label[v][position];if(node){ret=CSL.castLabel(this.state,node,term,plural,CSL.TOLERANT);}return ret;};CSL.NameOutput.prototype._collapseAuthor=function(){var myqueue,mystr,oldchars;// collapse can be undefined, an array of length zero, and probably
// other things ... ugh.
if(this.state.tmp.name_node.top.blobs.length===0){return;}if(this.nameset_base===0&&this.Item[this.variables[0]]&&!this._first_creator_variable){this._first_creator_variable=this.variables[0];}if(this.state[this.state.tmp.area].opt.collapse&&this.state[this.state.tmp.area].opt.collapse.length||this.state[this.state.tmp.area].opt.cite_group_delimiter&&this.state[this.state.tmp.area].opt.cite_group_delimiter.length){if(this.state.tmp.authorstring_request){// Avoid running this on every call to getAmbiguousCite()?
mystr="";myqueue=this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;oldchars=this.state.tmp.offset_characters;if(myqueue){mystr=this.state.output.string(this.state,myqueue,false);}// Avoid side-effects on character counting: we're only interested
// in the final rendering.
this.state.tmp.offset_characters=oldchars;this.state.registry.authorstrings[this.Item.id]=mystr;}else if(!this.state.tmp.just_looking&&!this.state.tmp.suppress_decorations&&(this.state[this.state.tmp.area].opt.collapse&&this.state[this.state.tmp.area].opt.collapse.length||this.state[this.state.tmp.area].opt.cite_group_delimiter&&this.state[this.state.tmp.area].opt.cite_group_delimiter)){// XX1 print("RENDER: "+this.Item.id);
mystr="";myqueue=this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;oldchars=this.state.tmp.offset_characters;if(myqueue){mystr=this.state.output.string(this.state,myqueue,false);}if(mystr===this.state.tmp.last_primary_names_string){if(this.item["suppress-author"]||this.state[this.state.tmp.area].opt.collapse&&this.state[this.state.tmp.area].opt.collapse.length){// XX1 print("    CUT!");
this.state.tmp.name_node.top.blobs.pop();this.state.tmp.name_node.children=[];// If popped, avoid side-effects on character counting: we're only interested
// in things that actually render.
this.state.tmp.offset_characters=oldchars;}// Needed
if(this.state[this.state.tmp.area].opt.cite_group_delimiter&&this.state[this.state.tmp.area].opt.cite_group_delimiter){this.state.tmp.use_cite_group_delimiter=true;}}else{// XX1 print("remembering: "+mystr);
this.state.tmp.last_primary_names_string=mystr;// XXXXX A little more precision would be nice.
// This will clobber variable="author editor" as well as variable="author".
if(this.variables.indexOf(this._first_creator_variable)>-1&&this.item&&this.item["suppress-author"]&&this.Item.type!=="legal_case"){this.state.tmp.name_node.top.blobs.pop();this.state.tmp.name_node.children=[];// If popped, avoid side-effects on character counting: we're only interested
// in things that actually render.
this.state.tmp.offset_characters=oldchars;// A wild guess, but will usually be correct
this.state.tmp.term_predecessor=false;}// Arcane and probably unnecessarily complicated?
this.state.tmp.have_collapsed=false;// Needed
if(this.state[this.state.tmp.area].opt.cite_group_delimiter&&this.state[this.state.tmp.area].opt.cite_group_delimiter){this.state.tmp.use_cite_group_delimiter=false;}}}}};/*
CSL.NameOutput.prototype.suppressNames = function() {
    suppress_condition = suppress_min && display_names.length >= suppress_min;
    if (suppress_condition) {
        continue;
    }
}
*/ /*global CSL: true */CSL.NameOutput.prototype.isPerson=function(value){if(value.literal||!value.given&&value.family&&value.isInstitution){return false;}else{return true;}};/*global CSL: true */CSL.NameOutput.prototype.truncatePersonalNameLists=function(){var v,i,ilen,j,jlen,chopvar,values;// XXX Before truncation, make a note of the original number
// of names, for use in et-al evaluation.
this.freeters_count={};this.persons_count={};this.institutions_count={};// By key is okay here, as we don't care about sequence.
for(v in this.freeters){if(this.freeters.hasOwnProperty(v)){this.freeters_count[v]=this.freeters[v].length;this.freeters[v]=this._truncateNameList(this.freeters,v);}}for(v in this.persons){if(this.persons.hasOwnProperty(v)){this.institutions_count[v]=this.institutions[v].length;this._truncateNameList(this.institutions,v);this.persons[v]=this.persons[v].slice(0,this.institutions[v].length);this.persons_count[v]=[];for(j=0,jlen=this.persons[v].length;j<jlen;j+=1){this.persons_count[v][j]=this.persons[v][j].length;this.persons[v][j]=this._truncateNameList(this.persons,v,j);}}}if(this.state.opt.development_extensions.etal_min_etal_usefirst_hack&&this.etal_min===1&&this.etal_use_first===1&&!(this.state.tmp.extension||this.state.tmp.just_looking)){chopvar=v;}else{chopvar=false;}if(chopvar||this._please_chop){for(i=0,ilen=this.variables.length;i<ilen;i+=1){v=this.variables[i];if(this.freeters[v].length){if(this._please_chop===v){this.freeters[v]=this.freeters[v].slice(1);this.freeters_count[v]+=-1;this._please_chop=false;}else if(chopvar&&!this._please_chop){this.freeters[v]=this.freeters[v].slice(0,1);this.freeters_count[v]=1;this.institutions[v]=[];this.persons[v]=[];this._please_chop=chopvar;}}for(var j=0,jlen=this.persons[v].length;j<jlen;j++){if(this.persons[v][j].length){if(this._please_chop===v){this.persons[v][j]=this.persons[v][j].slice(1);this.persons_count[v][j]+=-1;this._please_chop=false;break;}else if(chopvar&&!this._please_chop){this.freeters[v]=this.persons[v][j].slice(0,1);this.freeters_count[v]=1;this.institutions[v]=[];this.persons[v]=[];values=[];this._please_chop=chopvar;break;}}}if(this.institutions[v].length){if(this._please_chop===v){this.institutions[v]=this.institutions[v].slice(1);this.institutions_count[v]+=-1;this._please_chop=false;}else if(chopvar&&!this._please_chop){this.institutions[v]=this.institutions[v].slice(0,1);this.institutions_count[v]=1;values=[];this._please_chop=chopvar;}}}}// Transliteration and abbreviation mapping
// Hmm. This could produce three lists for each nameset:
//   - primary (transformed in place)
//   - secondary
//   - tertiary
// with items that produce no result in the secondary and tertiary
// transforms set to false. Maybe.
// Actually that would be insane, so forget it.
// What we need is to add suitable parameters to getName(), and merge
// the single-name-level operations below into that function. Then the
// operation can be applied in util_names_render.js, and the logic
// becomes very similar to what we already have running in util_transform.js.
/*
    for (v in this.freeters) {
        this._transformNameset(this.freeters[v]);
    }
    for (v in this.persons) {
        for (i = 0, ilen = this.persons[v].length; i < ilen; i += 1) {
            this._transformNameset(this.persons[v][i]);
        }
        this._transformNameset(this.institutions[v]);
    }
*/ // Could also be factored out to a separate function for clarity.
// ???? XXX Does this belong?
for(i=0,ilen=this.variables.length;i<ilen;i+=1){if(this.institutions[v].length){this.nameset_offset+=1;}for(var j=0,jlen=this.persons[v].length;j<jlen;j++){if(this.persons[v][j].length){this.nameset_offset+=1;}// this.institutions[v][i] = this._splitInstitution(this.institutions[v][i], v, i);
}}};CSL.NameOutput.prototype._truncateNameList=function(container,variable,index){var lst;if("undefined"===typeof index){lst=container[variable];}else{lst=container[variable][index];}if(this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names&&lst.length>50&&lst.length>this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names+2){// Preserve the last name in the list, in case we're rendering with a PI ellipsis (et-al-use-last)
var limit=this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names;lst=lst.slice(0,limit+1).concat(lst.slice(-1));}return lst;};/*global CSL: true */CSL.NameOutput.prototype.divideAndTransliterateNames=function(){var i,ilen,j,jlen;var Item=this.Item;var variables=this.variables;this.varnames=variables.slice();this.freeters={};this.persons={};this.institutions={};for(i=0,ilen=variables.length;i<ilen;i+=1){var v=variables[i];this.variable_offset[v]=this.nameset_offset;var values=this._normalizeVariableValue(Item,v);if(this.name.strings["suppress-min"]&&values.length>=this.name.strings["suppress-min"]){values=[];}if(this.name.strings["suppress-max"]&&values.length<=this.name.strings["suppress-max"]){values=[];}this._getFreeters(v,values);this._getPersonsAndInstitutions(v,values);if(this.state.opt.development_extensions.spoof_institutional_affiliations){if(this.name.strings["suppress-min"]===0){this.freeters[v]=[];for(j=0,jlen=this.persons[v].length;j<jlen;j+=1){this.persons[v][j]=[];}}else if(this.institution.strings["suppress-min"]===0){this.institutions[v]=[];this.freeters[v]=this.freeters[v].concat(this.persons[v]);for(j=0,jlen=this.persons[v].length;j<jlen;j+=1){for(var k=0,klen=this.persons[v][j].length;k<klen;k+=1){this.freeters[v].push(this.persons[v][j][k]);}}this.persons[v]=[];}}}};CSL.NameOutput.prototype._normalizeVariableValue=function(Item,variable){var names;if("string"===typeof Item[variable]||"number"===typeof Item[variable]){CSL.debug("name variable \""+variable+"\" is string or number, not array. Attempting to fix.");names=[{literal:Item[variable]+""}];}else if(!Item[variable]){names=[];}else if("number"!==typeof Item[variable].length){CSL.debug("name variable \""+variable+"\" is object, not array. Attempting to fix.");Item[variable]=[Item[variable]];names=Item[variable].slice();}else{names=Item[variable].slice();}return names;};CSL.NameOutput.prototype._getFreeters=function(v,values){this.freeters[v]=[];if(this.state.opt.development_extensions.spoof_institutional_affiliations){for(var i=values.length-1;i>-1;i--){if(this.isPerson(values[i])){var value=this._checkNickname(values.pop());if(value){this.freeters[v].push(value);}}else{break;}}}else{for(var i=values.length-1;i>-1;i--){var value=values.pop();if(this.isPerson(value)){var value=this._checkNickname(value);}this.freeters[v].push(value);}}this.freeters[v].reverse();if(this.freeters[v].length){this.nameset_offset+=1;}};CSL.NameOutput.prototype._getPersonsAndInstitutions=function(v,values){this.persons[v]=[];this.institutions[v]=[];if(!this.state.opt.development_extensions.spoof_institutional_affiliations){return;}var persons=[];var has_affiliates=false;var first=true;for(var i=values.length-1;i>-1;i+=-1){if(this.isPerson(values[i])){var value=this._checkNickname(values[i]);if(value){persons.push(value);}}else{has_affiliates=true;this.institutions[v].push(values[i]);if(!first){persons.reverse();this.persons[v].push(persons);persons=[];}first=false;}}if(has_affiliates){persons.reverse();this.persons[v].push(persons);this.persons[v].reverse();this.institutions[v].reverse();}};CSL.NameOutput.prototype._clearValues=function(values){for(var i=values.length-1;i>-1;i+=-1){values.pop();}};CSL.NameOutput.prototype._checkNickname=function(name){if(["interview","personal_communication"].indexOf(this.Item.type)>-1){var author="";author=CSL.Util.Names.getRawName(name);if(author&&this.state.sys.getAbbreviation&&!(this.item&&this.item["suppress-author"])){var normalizedKey=author;if(this.state.sys.normalizeAbbrevsKey){// The first argument does not have to be the exact variable name.
normalizedKey=this.state.sys.normalizeAbbrevsKey("author",author);}this.state.transform.loadAbbreviation("default","nickname",normalizedKey,this.Item.language);// XXX Why does this have to happen here?
var myLocalName=this.state.transform.abbrevs["default"].nickname[normalizedKey];if(myLocalName){if(myLocalName==="!here>>>"){name=false;}else{name={family:myLocalName,given:''};}}}}return name;};/*global CSL: true */CSL.NameOutput.prototype._purgeEmptyBlobs=function(blobs){for(var i=blobs.length-1;i>-1;i+=-1){if(!blobs[i]||blobs[i].length===0||!blobs[i].blobs.length){blobs=blobs.slice(0,i).concat(blobs.slice(i+1));}}return blobs;};CSL.NameOutput.prototype.joinPersons=function(blobs,pos,j,tokenname){var ret;blobs=this._purgeEmptyBlobs(blobs);if(!tokenname){tokenname="name";}if("undefined"===typeof j){if(this.etal_spec[pos].freeters===1){ret=this._joinEtAl(blobs);}else if(this.etal_spec[pos].freeters===2){ret=this._joinEllipsis(blobs);}else if(!this.state.tmp.sort_key_flag){ret=this._joinAnd(blobs);}else{ret=this._join(blobs,this.state.inheritOpt(this.name,"delimiter","name-delimiter",", "));}}else{if(this.etal_spec[pos].persons[j]===1){ret=this._joinEtAl(blobs);}else if(this.etal_spec[pos].persons[j]===2){ret=this._joinEllipsis(blobs);}else if(!this.state.tmp.sort_key_flag){ret=this._joinAnd(blobs);}else{ret=this._join(blobs,this.state.inheritOpt(this.name,"delimiter","name-delimiter",", "));}}return ret;};CSL.NameOutput.prototype.joinInstitutionSets=function(blobs,pos){var ret;blobs=this._purgeEmptyBlobs(blobs);if(this.etal_spec[pos].institutions===1){ret=this._joinEtAl(blobs,"institution");}else if(this.etal_spec[pos].institutions===2){ret=this._joinEllipsis(blobs,"institution");}else{ret=this._joinAnd(blobs);}return ret;};CSL.NameOutput.prototype.joinPersonsAndInstitutions=function(blobs){//
blobs=this._purgeEmptyBlobs(blobs);var ret=this._join(blobs,this.state.tmp.name_delimiter);ret.isInstitution=true;return ret;};// LEGACY
// This should go away eventually
CSL.NameOutput.prototype.joinFreetersAndInstitutionSets=function(blobs){// Nothing, one or two, never more
blobs=this._purgeEmptyBlobs(blobs);var ret=this._join(blobs,"[never here]",this["with"].single,this["with"].multiple);//var ret = this._join(blobs, "");
return ret;};CSL.NameOutput.prototype._getAfterInvertedName=function(blobs,delimiter,finalJoin){if(finalJoin&&blobs.length>1){if(this.state.inheritOpt(this.name,"delimiter-precedes-last")==="after-inverted-name"){var prevBlob=blobs[blobs.length-2];if(prevBlob.blobs.length>0&&prevBlob.blobs[0].isInverted){finalJoin.strings.prefix=delimiter;}}}return finalJoin;};CSL.NameOutput.prototype._getAndJoin=function(blobs,delimiter){var finalJoin=false;if(blobs.length>1){var singleOrMultiple="single";if(blobs.length>2){singleOrMultiple="multiple";}if(blobs[blobs.length-1].isInstitution){finalJoin=this.institution.and[singleOrMultiple];}else{finalJoin=this.name.and[singleOrMultiple];}// finalJoin = new CSL.Blob(finalJoin);
finalJoin=JSON.parse(JSON.stringify(finalJoin));finalJoin=this._getAfterInvertedName(blobs,delimiter,finalJoin);}return finalJoin;};CSL.NameOutput.prototype._joinEtAl=function(blobs){var delimiter=this.state.inheritOpt(this.name,"delimiter","name-delimiter",", ");var blob=this._join(blobs,delimiter);// notSerious
this.state.output.openLevel(this._getToken("name"));// Delimiter is applied from separately saved source in this case,
// for discriminate application of single and multiple joins.
this.state.output.current.value().strings.delimiter="";this.state.output.append(blob,"literal",true);if(blobs.length>1){this.state.output.append(this["et-al"].multiple,"literal",true);}else if(blobs.length===1){this.state.output.append(this["et-al"].single,"literal",true);}this.state.output.closeLevel();return this.state.output.pop();};CSL.NameOutput.prototype._joinEllipsis=function(blobs){var delimiter=this.state.inheritOpt(this.name,"delimiter","name-delimiter",", ");var finalJoin=false;if(blobs.length>1){var singleOrMultiple="single";if(blobs.length>2){singleOrMultiple="multiple";}finalJoin=JSON.parse(JSON.stringify(this.name.ellipsis[singleOrMultiple]));finalJoin=this._getAfterInvertedName(blobs,delimiter,finalJoin);}return this._join(blobs,delimiter,finalJoin);};CSL.NameOutput.prototype._joinAnd=function(blobs){var delimiter=this.state.inheritOpt(this.name,"delimiter","name-delimiter",", ");var finalJoin=this._getAndJoin(blobs,delimiter);return this._join(blobs,delimiter,finalJoin);};CSL.NameOutput.prototype._join=function(blobs,delimiter,finalJoin){var i,ilen;if(!blobs){return false;}blobs=this._purgeEmptyBlobs(blobs);if(!blobs.length){return false;}if(blobs.length>1){if(blobs.length===2){if(!finalJoin){blobs[0].strings.suffix+=delimiter;}else{blobs=[blobs[0],finalJoin,blobs[1]];}}else{var offset;if(finalJoin){offset=1;}else{offset=0;}var blob=blobs.pop();for(var i=0,ilen=blobs.length-offset;i<ilen;i++){blobs[i].strings.suffix+=delimiter;}blobs.push(finalJoin);blobs.push(blob);}}//this.state.output.openLevel(this._getToken(tokenname));
this.state.output.openLevel();//this.state.output.openLevel(this._getToken("empty"));
// Delimiter is applied from separately saved source in this case,
// for discriminate application of single and multiple joins.
for(i=0,ilen=blobs.length;i<ilen;i+=1){this.state.output.append(blobs[i],false,true);}this.state.output.closeLevel();return this.state.output.pop();};CSL.NameOutput.prototype._getToken=function(tokenname){var token=this[tokenname];if(tokenname==="institution"){var newtoken=new CSL.Token();// Which, hmm, is the same thing as "empty"
// Oh, well.
//newtoken.strings.prefix = token.prefix;
//newtoken.strings.suffix = token.suffix;
return newtoken;}return token;};/*global CSL: true */CSL.NameOutput.prototype.checkCommonAuthor=function(requireMatch){if(!requireMatch){return false;}var common_term=false;if(this.variables.length===2){var variables=this.variables;var varnames=variables.slice();varnames.sort();common_term=varnames.join("");}if(!common_term){return false;}var has_term=false;if(this.state.locale[this.state.opt.lang].terms[common_term]){has_term=true;}if(!has_term){this.state.tmp.done_vars.push(this.variables[0]);this.state.tmp.done_vars.push(this.variables[1]);return false;}var firstSet=this.Item[this.variables[0]];var secondSet=this.Item[this.variables[1]];var perfectMatch=this._compareNamesets(firstSet,secondSet);if(perfectMatch===true){this.state.tmp.done_vars.push(this.variables[0]);this.state.tmp.done_vars.push(this.variables[1]);}// This may be counter-intuitive.
// This check controls whether we will fail on the this attempt at rendering
// and proceed with substitution. If the names match exactly (true), then
// we do *not* want to abort and continue with substitution.
return!perfectMatch;};CSL.NameOutput.prototype.setCommonTerm=function(){var variables=this.variables;var varnames=variables.slice();varnames.sort();this.common_term=varnames.join("");// When no varnames are on offer
if(!this.common_term){return;}var has_term=false;if(this.label&&this.label[this.variables[0]]){if(this.label[this.variables[0]].before){has_term=this.state.getTerm(this.common_term,this.label[this.variables[0]].before.strings.form,0);}else if(this.label[this.variables[0]].after){has_term=this.state.getTerm(this.common_term,this.label[this.variables[0]].after.strings.form,0);}}// When there is no common term
if(!this.state.locale[this.state.opt.lang].terms[this.common_term]||!has_term||this.variables.length<2){this.common_term=false;return;}var freeters_offset=0;for(var i=0,ilen=this.variables.length-1;i<ilen;i+=1){var v=this.variables[i];var vv=this.variables[i+1];if(this.freeters[v].length||this.freeters[vv].length){if(this.etal_spec[v].freeters!==this.etal_spec[vv].freeters||!this._compareNamesets(this.freeters[v],this.freeters[vv])){this.common_term=false;return;}freeters_offset+=1;}if(this.persons[v].length!==this.persons[vv].length){this.common_term=false;return;}for(var j=0,jlen=this.persons[v].length;j<jlen;j+=1){if(this.etal_spec[v].persons[j]!==this.etal_spec[vv].persons[j]||!this._compareNamesets(this.persons[v][j],this.persons[vv][j])){this.common_term=false;return;}}}};CSL.NameOutput.prototype._compareNamesets=function(base_nameset,nameset){if(!base_nameset||!nameset||base_nameset.length!==nameset.length){return false;}for(var i=0,ilen=nameset.length;i<ilen;i+=1){for(var j=0,jlen=CSL.NAME_PARTS.length;j<jlen;j+=1){var part=CSL.NAME_PARTS[j];if(!base_nameset[i]||base_nameset[i][part]!=nameset[i][part]){return false;}}}return true;};/*global CSL: true */CSL.NameOutput.prototype.constrainNames=function(){// figure out how many names to include, in light of the disambig params
//
this.names_count=0;//var pos = 0;
var pos;for(var i=0,ilen=this.variables.length;i<ilen;i+=1){var v=this.variables[i];pos=this.nameset_base+i;// Constrain independent authors here
if(this.freeters[v].length){this.state.tmp.names_max.push(this.freeters[v].length,"literal");this._imposeNameConstraints(this.freeters,this.freeters_count,v,pos);this.names_count+=this.freeters[v].length;}// Constrain institutions here
if(this.institutions[v].length){this.state.tmp.names_max.push(this.institutions[v].length,"literal");this._imposeNameConstraints(this.institutions,this.institutions_count,v,pos);this.persons[v]=this.persons[v].slice(0,this.institutions[v].length);this.names_count+=this.institutions[v].length;}for(var j=0,jlen=this.persons[v].length;j<jlen;j+=1){// Constrain affiliated authors here
if(this.persons[v][j].length){this.state.tmp.names_max.push(this.persons[v][j].length,"literal");this._imposeNameConstraints(this.persons[v],this.persons_count[v],j,pos);this.names_count+=this.persons[v][j].length;}}}};CSL.NameOutput.prototype._imposeNameConstraints=function(lst,count,key,pos){// display_names starts as the original length of this list of names.
var display_names=lst[key];var discretionary_names_length=this.state.tmp["et-al-min"];// Mappings, to allow existing disambiguation machinery to
// remain untouched.
if(this.state.tmp.suppress_decorations){if(this.state.tmp.disambig_request&&this.state.tmp.disambig_request.names[pos]){// Oh. Trouble.
// state.tmp.nameset_counter is the number of the nameset
// in the disambiguation try-sequence. Ouch.
discretionary_names_length=this.state.tmp.disambig_request.names[pos];}else if(count[key]>=this.etal_min){discretionary_names_length=this.etal_use_first;}}else{if(this.state.tmp.disambig_request&&this.state.tmp.disambig_request.names[pos]>this.etal_use_first){if(count[key]<this.etal_min){discretionary_names_length=count[key];}else{discretionary_names_length=this.state.tmp.disambig_request.names[pos];}}else if(count[key]>=this.etal_min){//discretionary_names_length = this.state.tmp["et-al-use-first"];
discretionary_names_length=this.etal_use_first;}// XXXX: This is a workaround. Under some conditions.
// Where namesets disambiguate on one of the two names
// dropped here, it is possible for more than one
// in-text citation to be close (and indistinguishable)
// matches to a single bibliography entry.
//
// 
if(this.etal_use_last&&discretionary_names_length>this.etal_min-2){discretionary_names_length=this.etal_min-2;}}var sane=this.etal_min>=this.etal_use_first;var overlength=count[key]>discretionary_names_length;// This var is used to control contextual join, and
// lies about the number of names when forceEtAl is true,
// unless normalized.
if(discretionary_names_length>count[key]){// Use actual truncated list length, to avoid overrun.
discretionary_names_length=display_names.length;}// forceEtAl is relevant when the author list is
// truncated to eliminate clutter.
if(sane&&overlength){if(this.etal_use_last){lst[key]=display_names.slice(0,discretionary_names_length).concat(display_names.slice(-1));}else{lst[key]=display_names.slice(0,discretionary_names_length);}}this.state.tmp.disambig_settings.names[pos]=lst[key].length;this.state.disambiguate.padBase(this.state.tmp.disambig_settings);// ???
//if (!this.state.tmp.disambig_request) {
//    this.state.tmp.disambig_settings.givens[pos] = [];
//}
};// Disambiguate names (the number of names is controlled externally, by successive
// runs of the processor).
/*global CSL: true */CSL.NameOutput.prototype.disambigNames=function(){var pos;for(var i=0,ilen=this.variables.length;i<ilen;i+=1){var v=this.variables[i];pos=this.nameset_base+i;if(this.freeters[v].length){this._runDisambigNames(this.freeters[v],pos);}// Is this even necessary???
if(this.institutions[v].length){if("undefined"===typeof this.state.tmp.disambig_settings.givens[pos]){this.state.tmp.disambig_settings.givens[pos]=[];}for(var j=0,jlen=this.institutions[v].length;j<jlen;j+=1){if("undefined"===typeof this.state.tmp.disambig_settings.givens[pos][j]){this.state.tmp.disambig_settings.givens[pos].push(2);}}}for(var j=0,jlen=this.persons[v].length;j<jlen;j+=1){if(this.persons[v][j].length){this._runDisambigNames(this.persons[v][j],pos);}}}};CSL.NameOutput.prototype._runDisambigNames=function(lst,pos){var chk,myform,myinitials,param,i,ilen,paramx;//if (this.state.tmp.root === "bibliography") {
//    return;
//}
for(i=0,ilen=lst.length;i<ilen;i+=1){//
// register the name in the global names disambiguation
// registry
if(!lst[i].given&&!lst[i].family){continue;}myinitials=this.state.inheritOpt(this.name,"initialize-with");this.state.registry.namereg.addname(""+this.Item.id,lst[i],i);chk=this.state.tmp.disambig_settings.givens[pos];if("undefined"===typeof chk){// Holes can appear in the list, probably due to institutional
// names that this doesn't touch. Maybe. This fills them up.
for(var j=0,jlen=pos+1;j<jlen;j+=1){if(!this.state.tmp.disambig_settings.givens[j]){this.state.tmp.disambig_settings.givens[j]=[];}}}chk=this.state.tmp.disambig_settings.givens[pos][i];//if ("undefined" !== typeof chk && this.state.tmp.root === 'citation') {
//this.state.tmp.disambig_settings.givens[pos] = [];
//chk = undefined;
//}
if("undefined"===typeof chk){myform=this.state.inheritOpt(this.name,"form","name-form","long");param=this.state.registry.namereg.evalname(""+this.Item.id,lst[i],i,0,myform,myinitials);this.state.tmp.disambig_settings.givens[pos].push(param);}//
// set the display mode default for givennames if required
myform=this.state.inheritOpt(this.name,"form","name-form","long");paramx=this.state.registry.namereg.evalname(""+this.Item.id,lst[i],i,0,myform,myinitials);// this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
if(this.state.tmp.disambig_request){//
// fix a request for initials that makes no sense.
// can't do this in disambig, because the availability
// of initials is not a global parameter.
var val=this.state.tmp.disambig_settings.givens[pos][i];// This is limited to by-cite disambiguation.
// 2012-09-13: added lst[i].given check to condition
if(val===1&&this.state.citation.opt["givenname-disambiguation-rule"]==="by-cite"&&("undefined"===typeof this.state.inheritOpt(this.name,"initialize-with")||"undefined"===typeof lst[i].given)){val=2;}param=val;// 2012-09-13: lst[i].given check protects against personal names
// that have no first name element. These were causing an infinite loop,
// this prevents that.
if(this.state.opt["disambiguate-add-givenname"]&&lst[i].given){param=this.state.registry.namereg.evalname(""+this.Item.id,lst[i],i,param,this.state.inheritOpt(this.name,"form","name-form","long"),this.state.inheritOpt(this.name,"initialize-with"));}}else{//
// it clicks.  here is where we will put the
// call to the names register, to get the floor value
// for an individual name.
//
param=paramx;}// Need to save off the settings based on subsequent
// form, when first cites are rendered.
if(!this.state.tmp.just_looking&&this.item&&this.item.position===CSL.POSITION_FIRST){if(paramx>param){param=paramx;}}if(!this.state.tmp.sort_key_flag){this.state.tmp.disambig_settings.givens[pos][i]=param;if("string"===typeof myinitials&&("undefined"===typeof this.name.strings["initialize"]||true===this.name.strings["initialize"])){this.state.tmp.disambig_settings.use_initials=true;}}}//this.state.registry.registry[this.Item.id].disambig.givens = this.state.tmp.disambig_settings.givens.slice();
};/*global CSL: true */CSL.NameOutput.prototype.getEtAlConfig=function(){var item=this.item;this["et-al"]={};this.state.output.append(this.etal_term,this.etal_style,true);this["et-al"].single=this.state.output.pop();this["et-al"].single.strings.suffix=this.etal_suffix;this["et-al"].single.strings.prefix=this.etal_prefix_single;this.state.output.append(this.etal_term,this.etal_style,true);this["et-al"].multiple=this.state.output.pop();this["et-al"].multiple.strings.suffix=this.etal_suffix;this["et-al"].multiple.strings.prefix=this.etal_prefix_multiple;// Et-al style parameters (may be sidestepped by disambiguation
// in util_names_constraints.js)
if("undefined"===typeof item){item={};}//print("== getEtAlConfig() == "+this.state.tmp.area);
if(item.position){if(this.state.inheritOpt(this.name,"et-al-subsequent-min")){// XX
this.etal_min=this.state.inheritOpt(this.name,"et-al-subsequent-min");}else{// XX
this.etal_min=this.state.inheritOpt(this.name,"et-al-min");}if(this.state.inheritOpt(this.name,"et-al-subsequent-use-first")){// XX
this.etal_use_first=this.state.inheritOpt(this.name,"et-al-subsequent-use-first");}else{// XX
this.etal_use_first=this.state.inheritOpt(this.name,"et-al-use-first");}}else{if(this.state.tmp["et-al-min"]){this.etal_min=this.state.tmp["et-al-min"];}else{// XX
this.etal_min=this.state.inheritOpt(this.name,"et-al-min");}if(this.state.tmp["et-al-use-first"]){this.etal_use_first=this.state.tmp["et-al-use-first"];}else{// XX
this.etal_use_first=this.state.inheritOpt(this.name,"et-al-use-first");}if("boolean"===typeof this.state.tmp["et-al-use-last"]){//print("  etal_use_last from tmp: "+this.state.tmp["et-al-use-last"]);
this.etal_use_last=this.state.tmp["et-al-use-last"];}else{//print("  etal_use_last from name: "+this.name.strings["et-al-use-last"]);
// XX
this.etal_use_last=this.state.inheritOpt(this.name,"et-al-use-last");}//print("  etal_use_last: "+this.etal_use_last);
}// Provided for use as the starting level for disambiguation.
if(!this.state.tmp["et-al-min"]){this.state.tmp["et-al-min"]=this.etal_min;}};/*global CSL: true */CSL.NameOutput.prototype.setEtAlParameters=function(){var i,ilen,j,jlen;for(i=0,ilen=this.variables.length;i<ilen;i+=1){var v=this.variables[i];if("undefined"===typeof this.etal_spec[v]){this.etal_spec[v]={freeters:0,institutions:0,persons:[]};}this.etal_spec[this.nameset_base+i]=this.etal_spec[v];if(this.freeters[v].length){this._setEtAlParameter("freeters",v);}for(j=0,jlen=this.persons[v].length;j<jlen;j+=1){if("undefined"===typeof this.etal_spec[v][j]){this.etal_spec[v].persons[j]=0;}this._setEtAlParameter("persons",v,j);}if(this.institutions[v].length){this._setEtAlParameter("institutions",v);}}};CSL.NameOutput.prototype._setEtAlParameter=function(type,v,j){var lst,count;if(type==="persons"){lst=this.persons[v][j];count=this.persons_count[v][j];}else{lst=this[type][v];count=this[type+"_count"][v];}if(lst.length<count&&!this.state.tmp.sort_key_flag){if(this.etal_use_last){if(type==="persons"){this.etal_spec[v].persons[j]=2;}else{this.etal_spec[v][type]=2;}}else{if(type==="persons"){this.etal_spec[v].persons[j]=1;}else{this.etal_spec[v][type]=1;}}}else{if(type==="persons"){this.etal_spec[v].persons[j]=0;}else{this.etal_spec[v][type]=0;}}};/*global CSL: true */CSL.NameOutput.prototype.renderAllNames=function(){// Note that et-al/ellipsis parameters are set on the basis
// of rendering order through the whole cite.
var pos;for(var i=0,ilen=this.variables.length;i<ilen;i+=1){var v=this.variables[i];if(this.freeters[v].length||this.institutions[v].length){if(!this.state.tmp.group_context.tip.condition){this.state.tmp.just_did_number=false;}}pos=this.nameset_base+i;if(this.freeters[v].length){this.freeters[v]=this._renderNames(v,this.freeters[v],pos);}for(var j=0,jlen=this.institutions[v].length;j<jlen;j+=1){this.persons[v][j]=this._renderNames(v,this.persons[v][j],pos,j);}}this.renderInstitutionNames();};CSL.NameOutput.prototype.renderInstitutionNames=function(){// Institutions are split to string list as
// this.institutions[v]["long"] and this.institutions[v]["short"]
for(var i=0,ilen=this.variables.length;i<ilen;i+=1){var v=this.variables[i];for(var j=0,jlen=this.institutions[v].length;j<jlen;j+=1){var institution;var name=this.institutions[v][j];// XXX Start here for institutions
// Figure out the three segments: primary, secondary, tertiary
var j,jlen,localesets;if(this.state.tmp.extension){localesets=["sort"];}else if(name.isInstitution||name.literal){// Will never hit this in this function, but preserving
// in case we factor this out.
localesets=this.state.opt['cite-lang-prefs'].institutions;}else{localesets=this.state.opt['cite-lang-prefs'].persons;}var slot={primary:'locale-orig',secondary:false,tertiary:false};if(localesets){var slotnames=["primary","secondary","tertiary"];for(var k=0,klen=slotnames.length;k<klen;k+=1){if(localesets.length-1<k){break;}if(localesets[k]){slot[slotnames[k]]='locale-'+localesets[k];}}}else{slot.primary='locale-translat';}if(this.state.tmp.area!=="bibliography"&&!(this.state.tmp.area==="citation"&&this.state.opt.xclass==="note"&&this.item&&!this.item.position)){slot.secondary=false;slot.tertiary=false;}// Get normalized name object for a start.
// true invokes fallback
this.setRenderedName(name);// XXXX FROM HERE (instututions)
var institution=this._renderInstitutionName(v,name,slot,j);//this.institutions[v][j] = this._join(institution, "");
this.institutions[v][j]=institution;}}};CSL.NameOutput.prototype._renderInstitutionName=function(v,name,slot,j){var secondary,tertiary,long_style,short_style,institution,institution_short,institution_long;var res=this.getName(name,slot.primary,true);var primary=res.name;var usedOrig=res.usedOrig;if(primary){//print("primary, v, j = "+primary+", "+v+", "+j);
primary=this.fixupInstitution(primary,v,j);}secondary=false;if(slot.secondary){res=this.getName(name,slot.secondary,false,usedOrig);var secondary=res.name;usedOrig=res.usedOrig;if(secondary){secondary=this.fixupInstitution(secondary,v,j);}}//Zotero.debug("XXX [2] secondary: "+secondary["long"].literal+", slot.secondary: "+slot.secondary);
tertiary=false;if(slot.tertiary){res=this.getName(name,slot.tertiary,false,usedOrig);tertiary=res.name;if(tertiary){tertiary=this.fixupInstitution(tertiary,v,j);}}var n={l:{pri:false,sec:false,ter:false},s:{pri:false,sec:false,ter:false}};if(primary){n.l.pri=primary["long"];n.s.pri=primary["short"].length?primary["short"]:primary["long"];}if(secondary){n.l.sec=secondary["long"];n.s.sec=secondary["short"].length?secondary["short"]:secondary["long"];}if(tertiary){n.l.ter=tertiary["long"];n.s.ter=tertiary["short"].length?tertiary["short"]:tertiary["long"];}switch(this.institution.strings["institution-parts"]){case"short":// No multilingual for pure short form institution names.
if(primary["short"].length){short_style=this._getShortStyle();institution=[this._composeOneInstitutionPart([n.s.pri,n.s.sec,n.s.ter],slot,short_style,v)];}else{// Fail over to long.
long_style=this._getLongStyle(primary,v,j);institution=[this._composeOneInstitutionPart([n.l.pri,n.l.sec,n.l.ter],slot,long_style,v)];}break;case"short-long":long_style=this._getLongStyle(primary,v,j);short_style=this._getShortStyle();institution_short=this._renderOneInstitutionPart(primary["short"],short_style);// true is to include multilingual supplement
institution_long=this._composeOneInstitutionPart([n.l.pri,n.l.sec,n.l.ter],slot,long_style,v);institution=[institution_short,institution_long];break;case"long-short":long_style=this._getLongStyle(primary,v,j);short_style=this._getShortStyle();institution_short=this._renderOneInstitutionPart(primary["short"],short_style);// true is to include multilingual supplement
institution_long=this._composeOneInstitutionPart([n.l.pri,n.l.sec,n.l.ter],slot,long_style,v);institution=[institution_long,institution_short];break;default:long_style=this._getLongStyle(primary,v,j);// true is to include multilingual supplement
institution=[this._composeOneInstitutionPart([n.l.pri,n.l.sec,n.l.ter],slot,long_style,v)];break;}var blob=this._join(institution," ");if(blob){blob.isInstitution=true;}this.state.tmp.name_node.children.push(blob);return blob;};CSL.NameOutput.prototype._composeOneInstitutionPart=function(names,slot,style){var primary=false,secondary=false,tertiary=false,primary_tok,secondary_tok,tertiary_tok;if(names[0]){primary_tok=CSL.Util.cloneToken(style);if(this.state.opt.citeAffixes[slot.primary]){if("<i>"===this.state.opt.citeAffixes.institutions[slot.primary].prefix){var hasItalic=false;for(var i=0,ilen=primary_tok.decorations.length;i<ilen;i+=1){if(style.decorations[i][0]==="@font-style"&&primary_tok.decorations[i][1]==="italic"){hasItalic=true;}}if(!hasItalic){primary_tok.decorations.push(["@font-style","italic"]);}}}primary=this._renderOneInstitutionPart(names[0],primary_tok);}if(names[1]){secondary=this._renderOneInstitutionPart(names[1],style);}if(names[2]){tertiary=this._renderOneInstitutionPart(names[2],style);}// Compose
var institutionblob;if(secondary||tertiary){this.state.output.openLevel("empty");this.state.output.append(primary);secondary_tok=CSL.Util.cloneToken(style);if(slot.secondary){secondary_tok.strings.prefix=this.state.opt.citeAffixes.institutions[slot.secondary].prefix;secondary_tok.strings.suffix=this.state.opt.citeAffixes.institutions[slot.secondary].suffix;// Add a space if empty
if(!secondary_tok.strings.prefix){secondary_tok.strings.prefix=" ";}}var secondary_outer=new CSL.Token();secondary_outer.decorations.push(["@font-style","normal"]);secondary_outer.decorations.push(["@font-weight","normal"]);this.state.output.openLevel(secondary_outer);this.state.output.append(secondary,secondary_tok);this.state.output.closeLevel();tertiary_tok=CSL.Util.cloneToken(style);if(slot.tertiary){tertiary_tok.strings.prefix=this.state.opt.citeAffixes.institutions[slot.tertiary].prefix;tertiary_tok.strings.suffix=this.state.opt.citeAffixes.institutions[slot.tertiary].suffix;// Add a space if empty
if(!tertiary_tok.strings.prefix){tertiary_tok.strings.prefix=" ";}}var tertiary_outer=new CSL.Token();tertiary_outer.decorations.push(["@font-style","normal"]);tertiary_outer.decorations.push(["@font-weight","normal"]);this.state.output.openLevel(tertiary_outer);this.state.output.append(tertiary,tertiary_tok);this.state.output.closeLevel();this.state.output.closeLevel();institutionblob=this.state.output.pop();}else{institutionblob=primary;}return institutionblob;};CSL.NameOutput.prototype._renderOneInstitutionPart=function(blobs,style){for(var i=0,ilen=blobs.length;i<ilen;i+=1){if(blobs[i]){var str=blobs[i];// XXXXX Cut-and-paste code in multiple locations. This code block should be
// collected in a function.
// Tag: strip-periods-block
if(this.state.tmp.strip_periods){str=str.replace(/\./g,"");}else{for(var j=0,jlen=style.decorations.length;j<jlen;j+=1){if("@strip-periods"===style.decorations[j][0]&&"true"===style.decorations[j][1]){str=str.replace(/\./g,"");break;}}}//this.state.output.append(blobs[i], style, true);
this.state.tmp.group_context.tip.variable_success=true;this.state.tmp.can_substitute.replace(false,CSL.LITERAL);if(str==="!here>>>"){blobs[i]=false;}else{this.state.output.append(str,style,true);blobs[i]=this.state.output.pop();}}}if("undefined"===typeof this.institution.strings["part-separator"]){this.institution.strings["part-separator"]=this.state.tmp.name_delimiter;}return this._join(blobs,this.institution.strings["part-separator"]);};CSL.NameOutput.prototype._renderNames=function(v,values,pos,j){//
var ret=false;if(values.length){var names=[];for(var i=0,ilen=values.length;i<ilen;i+=1){var name=values[i];// XXX We'll start here with attempts.
// Figure out the three segments: primary, secondary, tertiary
var ret,localesets;if(this.state.tmp.extension){localesets=["sort"];}else if(name.isInstitution||name.literal){// Will never hit this in this function, but preserving
// in case we factor this out.
localesets=this.state.opt['cite-lang-prefs'].institutions;}else{localesets=this.state.opt['cite-lang-prefs'].persons;}var slot={primary:'locale-orig',secondary:false,tertiary:false};if(localesets){var slotnames=["primary","secondary","tertiary"];for(var k=0,klen=slotnames.length;k<klen;k+=1){if(localesets.length-1<k){break;}slot[slotnames[k]]='locale-'+localesets[k];}}else{slot.primary='locale-translat';}if(this.state.tmp.sort_key_flag||this.state.tmp.area!=="bibliography"&&!(this.state.tmp.area==="citation"&&this.state.opt.xclass==="note"&&this.item&&!this.item.position)){slot.secondary=false;slot.tertiary=false;}// primary
// true is for fallback
this.setRenderedName(name);if(!name.literal&&!name.isInstitution){var nameBlob=this._renderPersonalName(v,name,slot,pos,i,j);var nameToken=CSL.Util.cloneToken(this.name);this.state.output.append(nameBlob,nameToken,true);names.push(this.state.output.pop());}else{names.push(this._renderInstitutionName(v,name,slot,j));}}//ret = this._join(names, "");
ret=this.joinPersons(names,pos,j);}return ret;};CSL.NameOutput.prototype._renderPersonalName=function(v,name,slot,pos,i,j){// XXXX FROM HERE (persons)
var res=this.getName(name,slot.primary,true);var primary=this._renderOnePersonalName(res.name,pos,i,j);var secondary=false;if(slot.secondary){res=this.getName(name,slot.secondary,false,res.usedOrig);if(res.name){secondary=this._renderOnePersonalName(res.name,pos,i,j);}}var tertiary=false;if(slot.tertiary){res=this.getName(name,slot.tertiary,false,res.usedOrig);if(res.name){tertiary=this._renderOnePersonalName(res.name,pos,i,j);}}// Now compose them to a unit
var personblob;if(secondary||tertiary){this.state.output.openLevel("empty");this.state.output.append(primary);var secondary_tok=new CSL.Token();if(slot.secondary){secondary_tok.strings.prefix=this.state.opt.citeAffixes.persons[slot.secondary].prefix;secondary_tok.strings.suffix=this.state.opt.citeAffixes.persons[slot.secondary].suffix;// Add a space if empty
if(!secondary_tok.strings.prefix){secondary_tok.strings.prefix=" ";}}this.state.output.append(secondary,secondary_tok);var tertiary_tok=new CSL.Token();if(slot.tertiary){tertiary_tok.strings.prefix=this.state.opt.citeAffixes.persons[slot.tertiary].prefix;tertiary_tok.strings.suffix=this.state.opt.citeAffixes.persons[slot.tertiary].suffix;// Add a space if empty
if(!tertiary_tok.strings.prefix){tertiary_tok.strings.prefix=" ";}}this.state.output.append(tertiary,tertiary_tok);this.state.output.closeLevel();personblob=this.state.output.pop();}else{personblob=primary;}return personblob;};CSL.NameOutput.prototype._isRomanesque=function(name){// 0 = entirely non-romanesque
// 1 = mixed content
// 2 = pure romanesque
var ret=2;if(!name.family.replace(/\"/g,'').match(CSL.ROMANESQUE_REGEXP)){ret=0;}if(!ret&&name.given&&name.given.match(CSL.STARTSWITH_ROMANESQUE_REGEXP)){ret=1;}var top_locale;if(ret==2){if(name.multi&&name.multi.main){top_locale=name.multi.main.slice(0,2);}else if(this.Item.language){top_locale=this.Item.language.slice(0,2);}if(["ja","zh"].indexOf(top_locale)>-1){ret=1;}}//print("name: "+name.given+", multi: "+name.multi+", ret: "+ret);
return ret;};CSL.NameOutput.prototype._renderOnePersonalName=function(value,pos,i,j){var name=value;var dropping_particle=this._droppingParticle(name,pos,j);var family=this._familyName(name);var non_dropping_particle=this._nonDroppingParticle(name);var givenInfo=this._givenName(name,pos,i);var given=givenInfo.blob;var suffix=this._nameSuffix(name);if(given===false){dropping_particle=false;suffix=false;}var sort_sep=this.state.inheritOpt(this.name,"sort-separator");if(!sort_sep){sort_sep="";}var suffix_sep;if(name["comma-suffix"]){suffix_sep=", ";}else{suffix_sep=" ";}var romanesque=this._isRomanesque(name);function hasJoiningPunctuation(blob){if(!blob){return false;}else if("string"===typeof blob.blobs){if(["\u2019","\'","-"," "].indexOf(blob.blobs.slice(-1))>-1){return true;}else{return false;}}else{return hasJoiningPunctuation(blob.blobs[blob.blobs.length-1]);}}var has_hyphenated_non_dropping_particle=hasJoiningPunctuation(non_dropping_particle);var nbspace;if(["fr","ru","cs"].indexOf(this.state.opt["default-locale"][0].slice(0,2))>-1){nbspace="\u00a0";}else{nbspace=" ";}var blob,merged,first,second;if(romanesque===0){// XXX handle affixes for given and family
blob=this._join([non_dropping_particle,family,given],"");}else if(romanesque===1||name["static-ordering"]){// entry likes sort order
merged=this._join([non_dropping_particle,family],nbspace);blob=this._join([merged,given]," ");}else if(name["reverse-ordering"]){// entry likes reverse order
merged=this._join([non_dropping_particle,family],nbspace);blob=this._join([given,merged]," ");}else if(this.state.tmp.sort_key_flag){// ok with no affixes here
if(this.state.opt["demote-non-dropping-particle"]==="never"){merged=this._join([non_dropping_particle,family],nbspace);merged=this._join([merged,dropping_particle]," ");merged=this._join([merged,given],this.state.opt.sort_sep);blob=this._join([merged,suffix]," ");}else{second=this._join([given,dropping_particle,non_dropping_particle]," ");merged=this._join([family,second],this.state.opt.sort_sep);blob=this._join([merged,suffix]," ");}}else if(this.state.inheritOpt(this.name,"name-as-sort-order")==="all"||this.state.inheritOpt(this.name,"name-as-sort-order")==="first"&&i===0&&(j===0||"undefined"===typeof j)){//
// Discretionary sort ordering and inversions
//
if(["Lord","Lady"].indexOf(name.given)>-1){sort_sep=", ";}// XXX Needs a more robust solution than this
// XXX See https://forums.zotero.org/discussion/30974/any-idea-why-an-a-author-comes-last-in-the-bibliography/#Item_30
//if (["always", "display-and-sort"].indexOf(this.state.opt["demote-non-dropping-particle"]) > -1 && !has_hyphenated_non_dropping_particle) {
if(["always","display-and-sort"].indexOf(this.state.opt["demote-non-dropping-particle"])>-1){// Drop non-dropping particle
//second = this._join([given, dropping_particle, non_dropping_particle], " ");
second=this._join([given,dropping_particle],name["comma-dropping-particle"]+" ");// This would be a problem with al-Ghazali. Avoided by has_hyphenated_non_dropping_particle check above.
second=this._join([second,non_dropping_particle]," ");if(second&&this.given){second.strings.prefix=this.given.strings.prefix;second.strings.suffix=this.given.strings.suffix;}if(family&&this.family){family.strings.prefix=this.family.strings.prefix;family.strings.suffix=this.family.strings.suffix;}merged=this._join([family,second],sort_sep);blob=this._join([merged,suffix],sort_sep);}else{// Don't drop particle.
// Don't do this
//if (this.state.tmp.area === "bibliography" && !this.state.tmp.term_predecessor && non_dropping_particle) {
//    if (!has_hyphenated_non_dropping_particle) {
//        non_dropping_particle.blobs = CSL.Output.Formatters["capitalize-first"](this.state, non_dropping_particle.blobs)
//    }
//}
if(has_hyphenated_non_dropping_particle){first=this._join([non_dropping_particle,family],"");}else{first=this._join([non_dropping_particle,family],nbspace);}if(first&&this.family){first.strings.prefix=this.family.strings.prefix;first.strings.suffix=this.family.strings.suffix;}second=this._join([given,dropping_particle],name["comma-dropping-particle"]+" ");//second = this._join([given, dropping_particle], " ");
if(second&&this.given){second.strings.prefix=this.given.strings.prefix;second.strings.suffix=this.given.strings.suffix;}merged=this._join([first,second],sort_sep);blob=this._join([merged,suffix],sort_sep);}blob.isInverted=true;}else{// plain vanilla
if(name["dropping-particle"]&&name.family&&!name["non-dropping-particle"]){var dp=name["dropping-particle"];var apostrophes=["'","\u02bc","\u2019","-"];if(apostrophes.indexOf(dp.slice(-1))>-1&&dp.slice(0,-1)!=="de"){family=this._join([dropping_particle,family],"");dropping_particle=false;}}if(has_hyphenated_non_dropping_particle){second=this._join([non_dropping_particle,family],"");second=this._join([dropping_particle,second],nbspace);}else{second=this._join([dropping_particle,non_dropping_particle,family],nbspace);}second=this._join([second,suffix],suffix_sep);if(second&&this.family){second.strings.prefix=this.family.strings.prefix;second.strings.suffix=this.family.strings.suffix;}if(given&&this.given){given.strings.prefix=this.given.strings.prefix;given.strings.suffix=this.given.strings.suffix;}if(second.strings.prefix){name["comma-dropping-particle"]="";}var space;if(this.state.inheritOpt(this.name,"initialize-with")&&this.state.inheritOpt(this.name,"initialize-with").match(/[\u00a0\ufeff]/)&&givenInfo.initializationLevel===1){space=nbspace;}else{space=" ";}blob=this._join([given,second],name["comma-dropping-particle"]+space);}// XXX Just generally assume for the present that personal names render something
this.state.tmp.group_context.tip.variable_success=true;this.state.tmp.can_substitute.replace(false,CSL.LITERAL);this.state.tmp.term_predecessor=true;// notSerious
//this.state.output.append(blob, "literal", true);
//var ret = this.state.output.pop();
this.state.tmp.name_node.children.push(blob);return blob;};/*
        // Do not include given name, dropping particle or suffix in strict short form of name

        // initialize if appropriate
*/ // Input names should be touched by _normalizeNameInput()
// exactly once: this is not idempotent.
CSL.NameOutput.prototype._normalizeNameInput=function(value){var name={literal:value.literal,family:value.family,isInstitution:value.isInstitution,given:value.given,suffix:value.suffix,"comma-suffix":value["comma-suffix"],"non-dropping-particle":value["non-dropping-particle"],"dropping-particle":value["dropping-particle"],"static-ordering":value["static-ordering"],"static-particles":value["static-particles"],"reverse-ordering":value["reverse-ordering"],"full-form-always":value["full-form-always"],"parse-names":value["parse-names"],"comma-dropping-particle":"",block_initialize:value.block_initialize,multi:value.multi};this._parseName(name);return name;};// _transformNameset() replaced with enhanced transform.name().
CSL.NameOutput.prototype._stripPeriods=function(tokname,str){var decor_tok=this[tokname+"_decor"];if(str){if(this.state.tmp.strip_periods){str=str.replace(/\./g,"");}else if(decor_tok){for(var i=0,ilen=decor_tok.decorations.length;i<ilen;i+=1){if("@strip-periods"===decor_tok.decorations[i][0]&&"true"===decor_tok.decorations[i][1]){str=str.replace(/\./g,"");break;}}}}return str;};CSL.NameOutput.prototype._nonDroppingParticle=function(name){var ndp=name["non-dropping-particle"];if(ndp&&this.state.tmp.sort_key_flag){ndp=ndp.replace(/[\'\u2019]/,"");}var str=this._stripPeriods("family",ndp);if(this.state.output.append(str,this.family_decor,true)){return this.state.output.pop();}return false;};CSL.NameOutput.prototype._droppingParticle=function(name,pos,j){var dp=name["dropping-particle"];if(dp&&this.state.tmp.sort_key_flag){dp=dp.replace(/[\'\u2019]/,"");}var str=this._stripPeriods("given",dp);if(name["dropping-particle"]&&name["dropping-particle"].match(/^et.?al[^a-z]$/)){if(this.state.inheritOpt(this.name,"et-al-use-last")){if("undefined"===typeof j){this.etal_spec[pos].freeters=2;}else{this.etal_spec[pos].persons=2;}}else{if("undefined"===typeof j){this.etal_spec[pos].freeters=1;}else{this.etal_spec[pos].persons=1;}}name["comma-dropping-particle"]="";}else if(this.state.output.append(str,this.given_decor,true)){return this.state.output.pop();}return false;};CSL.NameOutput.prototype._familyName=function(name){var str=this._stripPeriods("family",name.family);if(this.state.output.append(str,this.family_decor,true)){return this.state.output.pop();}return false;};CSL.NameOutput.prototype._givenName=function(name,pos,i){var ret;// citation
//   use disambig as-is
// biblography
//   use disambig only if it boosts over the default
//   SO WHAT IS THE DEFAULT?
//   A: If "form" is short, it's 0.
//      If "form" is long, initialize-with exists (and initialize is not false) it's 1
//      If "form" is long, and initialize_with does not exist, it's 2.
var formIsShort=this.state.inheritOpt(this.name,"form","name-form","long")!=="long";var initializeIsTurnedOn=this.state.inheritOpt(this.name,"initialize")!==false;var hasInitializeWith="string"===typeof this.state.inheritOpt(this.name,"initialize-with")&&!name.block_initialize;var defaultLevel;var useLevel;if(name["full-form-always"]){useLevel=2;}else{if(formIsShort){defaultLevel=0;}else if(hasInitializeWith){defaultLevel=1;}else{defaultLevel=2;}var requestedLevel=this.state.tmp.disambig_settings.givens[pos][i];if(requestedLevel>defaultLevel){useLevel=requestedLevel;}else{useLevel=defaultLevel;}}var gdropt=this.state.citation.opt["givenname-disambiguation-rule"];if(gdropt&&gdropt.slice(-14)==="-with-initials"){hasInitializeWith=true;}if(name.family&&useLevel===1){if(hasInitializeWith){var initialize_with=this.state.inheritOpt(this.name,"initialize-with",false,"");name.given=CSL.Util.Names.initializeWith(this.state,name.given,initialize_with,!initializeIsTurnedOn);}else{name.given=CSL.Util.Names.unInitialize(this.state,name.given);}}else if(useLevel===0){return{blob:false};}else if(useLevel===2){name.given=CSL.Util.Names.unInitialize(this.state,name.given);}var str=this._stripPeriods("given",name.given);var rendered=this.state.output.append(str,this.given_decor,true);if(rendered){ret=this.state.output.pop();return{blob:ret,initializationLevel:useLevel};}return{blob:false};};CSL.NameOutput.prototype._nameSuffix=function(name){var str=name.suffix,ret;if(str&&"string"===typeof this.state.inheritOpt(this.name,"initialize-with")){str=CSL.Util.Names.initializeWith(this.state,str,this.state.inheritOpt(this.name,"initialize-with"),true);}str=this._stripPeriods("family",str);var toSuffix='';if(str&&str.slice(-1)==='.'){str=str.slice(0,-1);toSuffix='.';}var rendered=this.state.output.append(str,"empty",true);if(rendered){ret=this.state.output.pop();ret.strings.suffix=toSuffix+ret.strings.suffix;return ret;}return false;};CSL.NameOutput.prototype._getLongStyle=function(name){var long_style;if(name["short"].length){if(this.institutionpart["long-with-short"]){long_style=this.institutionpart["long-with-short"];}else{long_style=this.institutionpart["long"];}}else{long_style=this.institutionpart["long"];}if(!long_style){long_style=new CSL.Token();}return long_style;};CSL.NameOutput.prototype._getShortStyle=function(){var short_style;if(this.institutionpart["short"]){short_style=this.institutionpart["short"];}else{short_style=new CSL.Token();}return short_style;};CSL.NameOutput.prototype._parseName=function(name){if(!name["parse-names"]&&"undefined"!==typeof name["parse-names"]){return name;}if(name.family&&!name.given&&name.isInstitution){name.literal=name.family;name.family=undefined;name.isInstitution=undefined;}var noparse;if(name.family&&name.family.slice(0,1)==='"'&&name.family.slice(-1)==='"'||!name["parse-names"]&&"undefined"!==typeof name["parse-names"]){name.family=name.family.slice(1,-1);noparse=true;name["parse-names"]=0;}else{noparse=false;}if(this.state.opt.development_extensions.parse_names){if(!name["non-dropping-particle"]&&name.family&&!noparse&&name.given){if(!name["static-particles"]){CSL.parseParticles(name,true);}}}};/*
 * Return a single name object
  */ // The interface is a mess, but this should serve.
CSL.NameOutput.prototype.getName=function(name,slotLocaleset,fallback,stopOrig){// Needs to tell us whether we used orig or not.
if(stopOrig&&slotLocaleset==='locale-orig'){return{name:false,usedOrig:stopOrig};}// Normalize to string
if(!name.family){name.family="";}if(!name.given){name.given="";}// Recognized params are:
//  block-initialize
//  transliterated
//  static-ordering
//  full-form-always
// All default to false, except for static-ordering, which is initialized
// with a sniff.
var name_params={};// Determines the default static-order setting based on the characters
// used in the headline field. Will be overridden by locale-based
// parameters evaluated against explicit lang tags set on the (sub)field.
name_params["static-ordering"]=this.getStaticOrder(name);var foundTag=true;var langTag;if(slotLocaleset!=='locale-orig'){foundTag=false;if(name.multi){var langTags=this.state.opt[slotLocaleset];for(var i=0,ilen=langTags.length;i<ilen;i+=1){langTag=langTags[i];if(name.multi._key[langTag]){foundTag=true;var isInstitution=name.isInstitution;name=name.multi._key[langTag];name.isInstitution=isInstitution;// Set name formatting params
name_params=this.getNameParams(langTag);name_params.transliterated=true;break;}}}}if(!foundTag){langTag=false;if(name.multi&&name.multi.main){langTag=name.multi.main;}else if(this.Item.language){langTag=this.Item.language;}if(langTag){name_params=this.getNameParams(langTag);}}if(!fallback&&!foundTag){return{name:false,usedOrig:stopOrig};}// Normalize to string (again)
if(!name.family){name.family="";}if(!name.given){name.given="";}if(name.literal){delete name.family;delete name.given;}// var clone the item before writing into it
name={family:name.family,given:name.given,"non-dropping-particle":name["non-dropping-particle"],"dropping-particle":name["dropping-particle"],suffix:name.suffix,"static-ordering":name_params["static-ordering"],"static-particles":name["static-particles"],"reverse-ordering":name_params["reverse-ordering"],"full-form-always":name_params["full-form-always"],"parse-names":name["parse-names"],"comma-suffix":name["comma-suffix"],"comma-dropping-particle":name["comma-dropping-particle"],transliterated:name_params.transliterated,block_initialize:name_params["block-initialize"],literal:name.literal,isInstitution:name.isInstitution,multi:name.multi};if(!name.literal&&!name.given&&name.family&&name.isInstitution){name.literal=name.family;}if(name.literal){delete name.family;delete name.given;}name=this._normalizeNameInput(name);var usedOrig;if(stopOrig){usedOrig=stopOrig;}else{usedOrig=!foundTag;}return{name:name,usedOrig:usedOrig};};CSL.NameOutput.prototype.getNameParams=function(langTag){var ret={};var langspec=CSL.localeResolve(this.Item.language,this.state.opt["default-locale"][0]);var try_locale=this.state.locale[langspec.best]?langspec.best:this.state.opt["default-locale"][0];var name_as_sort_order=this.state.locale[try_locale].opts["name-as-sort-order"];var name_as_reverse_order=this.state.locale[try_locale].opts["name-as-reverse-order"];var name_never_short=this.state.locale[try_locale].opts["name-never-short"];var field_lang_bare=langTag.split("-")[0];if(name_as_sort_order&&name_as_sort_order[field_lang_bare]){ret["static-ordering"]=true;ret["reverse-ordering"]=false;}if(name_as_reverse_order&&name_as_reverse_order[field_lang_bare]){ret["reverse-ordering"]=true;ret["static-ordering"]=false;}if(name_never_short&&name_never_short[field_lang_bare]){ret["full-form-always"]=true;}if(ret["static-ordering"]){ret["block-initialize"]=true;}return ret;};CSL.NameOutput.prototype.setRenderedName=function(name){if(this.state.tmp.area==="bibliography"){var strname="";for(var j=0,jlen=CSL.NAME_PARTS.length;j<jlen;j+=1){if(name[CSL.NAME_PARTS[j]]){strname+=name[CSL.NAME_PARTS[j]];}}this.state.tmp.rendered_name.push(strname);}};CSL.NameOutput.prototype.fixupInstitution=function(name,varname,listpos){if(!name.literal&&name.family){name.literal=name.family;delete name.family;}var longNameStr=name.literal;var shortNameStr=longNameStr;var ret={"long":longNameStr.split(/\s*\|\s*/),"short":shortNameStr.split(/\s*\|\s*/)};if(this.state.sys.getAbbreviation){// Normalize longNameStr and shortNameStr
if(this.institution.strings.form==="short"){let jurisdiction=this.Item.jurisdiction;jurisdiction=this.state.transform.loadAbbreviation(jurisdiction,"institution-entire",longNameStr,this.Item.language);if(this.state.transform.abbrevs[jurisdiction]["institution-entire"][longNameStr]){longNameStr=this.state.transform.abbrevs[jurisdiction]["institution-entire"][longNameStr];}else{jurisdiction=this.Item.jurisdiction;jurisdiction=this.state.transform.loadAbbreviation(jurisdiction,"institution-part",longNameStr,this.Item.language);if(this.state.transform.abbrevs[jurisdiction]["institution-part"][longNameStr]){longNameStr=this.state.transform.abbrevs[jurisdiction]["institution-part"][longNameStr];}}longNameStr=this._quashChecks(jurisdiction,longNameStr);}if(["short","short-long","long-short"].indexOf(this.institution.strings["institution-parts"])>-1){let jurisdiction=this.Item.jurisdiction;jurisdiction=this.state.transform.loadAbbreviation(jurisdiction,"institution-part",shortNameStr,this.Item.language);if(this.state.transform.abbrevs[jurisdiction]["institution-part"][shortNameStr]){shortNameStr=this.state.transform.abbrevs[jurisdiction]["institution-part"][shortNameStr];}shortNameStr=this._quashChecks(jurisdiction,shortNameStr);if(["short-long","long-short"].indexOf(this.institution.strings["institution-parts"])>-1){if(shortNameStr===longNameStr){shortNameStr="";}}}// Split abbreviated strings
// For pure long, split and we're done.
ret["long"]=longNameStr.split(/\s*\|\s*/);// For short, split and then try abbrev with institution-part on each element
ret["short"]=shortNameStr.split(/\s*\|\s*/);if(["short","short-long","long-short"].indexOf(this.institution.strings["institution-parts"])>-1){for(var j=ret["short"].length-1;j>-1;j--){let jurisdiction=this.Item.jurisdiction;var abbrevKey=ret["short"][j];jurisdiction=this.state.transform.loadAbbreviation(jurisdiction,"institution-part",abbrevKey,this.Item.language);if(this.state.transform.abbrevs[jurisdiction]["institution-part"][abbrevKey]){ret["short"][j]=this.state.transform.abbrevs[jurisdiction]["institution-part"][abbrevKey];}if(ret["short"][j].indexOf("|")>-1){let retShort=ret["short"];let splitShort=retShort[j].split(/\s*\|\s*/);ret["short"]=retShort.slice(0,j).concat(splitShort).concat(retShort.slice(j+1));}}}if(this.state.opt.development_extensions.legacy_institution_name_ordering){ret["short"].reverse();}ret["short"]=this._trimInstitution(ret["short"]);if(this.institution.strings["reverse-order"]){ret["short"].reverse();}// trimmer is not available in getAmbiguousCite
if(!this.state.tmp.just_looking){if(this.Item.jurisdiction){let jurisdiction=this.Item.jurisdiction;var trimmer=this.state.tmp.abbrev_trimmer;if(trimmer&&trimmer[jurisdiction]&&trimmer[jurisdiction][varname]){for(var i=0,ilen=ret["short"].length;i<ilen;i++){var frag=ret["short"][i];ret["short"][i]=frag.replace(trimmer[jurisdiction][varname],"").trim();}}}}}if(this.state.opt.development_extensions.legacy_institution_name_ordering){ret["long"].reverse();}ret["long"]=this._trimInstitution(ret["long"]);if(this.institution.strings["reverse-order"]){ret["long"].reverse();}return ret;};CSL.NameOutput.prototype.getStaticOrder=function(name,refresh){var static_ordering_val=false;if(!refresh&&name["static-ordering"]){static_ordering_val=true;}else if(this._isRomanesque(name)===0){static_ordering_val=true;}else if((!name.multi||!name.multi.main)&&this.Item.language&&['vi','hu'].indexOf(this.Item.language)>-1){static_ordering_val=true;}else if(name.multi&&name.multi.main&&['vi','hu'].indexOf(name.multi.main.slice(0,2))>-1){static_ordering_val=true;}else{if(this.state.opt['auto-vietnamese-names']&&CSL.VIETNAMESE_NAMES.exec(name.family+" "+name.given)&&CSL.VIETNAMESE_SPECIALS.exec(name.family+name.given)){static_ordering_val=true;}}return static_ordering_val;};CSL.NameOutput.prototype._quashChecks=function(jurisdiction,str){var str=this.state.transform.quashCheck(jurisdiction,str);// If the abbreviation has date cut-offs, find the most recent
// abbreviation within scope.
var lst=str.split(/>>[0-9]{4}>>/);var m=str.match(/>>([0-9]{4})>>/);str=lst.pop();var date=this.Item["original-date"]?this.Item["original-date"]:this.Item["issued"];if(date){date=parseInt(date.year,10);date=isNaN(date)?false:date;}if(date){if(lst.length>0){for(var k=m.length-1;k>0;k--){if(date>=parseInt(m[k],10)){break;}str=lst.pop();}}str=str.replace(/\s*\|\s*/g,"|");}return str;};CSL.NameOutput.prototype._trimInstitution=function(subunits){// Oh! Good catch in the tests. This happens before abbrevs.
// Won't work that way. Need to do abbrev substitute first,
// and apply this separately to long and to short.
var use_first=false;var stop_last=false;var use_last=false;var stop_first=false;var s=subunits.slice();if(this.institution){// If use_first, apply stop_last, then apply use_first;
// If use_last, apply stop_first, then apply use_last;
if("undefined"!==typeof this.institution.strings["use-first"]){// this.state.sys.print("use-first OK");
use_first=this.institution.strings["use-first"];}if("undefined"!==typeof this.institution.strings["use-last"]){// this.state.sys.print("use-last OK");
use_last=this.institution.strings["use-last"];}if("undefined"!==typeof this.institution.strings["stop-first"]){// this.state.sys.print("stop-first OK");
stop_first=this.institution.strings["stop-first"];}if("undefined"!==typeof this.institution.strings["stop-last"]){stop_last=this.institution.strings["stop-last"];}if(use_first){if(stop_last){s=s.slice(0,stop_last*-1);}s=s.slice(0,use_first);}if(use_last){var ss=subunits.slice();if(use_first){stop_first=use_first;}else{s=[];}if(stop_first){ss=ss.slice(stop_first);}ss=ss.slice(use_last*-1);s=s.concat(ss);}subunits=s;}return subunits;};/*global CSL: true */CSL.PublisherOutput=function(state,group_tok){this.state=state;this.group_tok=group_tok;this.varlist=[];};CSL.PublisherOutput.prototype.render=function(){this.clearVars();this.composeAndBlob();this.composeElements();this.composePublishers();this.joinPublishers();};// XXX Figure out how to adapt this to the House of Lords / House of Commons
// joint committee case
// name_delimiter
// delimiter_precedes_last
// and
CSL.PublisherOutput.prototype.composeAndBlob=function(){this.and_blob={};var and_term=false;if(this.group_tok.strings.and==="text"){and_term=this.state.getTerm("and");}else if(this.group_tok.strings.and==="symbol"){and_term="&";}var tok=new CSL.Token();tok.strings.suffix=" ";tok.strings.prefix=" ";this.state.output.append(and_term,tok,true);var no_delim=this.state.output.pop();tok.strings.prefix=this.group_tok.strings["subgroup-delimiter"];this.state.output.append(and_term,tok,true);var with_delim=this.state.output.pop();this.and_blob.single=false;this.and_blob.multiple=false;if(and_term){if(this.group_tok.strings["subgroup-delimiter-precedes-last"]==="always"){this.and_blob.single=with_delim;}else if(this.group_tok.strings["subgroup-delimiter-precedes-last"]==="never"){this.and_blob.single=no_delim;this.and_blob.multiple=no_delim;}else{this.and_blob.single=no_delim;this.and_blob.multiple=with_delim;}}};CSL.PublisherOutput.prototype.composeElements=function(){for(var i=0,ilen=2;i<ilen;i+=1){var varname=["publisher","publisher-place"][i];for(var j=0,jlen=this["publisher-list"].length;j<jlen;j+=1){var str=this[varname+"-list"][j];var tok=this[varname+"-token"];// notSerious
this.state.output.append(str,tok,true);this[varname+"-list"][j]=this.state.output.pop();}}};CSL.PublisherOutput.prototype.composePublishers=function(){var blobs;for(var i=0,ilen=this["publisher-list"].length;i<ilen;i+=1){blobs=[this[this.varlist[0]+"-list"][i],this[this.varlist[1]+"-list"][i]];this["publisher-list"][i]=this._join(blobs,this.group_tok.strings.delimiter);}};CSL.PublisherOutput.prototype.joinPublishers=function(){var blobs=this["publisher-list"];var publishers=this._join(blobs,this.group_tok.strings["subgroup-delimiter"],this.and_blob.single,this.and_blob.multiple,this.group_tok);this.state.output.append(publishers,"literal");};// blobs, delimiter, single, multiple, tokenname
// Tokenname is a key at top level of this object.
CSL.PublisherOutput.prototype._join=CSL.NameOutput.prototype._join;CSL.PublisherOutput.prototype._getToken=CSL.NameOutput.prototype._getToken;CSL.PublisherOutput.prototype.clearVars=function(){this.state.tmp["publisher-list"]=false;this.state.tmp["publisher-place-list"]=false;this.state.tmp["publisher-group-token"]=false;this.state.tmp["publisher-token"]=false;this.state.tmp["publisher-place-token"]=false;};/*global CSL: true */CSL.evaluateLabel=function(node,state,Item,item){var myterm;if("locator"===node.strings.term){if(item&&item.label){if(item.label==="sub verbo"){myterm="sub-verbo";}else{myterm=item.label;}}if(!myterm){myterm="page";}}else{myterm=node.strings.term;}// Plurals detection.
var plural=node.strings.plural;if("number"!==typeof plural){// (node, ItemObject, variable, type)
var theItem=item&&node.strings.term==="locator"?item:Item;if(theItem[node.strings.term]){state.processNumber(false,theItem,node.strings.term,Item.type);plural=state.tmp.shadow_numbers[node.strings.term].plural;if(!state.tmp.shadow_numbers[node.strings.term].labelForm&&!state.tmp.shadow_numbers[node.strings.term].labelDecorations){if(node.strings.form){state.tmp.shadow_numbers[node.strings.term].labelForm=node.strings.form;}else if(state.tmp.group_context.tip.label_form){state.tmp.shadow_numbers[node.strings.term].labelForm=state.tmp.group_context.tip.label_form;}state.tmp.shadow_numbers[node.strings.term].labelCapitalizeIfFirst=node.strings.capitalize_if_first;state.tmp.shadow_numbers[node.strings.term].labelDecorations=node.decorations.slice();}if(["locator","number","page"].indexOf(node.strings.term)>-1&&state.tmp.shadow_numbers[node.strings.term].label){myterm=state.tmp.shadow_numbers[node.strings.term].label;}if(node.decorations&&state.opt.development_extensions.csl_reverse_lookup_support){node.decorations.reverse();node.decorations.push(["@showid","true",node.cslid]);node.decorations.reverse();}}}return CSL.castLabel(state,node,myterm,plural,CSL.TOLERANT);};CSL.castLabel=function(state,node,term,plural,mode){var label_form=node.strings.form;var label_capitalize_if_first=node.strings.capitalize_if_first;if(state.tmp.group_context.tip.label_form){if(label_form==="static"){state.tmp.group_context.tip.label_static=true;}else{label_form=state.tmp.group_context.tip.label_form;}}if(state.tmp.group_context.tip.label_capitalize_if_first){label_capitalize_if_first=state.tmp.group_context.tip.label_capitalize_if_first;}var ret=state.getTerm(term,label_form,plural,false,mode,node.default_locale);if(label_capitalize_if_first){ret=CSL.Output.Formatters["capitalize-first"](state,ret);}// XXXXX Cut-and-paste code in multiple locations. This code block should be
// collected in a function.
// Tag: strip-periods-block
if(state.tmp.strip_periods){ret=ret.replace(/\./g,"");}else{for(var i=0,ilen=node.decorations.length;i<ilen;i+=1){if("@strip-periods"===node.decorations[i][0]&&"true"===node.decorations[i][1]){ret=ret.replace(/\./g,"");break;}}}return ret;};/*global CSL: true */CSL.Node.name={build:function(state,target){var func;if([CSL.SINGLETON,CSL.START].indexOf(this.tokentype)>-1){var oldTmpRoot;if("undefined"===typeof state.tmp.root){oldTmpRoot=undefined;state.tmp.root="citation";}else{oldTmpRoot=state.tmp.root;}// Many CSL styles set et-al-[min|use-first]
// and et-al-subsequent-[min|use-first] to the same
// value.
// Set state.opt.update_mode = CSL.POSITION if
// et-al-subsequent-min or et-al-subsequent-use-first
// are set AND their value differs from their plain
// counterparts.
if(state.inheritOpt(this,"et-al-subsequent-min")&&state.inheritOpt(this,"et-al-subsequent-min")!==state.inheritOpt(this,"et-al-min")){state.opt.update_mode=CSL.POSITION;}if(state.inheritOpt(this,"et-al-subsequent-use-first")&&state.inheritOpt(this,"et-al-subsequent-use-first")!==state.inheritOpt(this,"et-al-use-first")){state.opt.update_mode=CSL.POSITION;}state.tmp.root=oldTmpRoot;func=function(state){// Et-al (onward processing in node_etal.js and node_names.js)
// XXXXX Why is this necessary? This is available on this.name, right?
state.tmp.etal_term="et-al";// Use default delimiter as fallback, in a way that allows explicit
// empty strings.
state.tmp.name_delimiter=state.inheritOpt(this,"delimiter","name-delimiter",", ");state.tmp["delimiter-precedes-et-al"]=state.inheritOpt(this,"delimiter-precedes-et-al");// And
if("text"===state.inheritOpt(this,"and")){this.and_term=state.getTerm("and","long",0);}else if("symbol"===state.inheritOpt(this,"and")){if(state.opt.development_extensions.expect_and_symbol_form){this.and_term=state.getTerm("and","symbol",0);}else{this.and_term="&";}}state.tmp.and_term=this.and_term;if(CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)){this.and_prefix_single=" ";this.and_prefix_multiple=", ";// Workaround to allow explicit empty string
// on cs:name delimiter.
if("string"===typeof state.tmp.name_delimiter){this.and_prefix_multiple=state.tmp.name_delimiter;}this.and_suffix=" ";// Really can't inspect these values in the build phase. Sorry.
//state.build.name_delimiter = this.strings.delimiter;
}else{this.and_prefix_single="";this.and_prefix_multiple="";this.and_suffix="";}if(state.inheritOpt(this,"delimiter-precedes-last")==="always"){this.and_prefix_single=state.tmp.name_delimiter;}else if(state.inheritOpt(this,"delimiter-precedes-last")==="never"){// Slightly fragile: could test for charset here to make
// this more certain.
if(this.and_prefix_multiple){this.and_prefix_multiple=" ";}}else if(state.inheritOpt(this,"delimiter-precedes-last")==="after-inverted-name"){if(this.and_prefix_single){this.and_prefix_single=state.tmp.name_delimiter;}if(this.and_prefix_multiple){this.and_prefix_multiple=" ";}}this.and={};if(state.inheritOpt(this,"and")){state.output.append(this.and_term,"empty",true);this.and.single=state.output.pop();this.and.single.strings.prefix=this.and_prefix_single;this.and.single.strings.suffix=this.and_suffix;state.output.append(this.and_term,"empty",true);this.and.multiple=state.output.pop();this.and.multiple.strings.prefix=this.and_prefix_multiple;this.and.multiple.strings.suffix=this.and_suffix;}else if(state.tmp.name_delimiter){// This is a little weird, but it works.
this.and.single=new CSL.Blob(state.tmp.name_delimiter);this.and.single.strings.prefix="";this.and.single.strings.suffix="";this.and.multiple=new CSL.Blob(state.tmp.name_delimiter);this.and.multiple.strings.prefix="";this.and.multiple.strings.suffix="";}this.ellipsis={};if(state.inheritOpt(this,"et-al-use-last")){// We use the dedicated Unicode ellipsis character because
// it is recommended by some editors, and can be more easily
// identified for find and replace operations.
// Source: http://en.wikipedia.org/wiki/Ellipsis#Computer_representations
//
// Eventually, this should be localized as a term in CSL, with some
// mechanism for triggering appropriate punctuation handling around
// the ellipsis placeholder (Polish is a particularly tough case for that).
this.ellipsis_term="\u2026";// Similar treatment to "and", above, will be needed
// here when this becomes a locale term.
this.ellipsis_prefix_single=" ";this.ellipsis_prefix_multiple=state.inheritOpt(this,"delimiter","name-delimiter",", ");this.ellipsis_suffix=" ";this.ellipsis.single=new CSL.Blob(this.ellipsis_term);this.ellipsis.single.strings.prefix=this.ellipsis_prefix_single;this.ellipsis.single.strings.suffix=this.ellipsis_suffix;this.ellipsis.multiple=new CSL.Blob(this.ellipsis_term);this.ellipsis.multiple.strings.prefix=this.ellipsis_prefix_multiple;this.ellipsis.multiple.strings.suffix=this.ellipsis_suffix;}// et-al parameters are annoyingly incomprehensible
// again.
//
// Explanation probably just adds a further layer of
// irritation, but what's INTENDED here is that
// the state.tmp et-al variables are set from the
// cs:key element when composing sort keys, and a
// macro containing a name can be called from cs:key.
// So when cs:key sets et-al attributes, they are
// set on state.tmp, and when the key is finished
// processing, the state.tmp variables are reset to
// undefined. IN THEORY the state.tmp et-al variables
// will not be used in other contexts. I hope.
//
// Anyway, the current tests now seem to pass.
if("undefined"===typeof state.tmp["et-al-min"]){state.tmp["et-al-min"]=state.inheritOpt(this,"et-al-min");}if("undefined"===typeof state.tmp["et-al-use-first"]){state.tmp["et-al-use-first"]=state.inheritOpt(this,"et-al-use-first");}if("undefined"===typeof state.tmp["et-al-use-last"]){//print("  setting et-al-use-last from name: "+this.strings["et-al-use-last"]);
state.tmp["et-al-use-last"]=state.inheritOpt(this,"et-al-use-last");}state.nameOutput.name=this;};state.build.name_flag=true;this.execs.push(func);}target.push(this);}};/*global CSL: true */CSL.Node["name-part"]={build:function(state){state.build[this.strings.name]=this;}};/*global CSL: true */CSL.Node.names={build:function(state,target){var func;// CSL.debug = print;
if(this.tokentype===CSL.START||this.tokentype===CSL.SINGLETON){CSL.Util.substituteStart.call(this,state,target);state.build.substitute_level.push(1);}if(this.tokentype===CSL.SINGLETON){state.build.names_variables[state.build.names_variables.length-1].concat(this.variables);for(var i in this.variables){var variable=this.variables[i];var name_labels=state.build.name_label[state.build.name_label.length-1];if(Object.keys(name_labels).length){name_labels[variable]=name_labels[Object.keys(name_labels)[0]];}}func=function(state){state.nameOutput.reinit(this,this.variables_real[0]);};this.execs.push(func);}if(this.tokentype===CSL.START){state.build.names_flag=true;state.build.name_flag=false;state.build.names_level+=1;state.build.names_variables.push(this.variables);state.build.name_label.push({});// init can substitute
// init names
func=function(state){state.tmp.can_substitute.push(true);state.tmp.name_node={};state.tmp.name_node.children=[];state.nameOutput.init(this);};this.execs.push(func);}if(this.tokentype===CSL.END){// Set/reset name blobs if they exist, for processing
// by namesOutput()
for(var i=0,ilen=3;i<ilen;i+=1){var key=["family","given","et-al"][i];this[key]=state.build[key];if(state.build.names_level===1){state.build[key]=undefined;}}// Labels, if any
this.label=state.build.name_label[state.build.name_label.length-1];state.build.names_level+=-1;state.build.names_variables.pop();state.build.name_label.pop();// The with term. This isn't the right place
// for this, but it's all hard-wired at the
// moment.
// "and" and "ellipsis" are set in node_name.js
func=function(state){// Et-al (strings only)
// Blob production has to happen inside nameOutput()
// since proper escaping requires access to the output
// queue.
if(state.tmp.etal_node){this.etal_style=state.tmp.etal_node;}else{this.etal_style="empty";}this.etal_term=state.getTerm(state.tmp.etal_term,"long",0);this.etal_prefix_single=" ";// Should be name delimiter, not hard-wired.
this.etal_prefix_multiple=state.tmp.name_delimiter;if(state.tmp["delimiter-precedes-et-al"]==="always"){this.etal_prefix_single=state.tmp.name_delimiter;}else if(state.tmp["delimiter-precedes-et-al"]==="never"){this.etal_prefix_multiple=" ";}else if(state.tmp["delimiter-precedes-et-al"]==="after-inverted-name"){this.etal_prefix_single=state.tmp.name_delimiter;this.etal_prefix_multiple=" ";}this.etal_suffix="";if(!CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.etal_term)){// Not sure what the correct treatment is here, but we should not suppress
// a comma-space.
// https://forums.zotero.org/discussion/76679/delimiter-precedes-et-al-always-dose-not-work-in-locale-zh-cn
if(this.etal_prefix_single===" "){this.etal_prefix_single="";}if(this.etal_prefix_multiple===" "){this.etal_prefix_multiple="";}if(this.etal_suffix===" "){this.etal_suffix="";}}// et-al affixes are further adjusted in nameOutput(),
// after the term (possibly changed in cs:et-al) is known.
for(var i=0,ilen=3;i<ilen;i+=1){var key=["family","given"][i];state.nameOutput[key]=this[key];}state.nameOutput["with"]=this["with"];// REMOVE THIS
var mywith="with";var with_default_prefix="";var with_suffix="";if(CSL.STARTSWITH_ROMANESQUE_REGEXP.test(mywith)){with_default_prefix=" ";with_suffix=" ";}var thewith={};thewith.single=new CSL.Blob(mywith);thewith.single.strings.suffix=with_suffix;thewith.multiple=new CSL.Blob(mywith);thewith.multiple.strings.suffix=with_suffix;if(state.inheritOpt(state.nameOutput.name,"delimiter-precedes-last")==="always"){thewith.single.strings.prefix=state.inheritOpt(this,"delimiter","names-delimiter");thewith.multiple.strings.prefix=state.inheritOpt(this,"delimiter","names-delimiter");}else if(state.inheritOpt(state.nameOutput.name,"delimiter-precedes-last")==="contextual"){thewith.single.strings.prefix=with_default_prefix;thewith.multiple.strings.prefix=state.inheritOpt(this,"delimiter","names-delimiter");}else if(state.inheritOpt(state.nameOutput.name,"delimiter-precedes-last")==="after-inverted-name"){thewith.single.strings.prefix=state.inheritOpt(this,"delimiter","names-delimiter");thewith.multiple.strings.prefix=with_default_prefix;}else{thewith.single.strings.prefix=with_default_prefix;thewith.multiple.strings.prefix=with_default_prefix;}state.nameOutput["with"]=thewith;// XXX label style should be set per variable, since they may differ
// XXX with full-form nested names constructs
state.nameOutput.label=this.label;state.nameOutput.etal_style=this.etal_style;state.nameOutput.etal_term=this.etal_term;state.nameOutput.etal_prefix_single=this.etal_prefix_single;state.nameOutput.etal_prefix_multiple=this.etal_prefix_multiple;state.nameOutput.etal_suffix=this.etal_suffix;state.nameOutput.outputNames();state.tmp["et-al-use-first"]=undefined;state.tmp["et-al-min"]=undefined;state.tmp["et-al-use-last"]=undefined;};this.execs.push(func);// unsets
func=function(state){if(!state.tmp.can_substitute.pop()){state.tmp.can_substitute.replace(false,CSL.LITERAL);}// For posterity ...
//
// This was enough to fix the issue reported here:
//
//   http://forums.zotero.org/discussion/25223/citeproc-bug-substitute-doesnt-work-correctly-for-title-macro/
//
// The remainder of the changes applied in the same patch
// relate to a label assignments, which were found to be
// buggy while working on the issue. The test covering
// both problems is here:
//
//   https://bitbucket.org/bdarcus/citeproc-test/src/ab136a6aa8f2/processor-tests/humans/substitute_SuppressOrdinaryVariable.txt
if(state.tmp.can_substitute.mystack.length===1){state.tmp.can_block_substitute=false;}};this.execs.push(func);state.build.name_flag=false;}target.push(this);if(this.tokentype===CSL.END||this.tokentype===CSL.SINGLETON){state.build.substitute_level.pop();CSL.Util.substituteEnd.call(this,state,target);}}};/*global CSL: true */CSL.Node.number={build:function(state,target){var func;CSL.Util.substituteStart.call(this,state,target);//
// This should push a rangeable object to the queue.
//
if(this.strings.form==="roman"){this.formatter=state.fun.romanizer;}else if(this.strings.form==="ordinal"){this.formatter=state.fun.ordinalizer;}else if(this.strings.form==="long-ordinal"){this.formatter=state.fun.long_ordinalizer;}if("undefined"===typeof this.successor_prefix){this.successor_prefix=state[state.build.area].opt.layout_delimiter;}if("undefined"===typeof this.splice_prefix){this.splice_prefix=state[state.build.area].opt.layout_delimiter;}// is this needed?
//if ("undefined" === typeof this.splice_prefix){
//    this.splice_prefix = state[state.tmp.area].opt.layout_delimiter;
//}
//
// Whether we actually stick a number object on
// the output queue depends on whether the field
// contains a pure number.
//
// push number or text
func=function(state,Item,item){// NOTE: this works because this is the ONLY function in this node.
// If further functions are added, they need to start with the same
// abort condition.
if(this.variables.length===0){return;}var varname;varname=this.variables[0];if("undefined"===typeof item){var item={};}if(["locator","locator-extra"].indexOf(varname)>-1){if(state.tmp.just_looking){return;}if(!item[varname]){return;}}else{if(!Item[varname]){return;}}if(varname==='collection-number'&&Item.type==='legal_case'){state.tmp.renders_collection_number=true;}// For bill or legislation items that have a label-form
// attribute set on the cs:number node rendering the locator,
// the form and pluralism of locator terms are controlled
// separately from those of the initial label. Form is
// straightforward: the label uses the value set on
// the cs:label node that renders it, and the embedded
// labels use the value of label-form set on the cs:number
// node. Both default to "long".
//
// Pluralism is more complicated. For embedded labels,
// pluralism is evaluated using a simple heuristic that
// can be found below (it just looks for comma, ampersand etc).
// The item.label rendered independently via cs:label
// defaults to singular. It is always singular if embedded
// labels exist that (when expanded to their valid CSL
// value) do not match the value of item.label. Otherwise,
// if one or more matching embedded labels exist, the
// cs:label is set to plural.
//
// The code that does all this is divided between this module,
// util_static_locator.js, and util_label.js. It's not easy
// to follow, but seems to do the job. Let's home for good
// luck out there in the wild.
var node=this;if(state.tmp.group_context.tip.force_suppress){return false;}if(["locator","locator-extra"].indexOf(varname)>-1){// amazing that we reach this. should abort sooner if no content?
state.processNumber.call(state,node,item,varname,Item.type);}else{if(!state.tmp.group_context.tip.condition&&Item[varname]){state.tmp.just_did_number=(""+Item[varname]).match(/[0-9]$/);}// UPDATE_GROUP_CONTEXT_CONDITION is run by processNumber
state.processNumber.call(state,node,Item,varname,Item.type);}if(this.substring){var val=Item[varname].slice(this.substring);state.output.append(val,node);}else{CSL.Util.outputNumericField(state,varname,Item.id);}if(["locator","locator-extra"].indexOf(this.variables_real[0])>-1&&!state.tmp.just_looking){state.tmp.done_vars.push(this.variables_real[0]);state.tmp.group_context.tip.done_vars.push(this.variables_real[0]);}};this.execs.push(func);target.push(this);CSL.Util.substituteEnd.call(this,state,target);}};/*global CSL: true */ /*
 * Yikes, these functions were running out of scope for yonks.
 * now that they are set in the correct token list,
 * they might be useful for things.
 * FB 2013.11.09
*/CSL.Node.sort={build:function(state,target){target=state[state.build.root+"_sort"].tokens;if(this.tokentype===CSL.START){if(state.build.area==="citation"){state.opt.sort_citations=true;}state.build.area=state.build.root+"_sort";state.build.extension="_sort";var func=function(state,Item){//state.tmp.area = state.tmp.root + "_sort";
//state.tmp.extension = "_sort";
if(state.opt.has_layout_locale){var langspec=CSL.localeResolve(Item.language,state.opt["default-locale"][0]);var sort_locales=state[state.tmp.area.slice(0,-5)].opt.sort_locales;var langForItem;for(var i=0,ilen=sort_locales.length;i<ilen;i+=1){langForItem=sort_locales[i][langspec.bare];if(!langForItem){langForItem=sort_locales[i][langspec.best];}if(langForItem){break;}}if(!langForItem){langForItem=state.opt["default-locale"][0];}state.tmp.lang_sort_hold=state.opt.lang;state.opt.lang=langForItem;}};this.execs.push(func);}if(this.tokentype===CSL.END){state.build.area=state.build.root;state.build.extension="";var func=function(state){if(state.opt.has_layout_locale){state.opt.lang=state.tmp.lang_sort_hold;delete state.tmp.lang_sort_hold;}//state.tmp.area = state.tmp.root;
//state.tmp.extension = "";
};this.execs.push(func);/*
            var func = function (state, Item) {
                state.tmp.area = state.tmp.root;
                state.tmp.extension = "";
            }
            this.execs.push(func);
            */}target.push(this);}};/*global CSL: true */CSL.Node.substitute={build:function(state,target){var func;if(this.tokentype===CSL.START){/* */ // set conditional
var choose_start=new CSL.Token("choose",CSL.START);CSL.Node.choose.build.call(choose_start,state,target);var if_singleton=new CSL.Token("if",CSL.SINGLETON);func=function(){if(state.tmp.value.length&&!state.tmp.common_term_match_fail){return true;}return false;};if_singleton.tests=[func];if_singleton.test=state.fun.match.any(if_singleton,state,if_singleton.tests);target.push(if_singleton);func=function(state){state.tmp.can_block_substitute=true;if(state.tmp.value.length&&!state.tmp.common_term_match_fail){state.tmp.can_substitute.replace(false,CSL.LITERAL);}state.tmp.common_term_match_fail=false;};this.execs.push(func);target.push(this);/* */}if(this.tokentype===CSL.END){//var if_end = new CSL.Token("if", CSL.END);
//CSL.Node["if"].build.call(if_end, state, target);
/* */target.push(this);var choose_end=new CSL.Token("choose",CSL.END);CSL.Node.choose.build.call(choose_end,state,target);/* */}}};/*global CSL: true */CSL.Node.text={build:function(state,target){var func,form,plural,id,num,number,formatter,firstoutput,specialdelimiter,label,suffix,term;if(this.postponed_macro){var group_start=CSL.Util.cloneToken(this);group_start.name="group";group_start.tokentype=CSL.START;CSL.Node.group.build.call(group_start,state,target);CSL.expandMacro.call(state,this,target);var group_end=CSL.Util.cloneToken(this);group_end.name="group";group_end.tokentype=CSL.END;if(this.postponed_macro==='juris-locator-label'){group_end.isJurisLocatorLabel=true;}CSL.Node.group.build.call(group_end,state,target);}else{CSL.Util.substituteStart.call(this,state,target);// ...
//
// Do non-macro stuff
// Guess again. this.variables is ephemeral, adjusted by an initial
// function set on the node via @variable attribute setup.
//variable = this.variables[0];
if(!this.variables_real){this.variables_real=[];}if(!this.variables){this.variables=[];}form="long";plural=0;if(this.strings.form){form=this.strings.form;}if(this.strings.plural){plural=this.strings.plural;}if("citation-number"===this.variables_real[0]||"year-suffix"===this.variables_real[0]||"citation-label"===this.variables_real[0]){//
// citation-number and year-suffix are super special,
// because they are rangeables, and require a completely
// different set of formatting parameters on the output
// queue.
if(this.variables_real[0]==="citation-number"){if(state.build.root==="citation"){state.opt.update_mode=CSL.NUMERIC;}if(state.build.root==="bibliography"){state.opt.bib_mode=CSL.NUMERIC;}//this.strings.is_rangeable = true;
if("citation-number"===state[state.tmp.area].opt.collapse){this.range_prefix=state.getTerm("citation-range-delimiter");}this.successor_prefix=state[state.build.area].opt.layout_delimiter;this.splice_prefix=state[state.build.area].opt.layout_delimiter;func=function(state,Item,item){id=""+Item.id;if(!state.tmp.just_looking){if(state.tmp.area.slice(-5)==="_sort"&&this.variables[0]==="citation-number"){if(state.tmp.area==="bibliography_sort"){state.tmp.group_context.tip.done_vars.push("citation-number");}if(state.tmp.area==="citation_sort"&&state.bibliography_sort.tmp.citation_number_map){var num=state.bibliography_sort.tmp.citation_number_map[state.registry.registry[Item.id].seq];}else{var num=state.registry.registry[Item.id].seq;}if(num){// Code currently in util_number.js
num=CSL.Util.padding(""+num);}state.output.append(num,this);return;}if(item&&item["author-only"]){state.tmp.element_trace.replace("suppress-me");}if(state.tmp.area!=="bibliography_sort"&&state.bibliography_sort.tmp.citation_number_map&&state.bibliography_sort.opt.citation_number_sort_direction===CSL.DESCENDING){num=state.bibliography_sort.tmp.citation_number_map[state.registry.registry[id].seq];}else{num=state.registry.registry[id].seq;}if(state.opt.citation_number_slug){state.output.append(state.opt.citation_number_slug,this);}else{number=new CSL.NumericBlob(false,num,this,Item.id);if(state.tmp.in_cite_predecessor){number.suppress_splice_prefix=true;}state.output.append(number,"literal");}}};this.execs.push(func);}else if(this.variables_real[0]==="year-suffix"){state.opt.has_year_suffix=true;if(state[state.tmp.area].opt.collapse==="year-suffix-ranged"){//this.range_prefix = "-";
this.range_prefix=state.getTerm("citation-range-delimiter");}this.successor_prefix=state[state.build.area].opt.layout_delimiter;if(state[state.tmp.area].opt["year-suffix-delimiter"]){this.successor_prefix=state[state.build.area].opt["year-suffix-delimiter"];}func=function(state,Item){if(state.registry.registry[Item.id]&&state.registry.registry[Item.id].disambig.year_suffix!==false&&!state.tmp.just_looking){//state.output.append(state.registry.registry[Item.id].disambig[2],this);
num=parseInt(state.registry.registry[Item.id].disambig.year_suffix,10);//if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
//    //this.range_prefix = "-";
//    this.range_prefix = state.getTerm("citation-range-delimiter");
//}
//this.successor_prefix = state[state.tmp.area].opt.layout_delimiter;
if(state[state.tmp.area].opt.cite_group_delimiter){this.successor_prefix=state[state.tmp.area].opt.cite_group_delimiter;}number=new CSL.NumericBlob(false,num,this,Item.id);formatter=new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);number.setFormatter(formatter);state.output.append(number,"literal");firstoutput=false;// XXX Can we do something better for length here?
for(var i=0,ilen=state.tmp.group_context.mystack.length;i<ilen;i++){var flags=state.tmp.group_context.mystack[i];if(!flags.variable_success&&(flags.variable_attempt||!flags.variable_attempt&&!flags.term_intended)){firstoutput=true;break;}}specialdelimiter=state[state.tmp.area].opt["year-suffix-delimiter"];if(firstoutput&&specialdelimiter&&!state.tmp.sort_key_flag){state.tmp.splice_delimiter=state[state.tmp.area].opt["year-suffix-delimiter"];}}};this.execs.push(func);}else if(this.variables_real[0]==="citation-label"){if(state.build.root==="bibliography"){state.opt.bib_mode=CSL.TRIGRAPH;}state.opt.has_year_suffix=true;func=function(state,Item){label=Item["citation-label"];if(!label){label=state.getCitationLabel(Item);}if(!state.tmp.just_looking){suffix="";if(state.registry.registry[Item.id]&&state.registry.registry[Item.id].disambig.year_suffix!==false){num=parseInt(state.registry.registry[Item.id].disambig.year_suffix,10);suffix=state.fun.suffixator.format(num);}label+=suffix;}state.output.append(label,this);};this.execs.push(func);}}else{if(this.strings.term){// printterm
func=function(state,Item){var gender=state.opt.gender[Item.type];var term=this.strings.term;term=state.getTerm(term,form,plural,gender,CSL.TOLERANT,this.default_locale);var myterm;// if the term is not an empty string, say
// that we rendered a term
if(term!==""){state.tmp.group_context.tip.term_intended=true;}CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,term,null,this);// capitalize the first letter of a term, if it is the
// first thing rendered in a citation (or if it is
// being rendered immediately after terminal punctuation,
// I guess, actually).
if(!state.tmp.term_predecessor&&!(state.opt["class"]==="in-text"&&state.tmp.area==="citation")){myterm=CSL.Output.Formatters["capitalize-first"](state,term);//CSL.debug("Capitalize");
}else{myterm=term;}// XXXXX Cut-and-paste code in multiple locations. This code block should be
// collected in a function.
// Tag: strip-periods-block
if(state.tmp.strip_periods){myterm=myterm.replace(/\./g,"");}else{for(var i=0,ilen=this.decorations.length;i<ilen;i+=1){if("@strip-periods"===this.decorations[i][0]&&"true"===this.decorations[i][1]){myterm=myterm.replace(/\./g,"");break;}}}state.output.append(myterm,this);if(state.tmp.can_block_substitute){// Black magic here. This causes the cs:substitution condition to pass,
// blocking further rendering within its scope. 
state.tmp.can_substitute.replace(false,CSL.LITERAL);}};this.execs.push(func);state.build.term=false;state.build.form=false;state.build.plural=false;}else if(this.variables_real.length){func=function(state,Item){// If some text variable is rendered, we're not collapsing.
if(this.variables_real[0]!=="locator"){state.tmp.have_collapsed=false;}if(!state.tmp.group_context.tip.condition&&Item[this.variables[0]]){state.tmp.just_did_number=false;}var val=Item[this.variables[0]];if(val&&!state.tmp.group_context.tip.condition){if((""+val).slice(-1).match(/[0-9]/)){state.tmp.just_did_number=true;}else{state.tmp.just_did_number=false;}}};this.execs.push(func);// plain string fields
// Deal with multi-fields and ordinary fields separately.
if(CSL.MULTI_FIELDS.indexOf(this.variables_real[0])>-1||this.variables_real[0].indexOf("-main")>-1||this.variables_real[0].indexOf("-sub")>-1||["language-name","language-name-original"].indexOf(this.variables_real[0])>-1){// multi-fields
// Initialize transform factory according to whether
// abbreviation is desired.
var abbrevfam=this.variables[0];var abbrfall=false;var altvar=false;var transfall=false;if(form==="short"){if(this.variables_real[0].slice(-6)!=="-short"){altvar=this.variables_real[0]+"-short";}}else{abbrevfam=false;}if(state.build.extension){// multi-fields for sorting get a sort transform,
// (abbreviated if the short form was selected)
transfall=true;}else{transfall=true;abbrfall=true;}func=state.transform.getOutputFunction(this.variables,abbrevfam,abbrfall,altvar,transfall);}else{// ordinary fields
if(CSL.CITE_FIELDS.indexOf(this.variables_real[0])>-1){// per-cite fields are read from item, rather than Item
func=function(state,Item,item){if(item&&item[this.variables[0]]){// Code copied to page variable as well; both
// become cs:number in MLZ extended schema
// If locator, use cs:number. Otherwise, render
// normally.
// XXX The code below is pretty-much copied from
// XXX node_number.js. Should be a common function.
// XXX BEGIN
state.processNumber(this,item,this.variables[0],Item.type);CSL.Util.outputNumericField(state,this.variables[0],Item.id);// XXX END
if(["locator","locator-extra"].indexOf(this.variables_real[0])>-1&&!state.tmp.just_looking){state.tmp.done_vars.push(this.variables_real[0]);}}};}else if(["page","page-first","chapter-number","collection-number","edition","issue","number","number-of-pages","number-of-volumes","volume"].indexOf(this.variables_real[0])>-1){// page gets mangled with the correct collapsing
// algorithm
func=function(state,Item){state.processNumber(this,Item,this.variables[0],Item.type);CSL.Util.outputNumericField(state,this.variables[0],Item.id);};}else if(["URL","DOI"].indexOf(this.variables_real[0])>-1){func=function(state,Item){var value;if(this.variables[0]){value=state.getVariable(Item,this.variables[0],form);if(value){if(this.variables[0]==="URL"&&form==="short"){value=value.replace(/(.*\.[^\/]+)\/.*/,"$1");if(value.match(/\/\/www\./)){value=value.replace(/https?:\/\//,"");}}// true is for non-suppression of periods
if(state.opt.development_extensions.wrap_url_and_doi){if(!this.decorations.length||this.decorations[0][0]!=="@"+this.variables[0]){// Special-casing to fix https://github.com/Juris-M/citeproc-js/issues/57
// clone current token, to avoid collateral damage
var clonetoken=CSL.Util.cloneToken(this);// cast a group blob
var groupblob=new CSL.Blob(null,null,"url-wrapper");// set the DOI decoration on the blob
groupblob.decorations.push(["@DOI","true"]);if(this.variables_real[0]==="DOI"){// strip a proper DOI prefix
var prefix;if(this.strings.prefix&&this.strings.prefix.match(/^.*https:\/\/doi\.org\/$/)){value=value.replace(/^https?:\/\/doi\.org\//,"");if(value.match(/^https?:\/\//)){// Do not tamper with another protocol + domain if already set in field value
prefix="";}else{// Otherwise https + domain
prefix="https://doi.org/";}// set any string prefix on the clone
clonetoken.strings.prefix=this.strings.prefix.slice(0,clonetoken.strings.prefix.length-16);}// cast a text blob
// set the prefix as the content of the blob
var prefixblob=new CSL.Blob(prefix);// cast another text blob
// set the value as the content of the second blob
var valueblob=new CSL.Blob(value);// append new text token and clone to group token
groupblob.push(prefixblob);groupblob.push(valueblob);// append group token to output
state.output.append(groupblob,clonetoken,false,false,true);}else{var valueblob=new CSL.Blob(value);// append new text token and clone to group token
groupblob.push(valueblob);// append group token to output
//this.decorations = [["@" + this.variables[0], "true"]].concat(this.decorations);
state.output.append(groupblob,clonetoken,false,false,true);}}else{state.output.append(value,this,false,false,true);}}else{// This is totally unnecessary, isn't it?
if(this.decorations.length){for(var i=this.decorations.length-1;i>-1;i--){if(this.decorations[i][0]==="@"+this.variables[0]){this.decorations=this.decorations.slice(0,i).concat(this.decorations.slice(i+1));}}}state.output.append(value,this,false,false,true);}}}};}else if(this.variables_real[0]==="section"){// Sections for statutes are special. This is an uncommon
// variable, so we save the cost of the runtime check
// unless it's being used.
func=function(state,Item){var value;value=state.getVariable(Item,this.variables[0],form);if(value){state.output.append(value,this);}};}else if(this.variables_real[0]==="hereinafter"){func=function(state,Item){var value=state.transform.abbrevs["default"]["hereinafter"][Item.id];if(value){state.output.append(value,this);state.tmp.group_context.tip.variable_success=true;}};}else{// anything left over just gets output in the normal way.
func=function(state,Item){var value;if(this.variables[0]){value=state.getVariable(Item,this.variables[0],form);if(value){value=""+value;value=value.split("\\").join("");state.output.append(value,this);}}};}}this.execs.push(func);}else if(this.strings.value){// for the text value attribute.
func=function(state){state.tmp.group_context.tip.term_intended=true;// true flags that this is a literal-value term
CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,this.strings.value,true,this);state.output.append(this.strings.value,this);if(state.tmp.can_block_substitute){// Black magic here. This causes the cs:substitution condition to pass,
// blocking further rendering within its scope. 
state.tmp.can_substitute.replace(false,CSL.LITERAL);}};this.execs.push(func);// otherwise no output
}}target.push(this);CSL.Util.substituteEnd.call(this,state,target);}}};/*global CSL: true */CSL.Node.intext={build:function(state,target){if(this.tokentype===CSL.START){state.build.area="intext";state.build.root="intext";state.build.extension="";var func=function(state,Item){state.tmp.area="intext";state.tmp.root="intext";state.tmp.extension="";};this.execs.push(func);}if(this.tokentype===CSL.END){// Do whatever cs:citation does with sorting.
state.intext_sort={opt:{sort_directions:state.citation_sort.opt.sort_directions}};state.intext.srt=state.citation.srt;}target.push(this);}};/*global CSL: true */CSL.Attributes={};CSL.Attributes["@disambiguate"]=function(state,arg){if(!this.tests){this.tests=[];};if(arg==="true"){state.opt.has_disambiguate=true;var func=function(Item){if(state.tmp.area==="bibliography"){if(state.tmp.disambiguate_count<state.registry.registry[Item.id].disambig.disambiguate){state.tmp.disambiguate_count+=1;return true;}}else{state.tmp.disambiguate_maxMax+=1;if(state.tmp.disambig_settings.disambiguate&&state.tmp.disambiguate_count<state.tmp.disambig_settings.disambiguate){state.tmp.disambiguate_count+=1;return true;}}return false;};this.tests.push(func);}else if(arg==="check-ambiguity-and-backreference"){var func=function(Item){if(state.registry.registry[Item.id].disambig.disambiguate&&state.registry.registry[Item.id]["citation-count"]>1){return true;}return false;};this.tests.push(func);}};CSL.Attributes["@is-numeric"]=function(state,arg){if(!this.tests){this.tests=[];};var variables=arg.split(/\s+/);var maketest=function(variable){return function(Item,item){var myitem=Item;if(item&&["locator","locator-extra"].indexOf(variable)>-1){myitem=item;}if(!myitem[variable]){return false;}if(CSL.NUMERIC_VARIABLES.indexOf(variable)>-1){if(!state.tmp.shadow_numbers[variable]){state.processNumber(false,myitem,variable,Item.type);}if(state.tmp.shadow_numbers[variable].numeric){return true;}}else if(["title","version"].indexOf(variable)>-1){if(myitem[variable].slice(-1)===""+parseInt(myitem[variable].slice(-1),10)){return true;}}return false;};};for(var i=0;i<variables.length;i+=1){this.tests.push(maketest(variables[i]));}};CSL.Attributes["@is-uncertain-date"]=function(state,arg){if(!this.tests){this.tests=[];};var variables=arg.split(/\s+/);// Strip off any boolean prefix.
var maketest=function(myvariable){return function(Item){if(Item[myvariable]&&Item[myvariable].circa){return true;}else{return false;}};};for(var i=0,ilen=variables.length;i<ilen;i+=1){this.tests.push(maketest(variables[i]));}};CSL.Attributes["@locator"]=function(state,arg){if(!this.tests){this.tests=[];};var trylabels=arg.replace("sub verbo","sub-verbo");trylabels=trylabels.split(/\s+/);// Strip off any boolean prefix.
var maketest=function(trylabel){return function(Item,item){var label;state.processNumber(false,item,"locator");label=state.tmp.shadow_numbers.locator.label;if(label&&trylabel===label){return true;}else{return false;}};};for(var i=0,ilen=trylabels.length;i<ilen;i+=1){this.tests.push(maketest(trylabels[i]));}};CSL.Attributes["@position"]=function(state,arg){if(!this.tests){this.tests=[];};var tryposition;state.opt.update_mode=CSL.POSITION;var trypositions=arg.split(/\s+/);var testSubsequentNear=function(Item,item){if(item&&CSL.POSITION_MAP[item.position]>=CSL.POSITION_MAP[CSL.POSITION_SUBSEQUENT]&&item["near-note"]){return true;}return false;};var testSubsequentNotNear=function(Item,item){if(item&&CSL.POSITION_MAP[item.position]==CSL.POSITION_MAP[CSL.POSITION_SUBSEQUENT]&&!item["near-note"]){return true;}return false;};var maketest=function(tryposition){return function(Item,item){if(state.tmp.area==="bibliography"){return false;}if(item&&"undefined"===typeof item.position){item.position=0;}if(item&&typeof item.position==="number"){if(item.position===0&&tryposition===0){return true;}else if(tryposition>0&&CSL.POSITION_MAP[item.position]>=CSL.POSITION_MAP[tryposition]){return true;}}else if(tryposition===0){return true;}return false;};};for(var i=0,ilen=trypositions.length;i<ilen;i+=1){var tryposition=trypositions[i];if(tryposition==="first"){tryposition=CSL.POSITION_FIRST;}else if(tryposition==="container-subsequent"){tryposition=CSL.POSITION_CONTAINER_SUBSEQUENT;}else if(tryposition==="subsequent"){tryposition=CSL.POSITION_SUBSEQUENT;}else if(tryposition==="ibid"){tryposition=CSL.POSITION_IBID;}else if(tryposition==="ibid-with-locator"){tryposition=CSL.POSITION_IBID_WITH_LOCATOR;}if("near-note"===tryposition){this.tests.push(testSubsequentNear);}else if("far-note"===tryposition){this.tests.push(testSubsequentNotNear);}else{this.tests.push(maketest(tryposition));}}};CSL.Attributes["@type"]=function(state,arg){if(!this.tests){this.tests=[];};// XXX This is ALWAYS composed as an "any" match
var types=arg.split(/\s+/);// Strip off any boolean prefix.
var maketest=function(mytype){return function(Item){var ret=Item.type===mytype;if(ret){return true;}else{return false;}};};var tests=[];for(var i=0,ilen=types.length;i<ilen;i+=1){tests.push(maketest(types[i]));}this.tests.push(state.fun.match.any(this,state,tests));};CSL.Attributes["@variable"]=function(state,arg){if(!this.tests){this.tests=[];};var func;this.variables=arg.split(/\s+/);this.variables_real=this.variables.slice();// First the non-conditional code.
if("label"===this.name&&this.variables[0]){this.strings.term=this.variables[0];}else if(["names","date","text","number"].indexOf(this.name)>-1){//
// An oddity of variable handling is that this.variables
// is actually ephemeral; the full list of variables is
// held in the variables_real var, and pushed into this.variables
// conditionally in order to suppress repeat renderings of
// the same item variable.  [STILL FUNCTIONAL? 2010.01.15]
//
// set variable names
func=function(state,Item,item){// Clear this.variables in place
for(var i=this.variables.length-1;i>-1;i+=-1){this.variables.pop();}for(var i=0,ilen=this.variables_real.length;i<ilen;i++){// set variable name if not quashed, and if not the title of a legal case w/suppress-author
if(state.tmp.done_vars.indexOf(this.variables_real[i])===-1// This looks nuts. Why suppress a case name if not required by context?
//                    && !(item && Item.type === "legal_case" && item["suppress-author"] && this.variables_real[i] === "title")
){this.variables.push(this.variables_real[i]);}if(state.tmp.can_block_substitute){state.tmp.done_vars.push(this.variables_real[i]);}}};this.execs.push(func);// check for output
func=function(state,Item,item){var output=false;for(var i=0,ilen=this.variables.length;i<ilen;i++){var variable=this.variables[i];if(["authority","committee"].indexOf(variable)>-1&&"string"===typeof Item[variable]&&"names"===this.name){// Great! So for each of these, we split.
// And we only recombine everything if the length
// of all the splits matches.
// Preflight
var isValid=true;var rawNames=Item[variable].split(/\s*;\s*/);var rawMultiNames={};if(Item.multi&&Item.multi._keys[variable]){for(var langTag in Item.multi._keys[variable]){rawMultiNames[langTag]=Item.multi._keys[variable][langTag].split(/\s*;\s*/);if(rawMultiNames[langTag].length!==rawNames.length){isValid=false;break;}}}if(!isValid){rawNames=[Item[variable]];rawMultiNames=Item.multi._keys[variable];}for(var j=0,jlen=rawNames.length;j<jlen;j++){var creatorParent={literal:rawNames[j],multi:{_key:{}}};for(var langTag in rawMultiNames){var creatorChild={literal:rawMultiNames[langTag][j]};creatorParent.multi._key[langTag]=creatorChild;}rawNames[j]=creatorParent;}Item[variable]=rawNames;}if(this.strings.form==="short"&&!Item[variable]){if(variable==="title"){variable="title-short";}else if(variable==="container-title"){variable="container-title-short";}}if(variable==="year-suffix"){// year-suffix always signals that it produces output,
// even when it doesn't. This permits it to be used with
// the "no date" term inside a group used exclusively
// to control formatting.
output=true;break;}else if(CSL.DATE_VARIABLES.indexOf(variable)>-1){if(state.opt.development_extensions.locator_date_and_revision&&"locator-date"===variable){// If locator-date is set, it's valid.
output=true;break;}if(Item[variable]){for(var key in Item[variable]){if(this.dateparts.indexOf(key)===-1&&"literal"!==key){continue;}if(Item[variable][key]){output=true;break;}}if(output){break;}}}else if("locator"===variable){if(item&&item.locator){output=true;}break;}else if("locator-extra"===variable){if(item&&item["locator-extra"]){output=true;}break;}else if(["citation-number","citation-label"].indexOf(variable)>-1){output=true;break;}else if("first-reference-note-number"===variable){if(item&&item["first-reference-note-number"]){output=true;}break;}else if("first-container-reference-note-number"===variable){if(item&&item["first-container-reference-note-number"]){output=true;}break;}else if("hereinafter"===variable){if(state.transform.abbrevs["default"].hereinafter[Item.id]&&state.sys.getAbbreviation&&Item.id){output=true;}break;}else if("object"===typeof Item[variable]){break;}else if("string"===typeof Item[variable]&&Item[variable]){output=true;break;}else if("number"===typeof Item[variable]){output=true;break;}if(output){break;}}//print("-- VAR: "+variable);
//flag = state.tmp.group_context.tip;
if(output){for(var i=0,ilen=this.variables_real.length;i<ilen;i++){var variable=this.variables_real[i];if(variable!=="citation-number"||state.tmp.area!=="bibliography"){state.tmp.cite_renders_content=true;}//print("  setting [2] to true based on: " + arg);
state.tmp.group_context.tip.variable_success=true;// For util_substitute.js, subsequent-author-substitute
if(state.tmp.can_substitute.value()&&state.tmp.area==="bibliography"&&"string"===typeof Item[variable]){state.tmp.name_node.top=state.output.current.value();state.tmp.rendered_name.push(Item[variable]);}}state.tmp.can_substitute.replace(false,CSL.LITERAL);}else{//print("  setting [1] to true based on: " + arg);
state.tmp.group_context.tip.variable_attempt=true;}//state.tmp.group_context.replace(flag);
};this.execs.push(func);}else if(["if","else-if","condition"].indexOf(this.name)>-1){// Strip off any boolean prefix.
// Now the conditionals.
var maketest=function(variable){return function(Item,item){var myitem=Item;if(item&&["locator","locator-extra","first-reference-note-number","first-container-reference-note-number","locator-date"].indexOf(variable)>-1){myitem=item;}// We don't run loadAbbreviation() here; it is run by the application-supplied
// retrieveItem() if hereinafter functionality is to be used, so this key will
// always exist in memory, possibly with a nil value.
if(variable==="hereinafter"&&state.sys.getAbbreviation&&myitem.id){if(state.transform.abbrevs["default"].hereinafter[myitem.id]){return true;}}else if(myitem[variable]){if("number"===typeof myitem[variable]||"string"===typeof myitem[variable]){return true;}else if("object"===typeof myitem[variable]){//
// this will turn true only for hash objects
// that have at least one attribute, or for a
// non-zero-length list
//
for(var key in myitem[variable]){if(myitem[variable][key]){return true;}}}}return false;};};for(var i=0,ilen=this.variables.length;i<ilen;i+=1){this.tests.push(maketest(this.variables[i]));}}};CSL.Attributes["@page"]=function(state,arg){if(!this.tests){this.tests=[];};var trylabels=arg.replace("sub verbo","sub-verbo");trylabels=trylabels.split(/\s+/);// Strip off any boolean prefix.
var maketest=function(trylabel){return function(Item){var label;state.processNumber(false,Item,"page",Item.type);if(!state.tmp.shadow_numbers.page.label){label="page";}else if(state.tmp.shadow_numbers.page.label==="sub verbo"){label="sub-verbo";}else{label=state.tmp.shadow_numbers.page.label;}if(state.tmp.shadow_numbers.page.values.length>0){if(state.tmp.shadow_numbers.page.values[0].gotosleepability){state.tmp.shadow_numbers.page.values[0].labelVisibility=false;}}if(trylabel===label){return true;}else{return false;}};};for(var i=0,ilen=trylabels.length;i<ilen;i+=1){this.tests.push(maketest(trylabels[i]));}};// a near duplicate of code above
CSL.Attributes["@number"]=function(state,arg){if(!this.tests){this.tests=[];};var trylabels=arg.split(/\s+/);var maketest=function(trylabel){return function(Item){var label;state.processNumber(false,Item,"number",Item.type);if(!state.tmp.shadow_numbers.number.label){label="number";}else{label=state.tmp.shadow_numbers.number.label;}if(trylabel===label){return true;}else{return false;}};};for(var i=0,ilen=trylabels.length;i<ilen;i+=1){this.tests.push(maketest(trylabels[i]));}};CSL.Attributes["@jurisdiction"]=function(state,arg){if(!this.tests){this.tests=[];};var tryjurisdictions=arg.split(/\s+/);// This forces a match=any method, similar to @type
var maketests=function(tryjurisdictions){return function(Item){if(!Item.jurisdiction){return false;}var jurisdiction=Item.jurisdiction;for(var i=0,ilen=tryjurisdictions.length;i<ilen;i++){if(jurisdiction===tryjurisdictions[i]){return true;}}return false;};};this.tests.push(maketests(tryjurisdictions));};CSL.Attributes["@country"]=function(state,arg){if(!this.tests){this.tests=[];};var trycountries=arg.split(/\s+/);// This forces a match=any method, similar to @type
var maketests=function(trycountries){return function(Item){if(!Item.country){return false;}var country=Item.country;for(var i=0,ilen=trycountries.length;i<ilen;i++){if(country===trycountries[i]){return true;}}return false;};};this.tests.push(maketests(trycountries));};CSL.Attributes["@context"]=function(state,arg){if(!this.tests){this.tests=[];};var func=function(){if(["bibliography","citation"].indexOf(arg)>-1){var area=state.tmp.area.slice(0,arg.length);if(area===arg){return true;}return false;}else if("alternative"===arg){return!!state.tmp.abort_alternative;}};this.tests.push(func);};CSL.Attributes["@has-year-only"]=function(state,arg){if(!this.tests){this.tests=[];};var trydates=arg.split(/\s+/);var maketest=function(trydate){return function(Item){var date=Item[trydate];if(!date||date.month||date.season){return false;}else{return true;}};};for(var i=0,ilen=trydates.length;i<ilen;i+=1){this.tests.push(maketest(trydates[i]));}};CSL.Attributes["@has-to-month-or-season"]=function(state,arg){if(!this.tests){this.tests=[];};var trydates=arg.split(/\s+/);var maketest=function(trydate){return function(Item){var date=Item[trydate];if(!date||!date.month&&!date.season||date.day){return false;}else{return true;}};};for(var i=0,ilen=trydates.length;i<ilen;i+=1){this.tests.push(maketest(trydates[i]));}};CSL.Attributes["@has-day"]=function(state,arg){if(!this.tests){this.tests=[];};var trydates=arg.split(/\s+/);var maketest=function(trydate){return function(Item){var date=Item[trydate];if(!date||!date.day){return false;}else{return true;}};};for(var i=0,ilen=trydates.length;i<ilen;i+=1){this.tests.push(maketest(trydates[i]));}};CSL.Attributes["@is-plural"]=function(state,arg){if(!this.tests){this.tests=[];};var func=function(Item){var nameList=Item[arg];if(nameList&&nameList.length){var persons=0;var institutions=0;var last_is_person=false;for(var i=0,ilen=nameList.length;i<ilen;i+=1){if(state.opt.development_extensions.spoof_institutional_affiliations&&(nameList[i].literal||nameList[i].isInstitution&&nameList[i].family&&!nameList[i].given)){institutions+=1;last_is_person=false;}else{persons+=1;last_is_person=true;}}if(persons>1){return true;}else if(institutions>1){return true;}else if(institutions&&last_is_person){return true;}}return false;};this.tests.push(func);};CSL.Attributes["@is-multiple"]=function(state,arg){if(!this.tests){this.tests=[];};var func=function(Item){var val=""+Item[arg];var lst=val.split(/(?:,\s|\s(?:tot\sen\smet|līdz|oraz|and|bis|έως|και|och|až|do|en|et|in|ir|ja|og|sa|to|un|und|és|și|i|u|y|à|e|a|и|-|–)\s|—|\&)/);if(lst.length>1){return true;}return false;};this.tests.push(func);};CSL.Attributes["@locale"]=function(state,arg){if(!this.tests){this.tests=[];};var ret,langspec,lang,lst,i,ilen;// Style default
var locale_default=state.opt["default-locale"][0];if(this.name==="layout"){// For layout
this.locale_raw=arg;if(this.tokentype===CSL.START){if(!state.opt.multi_layout){state.opt.multi_layout=[];}var locale_data=[];// Register the primary locale in the set, and others that "map" to it, 
// so that they can be used when generating sort keys. See node_sort.js.
// Not idempotent. Only do this once.
var locales=arg.split(/\s+/);var sort_locale={};var localeMaster=CSL.localeResolve(locales[0],locale_default);locale_data.push(localeMaster);if(localeMaster.generic){sort_locale[localeMaster.generic]=localeMaster.best;}else{sort_locale[localeMaster.best]=localeMaster.best;}for(var i=1,ilen=locales.length;i<ilen;i+=1){var localeServant=CSL.localeResolve(locales[i],locale_default);locale_data.push(localeServant);if(localeServant.generic){sort_locale[localeServant.generic]=localeMaster.best;}else{sort_locale[localeServant.best]=localeMaster.best;}}state[state.build.area].opt.sort_locales.push(sort_locale);state.opt.multi_layout.push(locale_data);}state.opt.has_layout_locale=true;}else{// For if and if-else
// Split argument
lst=arg.split(/\s+/);// Expand each list element
var locale_bares=[];for(i=0,ilen=lst.length;i<ilen;i+=1){// Parse out language string
lang=lst[i];// Analyze the locale
langspec=CSL.localeResolve(lang,locale_default);if(lst[i].length===2){// For fallback
locale_bares.push(langspec.bare);}// Load the locale terms etc.
// (second argument causes immediate return if locale already exists)
state.localeConfigure(langspec,true);// Replace string with locale spec object
lst[i]=langspec;}// Locales to test
var locale_list=lst.slice();// check for variable value
// Closure probably not necessary here.
var maketest=function(locale_list,locale_default,locale_bares){return function(Item){var res;ret=[];res=false;var langspec=false;var lang;if(!Item.language){lang=locale_default;}else{lang=Item.language;}langspec=CSL.localeResolve(lang,locale_default);for(i=0,ilen=locale_list.length;i<ilen;i+=1){if(langspec.best===locale_list[i].best){state.tmp.condition_lang_counter_arr.push(state.tmp.condition_counter);state.tmp.condition_lang_val_arr.push(state.opt.lang);state.opt.lang=locale_list[0].best;res=true;break;}}if(!res&&locale_bares.indexOf(langspec.bare)>-1){state.tmp.condition_lang_counter_arr.push(state.tmp.condition_counter);state.tmp.condition_lang_val_arr.push(state.opt.lang);state.opt.lang=locale_list[0].best;res=true;}return res;};};this.tests.push(maketest(locale_list,locale_default,locale_bares));}};CSL.Attributes["@alternative-node-internal"]=function(state){if(!this.tests){this.tests=[];};var maketest=function(){return function(){return!state.tmp.abort_alternative;};};var me=this;this.tests.push(maketest(me));};CSL.Attributes["@locale-internal"]=function(state,arg){if(!this.tests){this.tests=[];};var langspec,lang,lst,i,ilen;// For if and if-else
// Split argument
lst=arg.split(/\s+/);// Expand each list element
this.locale_bares=[];for(i=0,ilen=lst.length;i<ilen;i+=1){// Parse out language string
lang=lst[i];// Analyze the locale
langspec=CSL.localeResolve(lang,state.opt["default-locale"][0]);if(lst[i].length===2){// For fallback
this.locale_bares.push(langspec.bare);}// Load the locale terms etc.
state.localeConfigure(langspec);// Replace string with locale spec object
lst[i]=langspec;}// Set locale tag on node
this.locale_default=state.opt["default-locale"][0];// The locale to set on node children if match is successful
this.locale=lst[0].best;// Locales to test
this.locale_list=lst.slice();// check for variable value
// Closure probably not necessary here.
var maketest=function(me){return function(Item){var ret,res;ret=[];res=false;var langspec=false;if(Item.language){lang=Item.language;langspec=CSL.localeResolve(lang,state.opt["default-locale"][0]);if(langspec.best===state.opt["default-locale"][0]){langspec=false;}}if(langspec){// We attempt to match a specific locale from the
// list of parameters.  If that fails, we fall back
// to the base locale of the first element.  The
// locale applied is always the first local 
// in the list of parameters (or base locale, for a 
// single two-character language code) 
for(i=0,ilen=me.locale_list.length;i<ilen;i+=1){if(langspec.best===me.locale_list[i].best){state.opt.lang=me.locale;state.tmp.last_cite_locale=me.locale;// Set empty group open tag with locale set marker
state.output.openLevel("empty");state.output.current.value().new_locale=me.locale;res=true;break;}}if(!res&&me.locale_bares.indexOf(langspec.bare)>-1){state.opt.lang=me.locale;state.tmp.last_cite_locale=me.locale;// Set empty group open tag with locale set marker
state.output.openLevel("empty");state.output.current.value().new_locale=me.locale;res=true;}}return res;};};var me=this;this.tests.push(maketest(me));};CSL.Attributes["@court-class"]=function(state,arg){if(!this.tests){this.tests=[];};var tryclasses=arg.split(/\s+/);var maketest=function(tryclass){return function(Item){var cls=CSL.GET_COURT_CLASS(state,Item);if(cls===tryclass){return true;}else{return false;}};};for(var i=0,ilen=tryclasses.length;i<ilen;i++){this.tests.push(maketest(tryclasses[i]));}};CSL.Attributes["@container-multiple"]=function(state,arg){if(!this.tests){this.tests=[];};var retval="true"===arg?true:false;var maketest=function(retval){return function(Item){if(!state.tmp.container_item_count[Item.container_id]){return!retval;}else if(state.tmp.container_item_count[Item.container_id]>1){return retval;}return!retval;};};this.tests.push(maketest(retval));};CSL.Attributes["@container-subsequent"]=function(state,arg){if(!this.tests){this.tests=[];};var retval="true"===arg?true:false;var maketest=function(retval){return function(Item){if(state.tmp.container_item_pos[Item.container_id]>1){return retval;}return!retval;};};this.tests.push(maketest(retval));};CSL.Attributes["@has-subunit"]=function(state,arg){if(!this.tests){this.tests=[];};var maketest=function(namevar){return function(Item){var subunit_count=0;for(var i in Item[namevar]){var name=Item[namevar][i];if(!name.given){var institution=name.literal?name.literal:name.family;var length=institution.split("|").length;if(subunit_count===0||length<subunit_count){subunit_count=length;}}}return subunit_count>1;};};this.tests.push(maketest(arg));};CSL.Attributes["@cite-form"]=function(state,arg){if(!this.tests){this.tests=[];};var maketest=function(citeForm){return function(Item){if(Item["cite-form"]===citeForm){return true;}return false;};};this.tests.push(maketest(arg));};CSL.Attributes["@disable-duplicate-year-suppression"]=function(state,arg){state.opt.disable_duplicate_year_suppression=arg.split(/\s+/);};CSL.Attributes["@consolidate-containers"]=function(state,arg){CSL.Attributes["@track-containers"](state,arg);var args=arg.split(/\s+/);state.bibliography.opt.consolidate_containers=args;};CSL.Attributes["@track-containers"]=function(state,arg){var args=arg.split(/\s+/);if(!state.bibliography.opt.track_container_items){state.bibliography.opt.track_container_items=[];}if(!state.bibliography.opt.consolidate_containers){state.bibliography.opt.consolidate_containers=[];}state.bibliography.opt.track_container_items=state.bibliography.opt.track_container_items.concat(args);};// These are not evaluated as conditions immediately: they only
// set parameters that are picked up during processing.
CSL.Attributes["@parallel-first"]=function(state,arg){state.opt.parallel.enable=true;var vars=arg.split(/\s+/);if(!state.opt.track_repeat){state.opt.track_repeat={};}this.parallel_first={};for(var i in vars){var v=vars[i];this.parallel_first[v]=true;state.opt.track_repeat[v]=true;}};CSL.Attributes["@parallel-last"]=function(state,arg){state.opt.parallel.enable=true;var vars=arg.split(/\s+/);if(!state.opt.track_repeat){state.opt.track_repeat={};}this.parallel_last={};for(var i in vars){var v=vars[i];this.parallel_last[v]=true;state.opt.track_repeat[v]=true;}};CSL.Attributes["@parallel-last-to-first"]=function(state,arg){state.opt.parallel.enable=true;var vars=arg.split(/\s+/);this.parallel_last_to_first={};for(var i=0,ilen=vars.length;i<ilen;i++){this.parallel_last_to_first[vars[i]]=true;}};CSL.Attributes["@parallel-delimiter-override"]=function(state,arg){state.opt.parallel.enable=true;this.strings.set_parallel_delimiter_override=arg;};CSL.Attributes["@parallel-delimiter-override-on-suppress"]=function(state,arg){state.opt.parallel.enable=true;this.strings.set_parallel_delimiter_override_on_suppress=arg;};CSL.Attributes["@no-repeat"]=function(state,arg){state.opt.parallel.enable=true;var vars=arg.split(/\s+/);if(!state.opt.track_repeat){state.opt.track_repeat={};}this.non_parallel={};for(var i in vars){var v=vars[i];this.non_parallel[v]=true;state.opt.track_repeat[v]=true;}};CSL.Attributes["@require"]=function(state,arg){state.opt.use_context_condition=true;this.strings.require=arg;// Introduced to constrain rendering of the group with a
// requirement that it either render an alpha term via cs:label or
// cs:text at least once, or render without any label. That
// behaviour is invoked with "label-empty-or-alpha" as arg.
// This attribute is a complement to @label-form and modular
// jurisdiction support, as it makes macros that adapt to shifting
// local term definitions possible.
};CSL.Attributes["@reject"]=function(state,arg){state.opt.use_context_condition=true;this.strings.reject=arg;// Introduced to constrain rendering of the group with a
// requirement that it render some label via cs:label or cs:text,
// and that it NOT be alpha. That behaviour is invoked with
// "label-empty-or-alpha" as arg.
// This attribute is a complement to @label-form and modular
// jurisdiction support, as it makes macros that adapt to shifting
// local term definitions possible.
};CSL.Attributes["@require-comma-on-symbol"]=function(state,arg){state.opt.require_comma_on_symbol=arg;};CSL.Attributes["@gender"]=function(state,arg){this.gender=arg;};CSL.Attributes["@cslid"]=function(state,arg){// @cslid is a noop
// The value set on this attribute is used to
// generate reverse lookup wrappers on output when 
// this.development_extensions.csl_reverse_lookup_support is
// set to true in state.js (there is no runtime option,
// it must be set in state.js)
//
// See the @showid method in the html output
// section of formats.js for the function that
// renders the wrappers.
this.cslid=parseInt(arg,10);};CSL.Attributes["@capitalize-if-first"]=function(state,arg){this.strings.capitalize_if_first_override=arg;};CSL.Attributes["@label-capitalize-if-first"]=function(state,arg){this.strings.label_capitalize_if_first_override=arg;};CSL.Attributes["@label-form"]=function(state,arg){this.strings.label_form_override=arg;};CSL.Attributes["@part-separator"]=function(state,arg){this.strings["part-separator"]=arg;};CSL.Attributes["@leading-noise-words"]=function(state,arg){this["leading-noise-words"]=arg;};CSL.Attributes["@name-never-short"]=function(state,arg){this["name-never-short"]=arg;};CSL.Attributes["@class"]=function(state,arg){state.opt["class"]=arg;};CSL.Attributes["@version"]=function(state,arg){state.opt.version=arg;};/**
 * Store the value attribute on the token.
 * @name CSL.Attributes.@value
 * @function
 */CSL.Attributes["@value"]=function(state,arg){this.strings.value=arg;};/**
 * Store the name attribute (of a macro or term node)
 * on the state object.
 * <p>For reference when the closing node of a macro
 * or locale definition is encountered.</p>
 * @name CSL.Attributes.@name
 * @function
 */CSL.Attributes["@name"]=function(state,arg){this.strings.name=arg;};/**
 * Store the form attribute (of a term node) on the state object.
 * <p>For reference when the closing node of a macro
 * or locale definition is encountered.</p>
 * @name CSL.Attributes.@form
 * @function
 */CSL.Attributes["@form"]=function(state,arg){this.strings.form=arg;};CSL.Attributes["@date-parts"]=function(state,arg){this.strings["date-parts"]=arg;};CSL.Attributes["@range-delimiter"]=function(state,arg){this.strings["range-delimiter"]=arg;};/**
 * Store macro tokens in a buffer on the state object.
 * <p>For reference when the enclosing text token is
 * processed.</p>
 * @name CSL.Attributes.@macro
 * @function
 */CSL.Attributes["@macro"]=function(state,arg){this.postponed_macro=arg;};/*
 * CSL.Attributes["@prefer-jurisdiction"] = function (state, arg) {
 *    this.prefer_jurisdiction = true;
 * };
 */CSL.Attributes["@term"]=function(state,arg){if(arg==="sub verbo"){this.strings.term="sub-verbo";}else{this.strings.term=arg;}};/*
 * Ignore xmlns attribute.
 * <p>This should always be <p>http://purl.org/net/xbiblio/csl</code>
 * anyway.  At least for the present we will blindly assume
 * that it is.</p>
 * @name CSL.Attributes.@xmlns
 * @function
 */CSL.Attributes["@xmlns"]=function(){};/*
 * Store language attribute to a buffer field.
 * <p>Will be placed in the appropriate location
 * when the element is processed.</p>
 * @name CSL.Attributes.@lang
 * @function
 */CSL.Attributes["@lang"]=function(state,arg){if(arg){state.build.lang=arg;}};// Used as a flag during dates processing
CSL.Attributes["@lingo"]=function(){};// Used as a flag during dates processing
CSL.Attributes["@macro-has-date"]=function(){this["macro-has-date"]=true;};/*
 * Store suffix string on token.
 * @name CSL.Attributes.@suffix
 * @function
 */CSL.Attributes["@suffix"]=function(state,arg){this.strings.suffix=arg;};/*
 * Store prefix string on token.
 * @name CSL.Attributes.@prefix
 * @function
 */CSL.Attributes["@prefix"]=function(state,arg){this.strings.prefix=arg;};/*
 * Store delimiter string on token.
 * @name CSL.Attributes.@delimiter
 * @function
 */CSL.Attributes["@delimiter"]=function(state,arg){this.strings.delimiter=arg;};/*
 * Store match evaluator on token.
 */CSL.Attributes["@match"]=function(state,arg){this.match=arg;};CSL.Attributes["@names-min"]=function(state,arg){var val=parseInt(arg,10);if(state[state.build.area].opt.max_number_of_names<val){state[state.build.area].opt.max_number_of_names=val;}this.strings["et-al-min"]=val;};CSL.Attributes["@names-use-first"]=function(state,arg){this.strings["et-al-use-first"]=parseInt(arg,10);};CSL.Attributes["@names-use-last"]=function(state,arg){if(arg==="true"){this.strings["et-al-use-last"]=true;}else{this.strings["et-al-use-last"]=false;}};CSL.Attributes["@sort"]=function(state,arg){if(arg==="descending"){this.strings.sort_direction=CSL.DESCENDING;}};CSL.Attributes["@plural"]=function(state,arg){// Accepted values of plural attribute differ on cs:text
// and cs:label nodes.
if("always"===arg||"true"===arg){this.strings.plural=1;}else if("never"===arg||"false"===arg){this.strings.plural=0;}else if("contextual"===arg){this.strings.plural=false;}};CSL.Attributes["@has-publisher-and-publisher-place"]=function(){this.strings["has-publisher-and-publisher-place"]=true;};CSL.Attributes["@publisher-delimiter-precedes-last"]=function(state,arg){this.strings["publisher-delimiter-precedes-last"]=arg;};CSL.Attributes["@publisher-delimiter"]=function(state,arg){this.strings["publisher-delimiter"]=arg;};CSL.Attributes["@publisher-and"]=function(state,arg){this.strings["publisher-and"]=arg;};CSL.Attributes["@givenname-disambiguation-rule"]=function(state,arg){if(CSL.GIVENNAME_DISAMBIGUATION_RULES.indexOf(arg)>-1){state.citation.opt["givenname-disambiguation-rule"]=arg;}};CSL.Attributes["@collapse"]=function(state,arg){// only one collapse value will be honoured.
if(arg){state[this.name].opt.collapse=arg;}};CSL.Attributes["@cite-group-delimiter"]=function(state,arg){if(arg){state[state.tmp.area].opt.cite_group_delimiter=arg;}};CSL.Attributes["@names-delimiter"]=function(state,arg){state.setOpt(this,"names-delimiter",arg);};CSL.Attributes["@name-form"]=function(state,arg){state.setOpt(this,"name-form",arg);};CSL.Attributes["@subgroup-delimiter"]=function(state,arg){this.strings["subgroup-delimiter"]=arg;};CSL.Attributes["@subgroup-delimiter-precedes-last"]=function(state,arg){this.strings["subgroup-delimiter-precedes-last"]=arg;};CSL.Attributes["@name-delimiter"]=function(state,arg){state.setOpt(this,"name-delimiter",arg);};CSL.Attributes["@et-al-min"]=function(state,arg){var val=parseInt(arg,10);if(state[state.build.area].opt.max_number_of_names<val){state[state.build.area].opt.max_number_of_names=val;}state.setOpt(this,"et-al-min",val);};CSL.Attributes["@et-al-use-first"]=function(state,arg){state.setOpt(this,"et-al-use-first",parseInt(arg,10));};CSL.Attributes["@et-al-use-last"]=function(state,arg){if(arg==="true"){state.setOpt(this,"et-al-use-last",true);}else{state.setOpt(this,"et-al-use-last",false);}};CSL.Attributes["@et-al-subsequent-min"]=function(state,arg){var val=parseInt(arg,10);if(state[state.build.area].opt.max_number_of_names<val){state[state.build.area].opt.max_number_of_names=val;}state.setOpt(this,"et-al-subsequent-min",val);};CSL.Attributes["@et-al-subsequent-use-first"]=function(state,arg){state.setOpt(this,"et-al-subsequent-use-first",parseInt(arg,10));};CSL.Attributes["@suppress-min"]=function(state,arg){this.strings["suppress-min"]=parseInt(arg,10);};CSL.Attributes["@suppress-max"]=function(state,arg){this.strings["suppress-max"]=parseInt(arg,10);};CSL.Attributes["@and"]=function(state,arg){state.setOpt(this,"and",arg);};CSL.Attributes["@delimiter-precedes-last"]=function(state,arg){state.setOpt(this,"delimiter-precedes-last",arg);};CSL.Attributes["@delimiter-precedes-et-al"]=function(state,arg){state.setOpt(this,"delimiter-precedes-et-al",arg);};CSL.Attributes["@initialize-with"]=function(state,arg){state.setOpt(this,"initialize-with",arg);};CSL.Attributes["@initialize"]=function(state,arg){if(arg==="false"){state.setOpt(this,"initialize",false);}};CSL.Attributes["@name-as-reverse-order"]=function(state,arg){this["name-as-reverse-order"]=arg;};CSL.Attributes["@name-as-sort-order"]=function(state,arg){if(this.name==="style-options"){this["name-as-sort-order"]=arg;}else{state.setOpt(this,"name-as-sort-order",arg);}};CSL.Attributes["@sort-separator"]=function(state,arg){state.setOpt(this,"sort-separator",arg);};CSL.Attributes["@require-match"]=function(state,arg){if(arg==="true"){this.requireMatch=true;}};CSL.Attributes["@exclude-types"]=function(state,arg){state.bibliography.opt.exclude_types=arg.split(/\s+/);};CSL.Attributes["@exclude-with-fields"]=function(state,arg){state.bibliography.opt.exclude_with_fields=arg.split(/\s+/);};CSL.Attributes["@year-suffix-delimiter"]=function(state,arg){state[this.name].opt["year-suffix-delimiter"]=arg;};CSL.Attributes["@after-collapse-delimiter"]=function(state,arg){state[this.name].opt["after-collapse-delimiter"]=arg;};CSL.Attributes["@subsequent-author-substitute"]=function(state,arg){state[this.name].opt["subsequent-author-substitute"]=arg;};CSL.Attributes["@subsequent-author-substitute-rule"]=function(state,arg){state[this.name].opt["subsequent-author-substitute-rule"]=arg;};CSL.Attributes["@disambiguate-add-names"]=function(state,arg){if(arg==="true"){state.opt["disambiguate-add-names"]=true;}};CSL.Attributes["@disambiguate-add-givenname"]=function(state,arg){if(arg==="true"){state.opt["disambiguate-add-givenname"]=true;}};CSL.Attributes["@disambiguate-add-year-suffix"]=function(state,arg){if(arg==="true"&&state.opt.xclass!=="numeric"){state.opt["disambiguate-add-year-suffix"]=true;}};CSL.Attributes["@second-field-align"]=function(state,arg){if(arg==="flush"||arg==="margin"){state[this.name].opt["second-field-align"]=arg;}};CSL.Attributes["@hanging-indent"]=function(state,arg){if(arg==="true"){if(state.opt.development_extensions.hanging_indent_legacy_number){state[this.name].opt.hangingindent=2;}else{state[this.name].opt.hangingindent=true;}}};CSL.Attributes["@line-spacing"]=function(state,arg){if(arg&&arg.match(/^[.0-9]+$/)){state[this.name].opt["line-spacing"]=parseFloat(arg,10);}};CSL.Attributes["@entry-spacing"]=function(state,arg){if(arg&&arg.match(/^[.0-9]+$/)){state[this.name].opt["entry-spacing"]=parseFloat(arg,10);}};CSL.Attributes["@near-note-distance"]=function(state,arg){state[this.name].opt["near-note-distance"]=parseInt(arg,10);};CSL.Attributes["@substring"]=function(state,arg){this.substring=parseInt(arg,10);};CSL.Attributes["@text-case"]=function(state,arg){var func=function(state,Item){if(arg==="normal"){this.text_case_normal=true;}else{this.strings["text-case"]=arg;if(arg==="title"){if(Item.jurisdiction){this.strings["text-case"]="passthrough";}}}};this.execs.push(func);};CSL.Attributes["@page-range-format"]=function(state,arg){state.opt["page-range-format"]=arg;};CSL.Attributes["@year-range-format"]=function(state,arg){state.opt["year-range-format"]=arg;};CSL.Attributes["@default-locale"]=function(state,arg){if(this.name==='style'){var lst,len,pos,m,ret;//
// Workaround for Internet Exploder 6 (doesn't recognize
// groups in str.split(/something(braced-group)something/)
//
var m=arg.match(/-x-(sort|translit|translat)-/g);if(m){for(pos=0,len=m.length;pos<len;pos+=1){m[pos]=m[pos].replace(/^-x-/,"").replace(/-$/,"");}}lst=arg.split(/-x-(?:sort|translit|translat)-/);ret=[lst[0]];for(pos=1,len=lst.length;pos<len;pos+=1){ret.push(m[pos-1]);ret.push(lst[pos]);}lst=ret.slice();len=lst.length;for(pos=1;pos<len;pos+=2){state.opt["locale-"+lst[pos]].push(lst[pos+1].replace(/^\s*/g,"").replace(/\s*$/g,""));}if(lst.length){state.opt["default-locale"]=lst.slice(0,1);}else{state.opt["default-locale"]=["en"];}}else if(arg==="true"){this.default_locale=true;}};CSL.Attributes["@default-locale-sort"]=function(state,arg){state.opt["default-locale-sort"]=arg;};CSL.Attributes["@demote-non-dropping-particle"]=function(state,arg){state.opt["demote-non-dropping-particle"]=arg;};CSL.Attributes["@initialize-with-hyphen"]=function(state,arg){if(arg==="false"){state.opt["initialize-with-hyphen"]=false;}};CSL.Attributes["@institution-parts"]=function(state,arg){this.strings["institution-parts"]=arg;};CSL.Attributes["@if-short"]=function(state,arg){if(arg==="true"){this.strings["if-short"]=true;}};CSL.Attributes["@substitute-use-first"]=function(state,arg){this.strings["substitute-use-first"]=parseInt(arg,10);};CSL.Attributes["@use-first"]=function(state,arg){this.strings["use-first"]=parseInt(arg,10);};CSL.Attributes["@use-last"]=function(state,arg){this.strings["use-last"]=parseInt(arg,10);};CSL.Attributes["@stop-first"]=function(state,arg){this.strings["stop-first"]=parseInt(arg,10);};CSL.Attributes["@stop-last"]=function(state,arg){this.strings["stop-last"]=parseInt(arg,10)*-1;};CSL.Attributes["@reverse-order"]=function(state,arg){if("true"===arg){this.strings["reverse-order"]=true;}};CSL.Attributes["@display"]=function(state,arg){if(state.bibliography.tokens.length===2){state.opt.using_display=true;}this.strings.cls=arg;};/*global CSL: true */ /**
 * String stack object.
 * <p>Numerous string stacks are used to track nested
 * parameters at runtime.  This class provides methods
 * that remove some of the aggravation of managing
 * them.</p>
 * @class
 */CSL.Stack=function(val,literal){this.mystack=[];if(literal||val){this.mystack.push(val);}this.tip=this.mystack[0];};/**
 * Push a value onto the stack.
 * <p>This just does what it says.</p>
 */CSL.Stack.prototype.push=function(val,literal){if(literal||val){this.mystack.push(val);}else{this.mystack.push("");}this.tip=this.mystack[this.mystack.length-1];};/**
 * Clear the stack
 */CSL.Stack.prototype.clear=function(){this.mystack=[];this.tip={};};/**
 * Replace the top value on the stack.
 * <p>This removes some ugly syntax from the
 * main code.</p>
 */CSL.Stack.prototype.replace=function(val,literal){//
// safety fix after a bug was chased down.  Rhino
// JS will process a negative index without error (!).
if(this.mystack.length===0){CSL.error("Internal CSL processor error: attempt to replace nonexistent stack item with "+val);}if(literal||val){this.mystack[this.mystack.length-1]=val;}else{this.mystack[this.mystack.length-1]="";}this.tip=this.mystack[this.mystack.length-1];};/**
 * Remove the top value from the stack.
 * <p>Just does what it says.</p>
 */CSL.Stack.prototype.pop=function(){var ret=this.mystack.pop();if(this.mystack.length){this.tip=this.mystack[this.mystack.length-1];}else{this.tip={};}return ret;};/**
 * Return the top value on the stack.
 * <p>Removes a little hideous complication from
 * the main code.</p>
 */CSL.Stack.prototype.value=function(){return this.mystack.slice(-1)[0];};/**
 * Return length (depth) of stack.
 * <p>Used to identify if there is content to
 * be handled on the stack</p>
 */CSL.Stack.prototype.length=function(){return this.mystack.length;};/*global CSL: true */ /**
 * Initializes the parallel cite tracking arrays
 */CSL.Parallel=function(state){this.state=state;};CSL.Parallel.prototype.StartCitation=function(sortedItems,out){// This array carries the repeat markers used in rendering the cite.
this.state.tmp.suppress_repeats=[];if(sortedItems.length<2)return;var idxEnd=0;var parallelMatchList=false;var siblingRanges=[];for(var i=0,ilen=sortedItems.length-1;i<ilen;i++){var currItem=sortedItems[i][0];var nextItem=sortedItems[i+1][0];var freshMatchList=false;var info={};if(sortedItems[i][0].seeAlso&&sortedItems[i][0].seeAlso.length>0&&!parallelMatchList){freshMatchList=true;parallelMatchList=[sortedItems[i][0].id].concat(sortedItems[i][0].seeAlso);var tempMatchList=parallelMatchList.slice();var remainder=sortedItems.slice(i);remainder[0][1].parallel="first";for(var j=0,jlen=remainder.length;j<jlen;j++){var itemID=remainder[j][0].id;var ididx=tempMatchList.indexOf(itemID);idxEnd=false;if(ididx===-1){idxEnd=i+j-1;}else if(i+j===sortedItems.length-1){idxEnd=i+j;}if(idxEnd){siblingRanges.push([i,idxEnd]);break;}else{tempMatchList=tempMatchList.slice(0,ididx).concat(tempMatchList.slice(ididx+1));}}}// parallelMatchList/freshMatchList relate only to parallels.
// no-repeat non-parallels are handled in a separate block.
if(i>0&&freshMatchList){this.state.tmp.suppress_repeats[i-1].START=true;freshMatchList=false;}for(var varname in this.state.opt.track_repeat){if(!currItem[varname]||!nextItem[varname]){// Go ahead and render any value with an empty partner
info[varname]=false;}else if("string"===typeof nextItem[varname]||"number"===typeof nextItem[varname]){// Simple comparison of string values
if(varname==="title"&&currItem["title-short"]&&nextItem["title-short"]){var currVal=currItem["title-short"];var nextVal=nextItem["title-short"];}else{var currVal=currItem[varname];var nextVal=nextItem[varname];}if(currVal==nextVal){info[varname]=true;}else{info[varname]=false;}}else if("undefined"===typeof currItem[varname].length){// If a date, use only the year
info[varname]=false;var currYear=currItem[varname].year;var nextYear=nextItem[varname].year;if(currYear&&nextYear){if(currYear==nextYear){info[varname]=true;}}}else{// If a creator value, kludge it
var currVal=JSON.stringify(currItem[varname]);var nextVal=JSON.stringify(nextItem[varname]);if(currVal===nextVal){info[varname]=true;}else{info[varname]=false;}}}if(!parallelMatchList){info.ORPHAN=true;}if(idxEnd===i){info.END=true;parallelMatchList=false;}this.state.tmp.suppress_repeats.push(info);}// if (!this.state.tmp.just_looking) {
//     this.state.sys.print(`${JSON.stringify(this.state.tmp.suppress_repeats, null, 2)}`);
// }
// Set no-repeat info here?
for(var j=0,jlen=siblingRanges.length;j<jlen;j++){var masterID=sortedItems[siblingRanges[j][0]][0].id;this.state.registry.registry[masterID].master=true;this.state.registry.registry[masterID].siblings=[];var start=siblingRanges[j][0];var end=siblingRanges[j][1];for(var k=start;k<end;k++){this.state.tmp.suppress_repeats[k].SIBLING=true;var siblingID=sortedItems[k+1][0].id;sortedItems[k+1][1].parallel="other";this.state.registry.registry[masterID].siblings.push(siblingID);}}// this.state.sys.print(JSON.stringify(this.state.tmp.suppress_repeats, null, 2));
};CSL.Parallel.prototype.checkRepeats=function(params){var idx=this.state.tmp.cite_index;if(this.state.tmp.suppress_repeats){if(params.parallel_first&&Object.keys(params.parallel_first).length>0){var arr=[{}].concat(this.state.tmp.suppress_repeats);var ret=true;for(var varname in params.parallel_first){if(!arr[idx][varname]||arr[idx].START){// true --> suppress the entry
// Test here evaluates as "all", not "any"
ret=false;}}return ret;}if(params.parallel_last&&Object.keys(params.parallel_last).length>0){var arr=this.state.tmp.suppress_repeats.concat([{}]);var ret=Object.keys(params.parallel_last).length>0?true:false;for(var varname in params.parallel_last){if(!arr[idx][varname]||arr[idx].END){// "all" match, as above.
ret=false;}}return ret;}if(params.non_parallel&&Object.keys(params.non_parallel).length>0){var arr=[{}].concat(this.state.tmp.suppress_repeats);var ret=true;for(var varname in params.non_parallel){if(!arr[idx][varname]){ret=false;}}return ret;}}return false;};/*global CSL: true */CSL.Util={};CSL.Util.Match=function(){this.any=function(token,state,tests){return function(Item,item){for(var i=0,ilen=tests.length;i<ilen;i+=1){var result=tests[i](Item,item);if(result){return true;}}return false;};};this.none=function(token,state,tests){return function(Item,item){for(var i=0,ilen=tests.length;i<ilen;i+=1){var result=tests[i](Item,item);if(result){return false;}}return true;};};this.all=function(token,state,tests){return function(Item,item){for(var i=0,ilen=tests.length;i<ilen;i+=1){var result=tests[i](Item,item);if(!result){return false;}}return true;};};this[undefined]=this.all;this.nand=function(token,state,tests){return function(Item,item){for(var i=0,ilen=tests.length;i<ilen;i+=1){var result=tests[i](Item,item);if(!result){return true;}}return false;};};};/*global CSL: true */ /*
 * Fields can be transformed by translation/transliteration, or by
 * abbreviation.  Transformations are performed in that order.
 *
 * Renderings of original, translated or transliterated content
 * (followed by abbreviation if requested) are placed in the primary
 * output slot or the (implicitly punctuated) secondary and tertiary
 * output slots according to the settings registered in the
 * state.opt['cite-lang-prefs'] arrays. The array has six segments:
 * 'persons', 'institutions', 'titles', 'journals', 'publishers', and
 * 'places'. Each segment always contains at least one item, and may
 * hold values 'orig', 'translit' or 'translat'. The array defaults to
 * a single item 'orig'.
 *
 * All multilingual variables are associated with segments,
 * with the exception of 'edition' and 'genre'. These two
 * exceptions are always rendered with the first matching
 * language form found in state.opt['locale-translit'] or, if
 * composing a sort key, state.opt['locale-sort']. No secondary
 * slot rendering is performed for this two variables.
 *
 * The balance of multilingual variables are rendered with
 * the first matching value in the transform locales spec
 * (no transform, state.opt['locale-translit'], or 
 * state.opt['locale-translat']) mapped to the target
 * slot.
 *
 * Full primary+secondary+tertiary rendering is performed only in
 * note-style citations and the bibliography.  In-text citations are
 * rendered in the primary output slot only, following the same spec
 * parameters.
 *
 *   Optional setters:
 *     .setAbbreviationFallback(); fallback flag
 *       (if true, a failed abbreviation will fallback to long)
 *
 *     .setAlternativeVariableName(): alternative variable name in Item,
 *       for use as a fallback abbreviation source
 *
 * Translation/transliteration
 *
 *   Optional setter:
 *     .setTransformFallback():
 *       default flag (if true, the original field value will be used as a fallback)
 *
 * The getTextSubField() method may be used to obtain a string transform
 * of a field, without abbreviation, as needed for setting sort keys
 * (for example).
 *
 */CSL.Transform=function(state){// Abbreviation families
this.abbrevs={};this.abbrevs["default"]=new state.sys.AbbreviationSegments();function getCountryOrJurisdiction(variable,normalizedKey,quashCountry){var value="";if(state.sys.getHumanForm){if(variable==="country"){value=state.sys.getHumanForm(normalizedKey.toLowerCase(),false,true);value=value.split("|")[0];}else if(variable==="jurisdiction"){value=state.sys.getHumanForm(normalizedKey.toLowerCase(),false,true);if(!quashCountry){value=value.split("|").slice(1).join(", ");}else{// Bare country name is rendered by "country", not "jurisdiction"
value="";}}}return value;}// Internal function
function abbreviate(state,tok,Item,altvar,basevalue,family_var,use_field){var value="";var myabbrev_family=CSL.FIELD_CATEGORY_REMAP[family_var];var preferredJurisdiction;if(!myabbrev_family){return basevalue;}var variable=family_var;var normalizedKey=basevalue;if(state.sys.normalizeAbbrevsKey){normalizedKey=state.sys.normalizeAbbrevsKey(family_var,basevalue);}var quashCountry=false;if(variable==="jurisdiction"&&normalizedKey){quashCountry=normalizedKey.indexOf(":")===-1;}// Fix up jurisdiction codes
if(["jurisdiction","country"].indexOf(family_var)>-1&&basevalue===basevalue.toLowerCase()){normalizedKey=basevalue.toUpperCase();}// Lazy retrieval of abbreviations.
if(state.sys.getAbbreviation){if(["jurisdiction","country","language-name","language-name-original"].indexOf(variable)>-1){preferredJurisdiction="default";}else if(Item.jurisdiction){preferredJurisdiction=Item.jurisdiction;}else{preferredJurisdiction="default";}var jurisdiction=state.transform.loadAbbreviation(preferredJurisdiction,myabbrev_family,normalizedKey,Item.language);// Some rules:
// # variable === "country"
// (1) If an abbreviation is associated with the code, then:
//     (a) return the abbreviated form if form="short"
// (2) Otherwise:
//     (a) return the human-readable country name, or whatever is there if it's not a code
// # variable === "jurisdiction"
// (1) If !!getHumanForm(jurisdictionID, false, false):
//     (a) If the code is top-level (i.e. a country):
//         (i) return nothing -- this is what the "country" variable is for.
//     (b) otherwise:
//         (i) If an abbreviation is associated with the code, then:
//             (A) return the abbreviated form
//         (ii) Otherwise
//             (A) return the human-readable form, with the country name & code removed from the front
// (2) Otherwise:
//     (a) abbreviate as per normal.
// # other variables
// (1) Abbreviate as per normal.
if(state.transform.abbrevs[jurisdiction][myabbrev_family]&&normalizedKey){// Safe to test presence of abbrev against raw object in this block
var abbrev=state.transform.abbrevs[jurisdiction][myabbrev_family][normalizedKey];if(tok.strings.form==="short"&&abbrev){if(quashCountry){value="";}else{value=abbrev;}}else{value=getCountryOrJurisdiction(variable,normalizedKey,quashCountry);}}}// Was for: 
if(!value&&(!state.opt.development_extensions.require_explicit_legal_case_title_short||Item.type!=='legal_case')&&altvar&&Item[altvar]&&use_field){value=Item[altvar];}if(!value&&!state.sys.getAbbreviation&&state.sys.getHumanForm){value=getCountryOrJurisdiction(variable,normalizedKey,quashCountry);}if(!value&&!quashCountry&&(!state.sys.getHumanForm||variable!=="jurisdiction")){value=basevalue;}if(state.opt.development_extensions.force_title_abbrev_fallback){if(variable==="title"&&value===basevalue&&Item["title-short"]){value=Item["title-short"];}}return value;}function getFieldLocale(Item,field){var ret=state.opt["default-locale"][0].slice(0,2);var localeRex;if(state.opt.development_extensions.strict_text_case_locales){localeRex=new RegExp("^([a-zA-Z]{2})(?:$|-.*| .*)");}else{localeRex=new RegExp("^([a-zA-Z]{2})(?:$|-.*|.*)");}if(Item.language){var m=(""+Item.language).match(localeRex);if(m){ret=m[1];}else{// Set garbage to "Klingon".
ret="tlh";}}if(Item.multi&&Item.multi&&Item.multi.main&&Item.multi.main[field]){ret=Item.multi.main[field];}if(!state.opt.development_extensions.strict_text_case_locales||state.opt.development_extensions.normalize_lang_keys_to_lowercase){ret=ret.toLowerCase();}return ret;}// Internal functions
function getTextSubField(Item,field,locale_type,use_default,stopOrig,family_var){var opt,o,ret,opts;var usedOrig=stopOrig;var usingOrig=false;if(!Item[field]){return{name:"",usedOrig:stopOrig,token:CSL.Util.cloneToken(this)};}// If form="short" is selected ("family_var" is a misnomer
// here, it means short-form requested), and the variable
// has a short-form partner (i.e. it is in array
// VARIABLES_WITH_SHORT_FORM), then it is run here as *-short".
var stickyLongForm=false;if(CSL.VARIABLES_WITH_SHORT_FORM.indexOf(field)>-1&&family_var){field=field+"-short";stickyLongForm=true;}var breakMe=false;var firstValue=null;var fieldsToTry=[];if(field.slice(-6)==="-short"){fieldsToTry.push(field);fieldsToTry.push(field.slice(0,-6));}else{fieldsToTry.push(field);}for(var h=0,hlen=fieldsToTry.length;h<hlen;h++){var variantMatch=false;var field=fieldsToTry[h];ret={name:"",usedOrig:stopOrig,locale:getFieldLocale(Item,field)};opts=state.opt[locale_type]?state.opt[locale_type].slice():[];var hasVal=false;if(locale_type==='locale-orig'){if(!stopOrig){ret.name=Item[field];ret.usedOrig=false;}hasVal=true;usingOrig=true;}else if(use_default&&("undefined"===typeof opts||opts.length===0)){// If we want the original, or if we don't have any specific guidance and we 
// definitely want output, just return the original value.
ret.name=Item[field];ret.usedOrig=true;hasVal=true;usingOrig=true;}if(!hasVal){for(var i=0,ilen=opts.length;i<ilen;i+=1){opt=opts[i];o=opt.split(/[\-_]/)[0];if(opt&&Item.multi&&Item.multi._keys[field]&&Item.multi._keys[field][opt]){ret.name=Item.multi._keys[field][opt];ret.locale=opt;hasVal=true;variantMatch=true;usingOrig=false;break;}else if(o&&Item.multi&&Item.multi._keys[field]&&Item.multi._keys[field][o]){ret.name=Item.multi._keys[field][o];ret.locale=o;hasVal=true;variantMatch=true;usingOrig=false;break;}}if(!ret.name&&use_default){ret={name:Item[field],usedOrig:true,locale:getFieldLocale(Item,field)};usingOrig=true;}}ret.token=CSL.Util.cloneToken(this);if(h===0){if(variantMatch){ret.found_variant_ok=true;}firstValue=ret;if(!stickyLongForm&&("undefined"===typeof opts||opts.length===0)){breakMe=true;}if(variantMatch){breakMe=true;}}else{if(!stickyLongForm&&!variantMatch&&firstValue){ret=firstValue;field=fieldsToTry[0];}else if(variantMatch){ret.found_variant_ok=true;}}if(["title","container-title"].indexOf(field)>-1){if(!usedOrig&&(!ret.token.strings["text-case"]||ret.token.strings["text-case"]==="sentence"||ret.token.strings["text-case"]==="normal")){var locale=state.opt.lang;var lang;if(usingOrig){lang=false;}else{lang=ret.locale;}var seg=field.slice(0,-5);var sentenceCase=ret.token.strings["text-case"]==="sentence"?true:false;ret.name=CSL.titlecaseSentenceOrNormal(state,Item,seg,lang,sentenceCase);delete ret.token.strings["text-case"];}}if(breakMe){break;}}return ret;}this.getTextSubField=getTextSubField;// Setter for abbreviation lists
// This initializes a single abbreviation based on known
// data.
function loadAbbreviation(jurisdiction,category,orig,lang){if(!jurisdiction){jurisdiction="default";}var country=jurisdiction.split(":")[0];var domain=CSL.getAbbrevsDomain(state,country,lang);if(domain){jurisdiction+="@"+domain;}if(!orig){if(!state.transform.abbrevs[jurisdiction]){state.transform.abbrevs[jurisdiction]=new state.sys.AbbreviationSegments();}if(!state.transform.abbrevs[jurisdiction][category]){state.transform.abbrevs[jurisdiction][category]={};}return jurisdiction;}// The getAbbreviation() function should check the
// external DB for the content key. If a value exists
// in this[category] and no value exists in DB, the entry
// in memory is left untouched. If a value does exist in
// DB, the memory value is created.
//
// See testrunner_stdrhino.js for an example.
if(state.sys.getAbbreviation){jurisdiction=state.sys.getAbbreviation(state.opt.styleID,state.transform.abbrevs,jurisdiction,category,orig);if(!jurisdiction){jurisdiction="default";if(domain){jurisdiction+="@"+domain;}}}return jurisdiction;}this.loadAbbreviation=loadAbbreviation;function publisherCheck(tok,Item,primary,family_var){var varname=tok.variables[0];if(state.publisherOutput&&primary){if(["publisher","publisher-place"].indexOf(varname)===-1){return false;}else{// In this case, the publisher bundle will be rendered
// at the close of the group, by the closing group node.
state.publisherOutput[varname+"-token"]=tok;state.publisherOutput.varlist.push(varname);var lst=primary.split(/;\s*/);if(lst.length===state.publisherOutput[varname+"-list"].length){state.publisherOutput[varname+"-list"]=lst;}// Abbreviate each of the items in the list here!
for(var i=0,ilen=lst.length;i<ilen;i+=1){lst[i]=abbreviate(state,tok,Item,false,lst[i],family_var,true);}state.tmp[varname+"-token"]=tok;return true;}}return false;}function citeFormCheck(Item,value){var m=value.match(/^#([0-9]+).*>>>/);if(m&&m[1]){Item["cite-form"]=m[1];}}// The name transform code is placed here to keep similar things
// in one place.  Obviously this module could do with a little
// tidying up.
function quashCheck(jurisdiction,value){var m=value.match(/^(?:#[0-9]+)*(?:!((?:[-_a-z]+(?:(?:.*)))(?:,(?:[-_a-z]+(?:(?:.*))))*))*>>>/);if(m){value=value.slice(m[0].length);if(m[1]){var fields=m[1].split(",");for(var i=0,ilen=fields.length;i<ilen;i+=1){var rawField=fields[i];var mm=rawField.match(/^([-_a-z]+)(?:\:(.*))*$/);var field=mm[1];// trimmer is not available in getAmbiguousCite
var trimmer=state.tmp.abbrev_trimmer;if(mm[2]){if(trimmer&&jurisdiction){if(!trimmer[jurisdiction]){trimmer[jurisdiction]={};}trimmer[jurisdiction][field]=mm[2];}}else if(state.tmp.done_vars.indexOf(field)===-1){if(trimmer&&jurisdiction){if(!trimmer.QUASHES[jurisdiction]){trimmer.QUASHES[jurisdiction]={};}trimmer.QUASHES[jurisdiction][field]=true;}state.tmp.done_vars.push(field);}}}}return value;}this.quashCheck=quashCheck;// Return function appropriate to selected options
function getOutputFunction(variables,family_var,abbreviation_fallback,alternative_varname){// var mytoken;
// Set the primary_locale and secondary_locale lists appropriately.
// No instance helper function for this; everything can be derived
// from processor settings and rendering context.
var localesets;var langPrefs=CSL.LangPrefsMap[variables[0]];if(!langPrefs){localesets=false;}else{localesets=state.opt['cite-lang-prefs'][langPrefs];}return function(state,Item,item){var primary,primary_locale,secondary,secondary_locale,tertiary,tertiary_locale,primary_tok;if(!variables[0]||!Item[variables[0]]&&!Item[alternative_varname]){return null;}//
// Exploring the edges here.
// "suppress-author" for string variables (mostly titles).
//
if(!state.tmp.just_looking&&item&&item["suppress-author"]){if(!state.tmp.probably_rendered_something&&state.tmp.can_substitute.length()>1){return null;}}var slot={primary:false,secondary:false,tertiary:false};if(state.tmp.area.slice(-5)==="_sort"){slot.primary='locale-sort';}else{if(localesets&&localesets.length===1&&localesets[0]==="locale-orig"){slot.primary="locale-orig";localesets=false;}else if(localesets&&!state.tmp.multi_layout){var slotnames=["primary","secondary","tertiary"];for(var i=0,ilen=slotnames.length;i<ilen;i+=1){if(localesets.length-1<i){break;}if(localesets[i]){slot[slotnames[i]]='locale-'+localesets[i];}}}else{slot.primary='locale-orig';}}if(variables[0]==="title-short"||state.tmp.area!=="bibliography"&&!(state.tmp.area==="citation"&&state.opt.xclass==="note"&&item&&!item.position)){slot.secondary=false;slot.tertiary=false;}if(state.tmp.multi_layout){slot.secondary=false;slot.tertiary=false;}// Problem for multilingual: we really should be
// checking for sanity on the basis of the output
// strings to be actually used. (also below)
if(state.tmp["publisher-list"]){if(variables[0]==="publisher"){state.tmp["publisher-token"]=this;}else if(variables[0]==="publisher-place"){state.tmp["publisher-place-token"]=this;}return null;}// tmp.lang_array carries the current locale IDs of the style
// and the item. Field-level locale IDs are added here, so
// we clone it to allow reset.
var oldLangArray=state.tmp.lang_array.slice();// True is for transform fallback
var res=getTextSubField.call(this,Item,variables[0],slot.primary,true,null,family_var);primary=res.name;primary_locale=res.locale;var primary_tok=res.token;var primaryUsedOrig=res.usedOrig;if(family_var&&!res.found_variant_ok){primary=abbreviate(state,primary_tok,Item,alternative_varname,primary,family_var,true);// Suppress subsequent use of another variable if requested by
// hack syntax in this abbreviation short form.
if(primary){// We run quash-check in getAmbiguousCite, to possibly pick up a cite-form value.
citeFormCheck(Item,primary);if(!state.tmp.just_looking){primary=quashCheck(Item.jurisdiction,primary);}}}if(publisherCheck(this,Item,primary,family_var)){state.tmp.lang_array=oldLangArray;return null;}// No fallback for secondary and tertiary
secondary=false;tertiary=false;var secondary_tok;var tertiary_tok;if(slot.secondary){res=getTextSubField.call(this,Item,variables[0],slot.secondary,false,res.usedOrig,null,family_var);secondary=res.name;secondary_locale=res.locale;secondary_tok=res.token;if(family_var&&!res.found_variant_ok){if(secondary){// The abbreviate() function could use a cleanup, after Zotero correct to use title-short
secondary=abbreviate(state,secondary_tok,Item,false,secondary,family_var,true);}}//print("XXX secondary_locale: "+secondary_locale);
}if(slot.tertiary){res=getTextSubField.call(this,Item,variables[0],slot.tertiary,false,res.usedOrig,null,family_var);tertiary=res.name;tertiary_locale=res.locale;tertiary_tok=res.token;if(family_var&&!res.found_variant_ok){if(tertiary){// The abbreviate() function could use a cleanup, after Zotero correct to use title-short
tertiary=abbreviate(state,tertiary_tok,Item,false,tertiary,family_var,true);}}//print("XXX tertiary_locale: "+tertiary_locale);
}// Decoration of primary (currently translit only) goes here
var primaryPrefix;if(slot.primary==="locale-translit"){primaryPrefix=state.opt.citeAffixes[langPrefs][slot.primary].prefix;}// XXX This should probably protect against italics at higher
// levels.
if(primaryPrefix==="<i>"&&variables[0]==='title'&&!primaryUsedOrig){var hasItalic=false;for(var i=0,ilen=primary_tok.decorations.length;i<ilen;i+=1){if(primary_tok.decorations[i][0]==="@font-style"&&primary_tok.decorations[i][1]==="italic"){hasItalic=true;}}if(!hasItalic){primary_tok.decorations.push(["@font-style","italic"]);}}//print("XXX "+primary_tok.strings["text-case"]);
if(primary_locale!=="en"&&primary_tok.strings["text-case"]==="title"){primary_tok.strings["text-case"]="passthrough";}if("title"===variables[0]){primary=CSL.demoteNoiseWords(state,primary,this["leading-noise-words"]);}if(secondary||tertiary){state.output.openLevel("empty");// A little too aggressive maybe.
primary_tok.strings.suffix=primary_tok.strings.suffix.replace(/[ .,]+$/,"");if(primary_locale){state.tmp.lang_array=[primary_locale].concat(oldLangArray);}CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,null,null,primary_tok,primary_tok.strings.prefix+primary);state.output.append(primary,primary_tok);state.tmp.probably_rendered_something=true;if(primary===secondary){secondary=false;}if(secondary){secondary_tok.strings.prefix=state.opt.citeAffixes[langPrefs][slot.secondary].prefix;secondary_tok.strings.suffix=state.opt.citeAffixes[langPrefs][slot.secondary].suffix;// Add a space if empty
if(!secondary_tok.strings.prefix){secondary_tok.strings.prefix=" ";}// Remove quotes
for(var i=secondary_tok.decorations.length-1;i>-1;i+=-1){if(['@quotes/true','@font-style/italic','@font-style/oblique','@font-weight/bold'].indexOf(secondary_tok.decorations[i].join('/'))>-1){secondary_tok.decorations=secondary_tok.decorations.slice(0,i).concat(secondary_tok.decorations.slice(i+1));}}if(secondary_locale!=="en"&&secondary_tok.strings["text-case"]==="title"){secondary_tok.strings["text-case"]="passthrough";}if(secondary_locale){state.tmp.lang_array=[secondary_locale].concat(oldLangArray);}var secondary_outer=new CSL.Token();secondary_outer.decorations.push(["@font-style","normal"]);secondary_outer.decorations.push(["@font-weight","normal"]);state.output.openLevel(secondary_outer);state.output.append(secondary,secondary_tok);state.output.closeLevel();var blob_obj=state.output.current.value();var blobs_pos=state.output.current.value().blobs.length-1;// Suppress supplementary multilingual info on subsequent
// partners of a parallel cite?
}if(primary===tertiary){tertiary=false;}if(tertiary){tertiary_tok.strings.prefix=state.opt.citeAffixes[langPrefs][slot.tertiary].prefix;tertiary_tok.strings.suffix=state.opt.citeAffixes[langPrefs][slot.tertiary].suffix;// Add a space if empty
if(!tertiary_tok.strings.prefix){tertiary_tok.strings.prefix=" ";}// Remove quotes
for(var i=tertiary_tok.decorations.length-1;i>-1;i+=-1){if(['@quotes/true','@font-style/italic','@font-style/oblique','@font-weight/bold'].indexOf(tertiary_tok.decorations[i].join('/'))>-1){tertiary_tok.decorations=tertiary_tok.decorations.slice(0,i).concat(tertiary_tok.decorations.slice(i+1));}}if(tertiary_locale!=="en"&&tertiary_tok.strings["text-case"]==="title"){tertiary_tok.strings["text-case"]="passthrough";}if(tertiary_locale){state.tmp.lang_array=[tertiary_locale].concat(oldLangArray);}var tertiary_outer=new CSL.Token();tertiary_outer.decorations.push(["@font-style","normal"]);tertiary_outer.decorations.push(["@font-weight","normal"]);state.output.openLevel(tertiary_outer);state.output.append(tertiary,tertiary_tok);state.output.closeLevel();var blob_obj=state.output.current.value();var blobs_pos=state.output.current.value().blobs.length-1;// Suppress supplementary multilingual info on subsequent
// partners of a parallel cite?
// See note above.
}state.output.closeLevel();}else{if(primary_locale){state.tmp.lang_array=[primary_locale].concat(oldLangArray);}CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,null,null,primary_tok,primary_tok.strings.prefix+primary);state.output.append(primary,primary_tok);state.tmp.probably_rendered_something=true;}state.tmp.lang_array=oldLangArray;if(state.tmp.can_block_substitute){state.tmp.name_node.children.push(state.output.current.value());}return null;};}this.getOutputFunction=getOutputFunction;};/*global CSL: true */ /**
 * Style token.
 * <p>This class provides the tokens that define
 * the runtime version of the style.  The tokens are
 * instantiated by {@link CSL.Core.Build}, but the token list
 * must be post-processed with
 * {@link CSL.Core.Configure} before it can be used to generate
 * citations.</p>
 * @param {String} name The node name represented by this token.
 * @param {Int} tokentype A flag indicating whether this token
 * marks the start of a node, the end of a node, or is a singleton.
 * @class
 */CSL.Token=function(name,tokentype,conditional){/**
     * Name of the element.
     * <p>This corresponds to the element name of the
     * relevant tag in the CSL file.
     */this.name=name;/**
     * Strings and other static content specific to the element.
     */this.strings={};this.strings.delimiter=undefined;this.strings.prefix="";this.strings.suffix="";/**
     * Formatting parameters.
     * <p>This is a placeholder at instantiation.  It is
     * replaced by the result of {@link CSL.setDecorations}
     * when the tag is created and configured during {@link CSL.Core.Build}
     * by {@link CSL.XmlToToken}.  The parameters for particular
     * formatting attributes are stored as string arrays, which
     * map to formatting functions at runtime,
     * when the output format is known.  Note that the order in which
     * parameters are registered is fixed by the constant
     * {@link CSL.FORMAT_KEY_SEQUENCE}.
     */this.decorations=[];this.variables=[];/**
     * Element functions.
     * <p>Functions implementing the styling behaviour of the element
     * are pushed into this array in the {@link CSL.Core.Build} phase.
     */this.execs=[];/**
     * Token type.
     * <p>This is a flag constant indicating whether the token represents
     * a start tag, an end tag, or is a singleton.</p>
     */this.tokentype=tokentype;// Conditional attributes added to bare tokens at runtime
/**
     * Condition evaluator.
     * <p>This is a placeholder that receives a single function, and is
     * only relevant for a conditional branching tag (<code>if</code> or
     * <code>else-if</code>).  The function implements the argument to
     * the <code>match=</code> attribute (<code>any</code>, <code>all</code>
     * or <code>none</code>), by executing the functions registered in the
     * <code>tests</code> array (see below), and reacting accordingly.  This
     * function is invoked by the execution wrappers found in
     * {@link CSL.Engine}.</p>
     */ // this.evaluator = false;
/**
     * Conditions.
     * <p>Functions that evaluate to true or false, implementing
     * various posisble attributes to the conditional branching tags,
     * are registered here during {@link CSL.Core.Build}.
     * </p>
     */ // this.tests = [];
/**
     * Jump point on success.
     * <p>This holds the list jump point to be used when the
     * <code>evaluator</code> function of a conditional tag
     * returns true (success).  The jump index value is set during the
     * back-to-front token pass performed during {@link CSL.Core.Configure}.
     * </p>
     */ // this.succeed = false;
/**
     * Jump point on failure.
     * <p>This holds the list jump point to be used when the
     * <code>evaluator</code> function of a conditional tag
     * returns false (failure).  Jump index values are set during the
     * back-to-front token pass performed during {@link CSL.Core.Configure}.
     * </p>
     */ // this.fail = false;
/**
     * Index of next token.
     * <p>This holds the index of the next token in the
     * token list, which is the default "jump-point" for ordinary
     * processing.  Jump index values are set during the
     * back-to-front token pass performed during {@link CSL.Core.Configure}.
     * </p>
     */ // this.next = false;
};// Have needed this for yonks
CSL.Util.cloneToken=function(token){var newtok,key,pos,len;if("string"===typeof token){return token;}newtok=new CSL.Token(token.name,token.tokentype);for(var key in token.strings){if(token.strings.hasOwnProperty(key)){newtok.strings[key]=token.strings[key];}}if(token.decorations){newtok.decorations=[];for(pos=0,len=token.decorations.length;pos<len;pos+=1){newtok.decorations.push(token.decorations[pos].slice());}}if(token.variables){newtok.variables=token.variables.slice();}// Probably overkill; this is only used for cloning formatting
// tokens.
if(token.execs){newtok.execs=token.execs.slice();if(token.tests){newtok.tests=token.tests.slice();}}return newtok;};/*global CSL: true */ /**
 * Ambiguous Cite Configuration Object
 * @class
 */CSL.AmbigConfig=function(){this.maxvals=[];this.minval=1;this.names=[];this.givens=[];this.year_suffix=false;this.disambiguate=0;};/*global CSL: true */CSL.Blob=function(str,token,levelname){var len,pos,key;this.levelname=levelname;//print(levelname);
if(token){this.strings={"prefix":"","suffix":""};for(var key in token.strings){if(token.strings.hasOwnProperty(key)){this.strings[key]=token.strings[key];}}this.decorations=[];if(token.decorations===undefined){len=0;}else{len=token.decorations.length;}for(pos=0;pos<len;pos+=1){this.decorations.push(token.decorations[pos].slice());}}else{this.strings={};this.strings.prefix="";this.strings.suffix="";this.strings.delimiter="";this.decorations=[];}if("string"===typeof str){this.blobs=str;}else if(str){this.blobs=[str];}else{this.blobs=[];}this.alldecor=[this.decorations];};CSL.Blob.prototype.push=function(blob){if("string"===typeof this.blobs){CSL.error("Attempt to push blob onto string object");}else if(false!==blob){blob.alldecor=blob.alldecor.concat(this.alldecor);this.blobs.push(blob);}};/*global CSL: true */ /**
 * An output instance object representing a number or a range
 *
 * with attributes next and start, and
 * methods isRange(), renderStart(), renderEnd() and renderRange().
 * At render time, the output queue will perform optional
 * collapsing of these objects in the queue, according to
 * configurable options, and apply any decorations registered
 * in the object to the output elements.
 * @namespace Range object and friends.
 */CSL.NumericBlob=function(particle,num,mother_token,id){// item id is used to assure that prefix delimiter is invoked only
// when joining blobs across items
this.id=id;this.alldecor=[];this.num=num;this.particle=particle;this.blobs=num.toString();this.status=CSL.START;this.strings={};if(mother_token){this.gender=mother_token.gender;this.decorations=mother_token.decorations;this.strings.prefix=mother_token.strings.prefix;this.strings.suffix=mother_token.strings.suffix;this.strings["text-case"]=mother_token.strings["text-case"];this.successor_prefix=mother_token.successor_prefix;this.range_prefix=mother_token.range_prefix;this.splice_prefix=mother_token.splice_prefix;this.formatter=mother_token.formatter;if(!this.formatter){this.formatter=new CSL.Output.DefaultFormatter();}if(this.formatter){this.type=this.formatter.format(1);}}else{this.decorations=[];this.strings.prefix="";this.strings.suffix="";this.successor_prefix="";this.range_prefix="";this.splice_prefix="";this.formatter=new CSL.Output.DefaultFormatter();}};CSL.NumericBlob.prototype.setFormatter=function(formatter){this.formatter=formatter;this.type=this.formatter.format(1);};CSL.Output.DefaultFormatter=function(){};CSL.Output.DefaultFormatter.prototype.format=function(num){return num.toString();};CSL.NumericBlob.prototype.checkNext=function(next,start){if(start){this.status=CSL.START;if("object"===typeof next){if(next.num===this.num+1){next.status=CSL.SUCCESSOR;}else{next.status=CSL.SEEN;}}}else if(!next||!next.num||this.type!==next.type||next.num!==this.num+1){if(this.status===CSL.SUCCESSOR_OF_SUCCESSOR){this.status=CSL.END;}if("object"===typeof next){next.status=CSL.SEEN;}}else{// next number is in the sequence
if(this.status===CSL.START||this.status===CSL.SEEN){next.status=CSL.SUCCESSOR;}else if(this.status===CSL.SUCCESSOR||this.status===CSL.SUCCESSOR_OF_SUCCESSOR){if(this.range_prefix){next.status=CSL.SUCCESSOR_OF_SUCCESSOR;this.status=CSL.SUPPRESS;}else{next.status=CSL.SUCCESSOR;}}// wakes up the correct delimiter.
//if (this.status === CSL.SEEN) {
//    this.status = CSL.SUCCESSOR;
//}
}};CSL.NumericBlob.prototype.checkLast=function(last){// Used to adjust final non-range join
if(this.status===CSL.SEEN||last.num!==this.num-1&&this.status===CSL.SUCCESSOR){this.status=CSL.SUCCESSOR;return true;}return false;};/*global CSL: true */CSL.Util.fixDateNode=function(parent,pos,node){var form,variable,datexml,subnode,partname,attr,val,prefix,suffix,children,subchildren,display,cslid;var lingo=this.cslXml.getAttributeValue(node,"lingo");var default_locale=this.cslXml.getAttributeValue(node,"default-locale");// Raise date flag, used to control inclusion of year-suffix key in sorts
// This may be a little reckless: not sure what happens on no-date conditions
this.build.date_key=true;form=this.cslXml.getAttributeValue(node,"form");var lingo;if(default_locale){lingo=this.opt["default-locale"][0];}else{lingo=this.cslXml.getAttributeValue(node,"lingo");}if(!this.getDate(form,default_locale)){return parent;}var dateparts=this.cslXml.getAttributeValue(node,"date-parts");variable=this.cslXml.getAttributeValue(node,"variable");prefix=this.cslXml.getAttributeValue(node,"prefix");suffix=this.cslXml.getAttributeValue(node,"suffix");display=this.cslXml.getAttributeValue(node,"display");cslid=this.cslXml.getAttributeValue(node,"cslid");//
// Xml: Copy a node
//
datexml=this.cslXml.nodeCopy(this.getDate(form,default_locale));this.cslXml.setAttribute(datexml,'lingo',this.opt.lang);this.cslXml.setAttribute(datexml,'form',form);this.cslXml.setAttribute(datexml,'date-parts',dateparts);this.cslXml.setAttribute(datexml,"cslid",cslid);//
// Xml: Set attribute
//
this.cslXml.setAttribute(datexml,'variable',variable);this.cslXml.setAttribute(datexml,'default-locale',default_locale);//
// Xml: Set flag
//
if(prefix){//
// Xml: Set attribute
//
this.cslXml.setAttribute(datexml,"prefix",prefix);}if(suffix){//
// Xml: Set attribute
//
this.cslXml.setAttribute(datexml,"suffix",suffix);}if(display){//
// Xml: Set attribute
//
this.cslXml.setAttribute(datexml,"display",display);}//
// Step through any date-part children of the layout date node,
// and lay their attributes onto the corresponding node in the
// locale template node copy.
//
// tests: language_BaseLocale
// tests: date_LocalizedTextInStyleLocaleWithTextCase
//
children=this.cslXml.children(datexml);for(var key in children){subnode=children[key];if("date-part"===this.cslXml.nodename(subnode)){partname=this.cslXml.getAttributeValue(subnode,"name");if(default_locale){this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml,"date-part",partname,"@default-locale","true");}}}children=this.cslXml.children(node);for(var key in children){subnode=children[key];if("date-part"===this.cslXml.nodename(subnode)){partname=this.cslXml.getAttributeValue(subnode,"name");subchildren=this.cslXml.attributes(subnode);for(attr in subchildren){if("@name"===attr){continue;}if(lingo&&lingo!==this.opt.lang){if(["@suffix","@prefix","@form"].indexOf(attr)>-1){continue;}}val=subchildren[attr];this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml,"date-part",partname,attr,val);}}}if("year"===this.cslXml.getAttributeValue(node,"date-parts")){//
// Xml: Find one node by attribute and delete
//
this.cslXml.deleteNodeByNameAttribute(datexml,'month');//
// Xml: Find one node by attribute and delete
//
this.cslXml.deleteNodeByNameAttribute(datexml,'day');}else if("year-month"===this.cslXml.getAttributeValue(node,"date-parts")){//
// Xml: Find one node by attribute and delete
//
this.cslXml.deleteNodeByNameAttribute(datexml,'day');}else if("month-day"===this.cslXml.getAttributeValue(node,"date-parts")){//
// Xml: Get child nodes
//
var childNodes=this.cslXml.children(datexml);for(var i=1,ilen=this.cslXml.numberofnodes(childNodes);i<ilen;i++){//
// Xml: Get attribute value (for string comparison)
//
if(this.cslXml.getAttributeValue(childNodes[i],'name')==="year"){//
// Xml: Set attribute value
//
this.cslXml.setAttribute(childNodes[i-1],"suffix","");break;}}//
// Xml: Find one node by attribute and delete
//
this.cslXml.deleteNodeByNameAttribute(datexml,'year');}return this.cslXml.insertChildNodeAfter(parent,node,pos,datexml);};/*global CSL: true */CSL.dateMacroAsSortKey=function(state,Item){CSL.dateAsSortKey.call(this,state,Item,true);};CSL.dateAsSortKey=function(state,Item,isMacro){var dp,elem,value,e,yr,prefix,i,ilen;var variable=this.variables[0];var macroFlag="empty";if(isMacro&&state.tmp.extension){macroFlag="macro-with-date";}dp=Item[variable];if("undefined"===typeof dp){dp={"date-parts":[[0]]};}if("undefined"===typeof this.dateparts){this.dateparts=["year","month","day"];}if(dp.raw){dp=state.fun.dateparser.parseDateToArray(dp.raw);}else if(dp["date-parts"]){dp=state.dateParseArray(dp);}if("undefined"===typeof dp){dp={};}if(dp.year){for(i=0,ilen=CSL.DATE_PARTS_INTERNAL.length;i<ilen;i+=1){elem=CSL.DATE_PARTS_INTERNAL[i];value=0;e=elem;if(e.slice(-4)==="_end"){e=e.slice(0,-4);}if(dp[elem]&&this.dateparts.indexOf(e)>-1){value=dp[elem];}if(elem.slice(0,4)==="year"){yr=CSL.Util.Dates[e].numeric(state,value);var prefix="1";if(yr[0]==="-"){prefix="0";yr=yr.slice(1);yr=9999-parseInt(yr,10);}state.output.append(CSL.Util.Dates[elem.slice(0,4)].numeric(state,prefix+yr),macroFlag);}else{value=CSL.Util.Dates[e]["numeric-leading-zeros"](state,value);// Ugh.
if(!value){value="00";}state.output.append(value,macroFlag);}}}};CSL.Engine.prototype.dateParseArray=function(date_obj){var ret,field,dp,exts;ret={};for(field in date_obj){if(field==="date-parts"){dp=date_obj["date-parts"];if(dp.length>1){if(dp[0].length!==dp[1].length){CSL.error("CSL data error: element mismatch in date range input.");}}exts=["","_end"];for(var i=0,ilen=dp.length;i<ilen;i+=1){for(var j=0,jlen=CSL.DATE_PARTS.length;j<jlen;j+=1){if(isNaN(parseInt(dp[i][j],10))){ret[CSL.DATE_PARTS[j]+exts[i]]=undefined;}else{ret[CSL.DATE_PARTS[j]+exts[i]]=parseInt(dp[i][j],10);}}}}else if(date_obj.hasOwnProperty(field)){// XXXX: temporary workaround
if(field==="literal"&&"object"===typeof date_obj.literal&&"string"===typeof date_obj.literal.part){CSL.debug("Warning: fixing up weird literal date value");ret.literal=date_obj.literal.part;}else{ret[field]=date_obj[field];}}}return ret;};/*global CSL: true */CSL.Util.Names={};CSL.Util.Names.compareNamesets=CSL.NameOutput.prototype._compareNamesets;/**
 * Un-initialize a name (quash caps after first character)
 */CSL.Util.Names.unInitialize=function(state,name){var i,ilen,namelist,punctlist,ret;if(!name){return"";}namelist=name.split(/(?:\-|\s+)/);punctlist=name.match(/(\-|\s+)/g);ret="";for(i=0,ilen=namelist.length;i<ilen;i+=1){// if (CSL.ALL_ROMANESQUE_REGEXP.exec(namelist[i].slice(0,-1)) 
//    && namelist[i] 
//    && namelist[i] !== namelist[i].toUpperCase()) {
// More or less like this, to address the following fault report:
// http://forums.zotero.org/discussion/17610/apsa-problems-with-capitalization-of-mc-mac-etc/
// Leaving the name string untouched because name capitalization is varied and wonderful.
// https://github.com/Juris-M/citeproc-js/issues/43
//namelist[i] = namelist[i].slice(0, 1) + namelist[i].slice(1, 2).toLowerCase() + namelist[i].slice(2);
// }
ret+=namelist[i];if(i<ilen-1){ret+=punctlist[i];}}return ret;};/**
 * Initialize a name.
 */CSL.Util.Names.initializeWith=function(state,name,terminator,normalizeOnly){var i,ilen,mm,lst,ret;if(!name){return"";}if(!terminator){terminator="";}if(["Lord","Lady"].indexOf(name)>-1||!name.replace(/^(?:<[^>]+>)*/,"").match(CSL.STARTSWITH_ROMANESQUE_REGEXP)&&!terminator.match("%s")){return name;}if(state.opt["initialize-with-hyphen"]===false){name=name.replace(/\-/g," ");}// We need to suss out what is a set of initials or abbreviation,
// so that they can be selectively normalized. Steps might be:
//   (1) Split the string
//   (2) Step through the string, deleting periods and, if initalize="false", then
//       (a) note abbreviations and initials (separately).
//   (3) If initialize="false" then:
//       (a) Do the thing below, but only pushing terminator; or else
//       (b) Do the thing below
name=name.replace(/\s*\-\s*/g,"-").replace(/\s+/g," ");name=name.replace(/-([a-z])/g,"\u2013$1");for(var i=name.length-2;i>-1;i+=-1){if(name.slice(i,i+1)==="."&&name.slice(i+1,i+2)!==" "){name=name.slice(0,i)+". "+name.slice(i+1);}}// (1) Split the string
var nameSplits=CSL.Output.Formatters.nameDoppel.split(name);var namelist=[];namelist=[nameSplits.strings[0]];if(nameSplits.tags.length===0){var mmm=namelist[0].match(/[^\.]+$/);if(mmm&&mmm[0].length===1&&mmm[0]!==mmm[0].toLowerCase()){namelist[0]+=".";}}for(i=1,ilen=nameSplits.strings.length;i<ilen;i+=1){namelist.push(nameSplits.tags[i-1]);namelist.push(nameSplits.strings[i]);}// Use doInitializeName or doNormalizeName, depending on requirements.
if(normalizeOnly){ret=this.doNormalize(state,namelist,terminator);}else{ret=this.doInitialize(state,namelist,terminator);}ret=ret.replace(/\u2013([a-z])/g,"-$1");return ret;};CSL.Util.Names.notag=function(str){return str.replace(/^(?:<[^>]+>)*/,"");};CSL.Util.Names.mergetag=function(state,tagstr,newstr){var m=tagstr.match(/(?:-*<[^>]+>-*)/g);if(!m){return newstr;}else{tagstr=m.join("");}m=newstr.match(/^(.*[^\s])*(\s+)$/);if(m){m[1]=m[1]?m[1]:"";newstr=m[1]+tagstr+m[2];}else{newstr=newstr+tagstr;}return newstr;};CSL.Util.Names.tagonly=function(state,str){var m=str.match(/(?:<[^>]+>)+/);if(!m){return str;}else{return m.join("");}};CSL.Util.Names.doNormalize=function(state,namelist,terminator){var i,ilen;// namelist is a flat list of given-name elements and space-like separators between them
terminator=terminator?terminator:"";// Flag elements that look like abbreviations
var isAbbrev=[];for(i=0,ilen=namelist.length;i<ilen;i+=1){if(this.notag(namelist[i]).length>1&&this.notag(namelist[i]).slice(-1)==="."){// namelist[i] = namelist[i].slice(0, -1);
namelist[i]=namelist[i].replace(/^(.*)\.(.*)$/,"$1$2");isAbbrev.push(true);}else if(namelist[i].length===1&&namelist[i].toUpperCase()===namelist[i]){isAbbrev.push(true);}else{isAbbrev.push(false);}}// Step through the elements of the givenname array
for(i=0,ilen=namelist.length;i<ilen;i+=2){// If the element is not an abbreviation, leave it and its trailing spaces alone
if(isAbbrev[i]){// For all elements but the last
if(i<namelist.length-2){// Start from scratch on space-like things following an abbreviation
namelist[i+1]=this.tagonly(state,namelist[i+1]);if(!isAbbrev[i+2]){namelist[i+1]=this.tagonly(state,namelist[i+1])+" ";}// Add the terminator to the element
// If the following element is not a single-character abbreviation, remove a trailing zero-width non-break space, if present
// These ops may leave some duplicate cruft in the elements and separators. This will be cleaned at the end of the function.
if(namelist[i+2].length>1){namelist[i+1]=terminator.replace(/\ufeff$/,"")+namelist[i+1];}else{namelist[i+1]=this.mergetag(state,namelist[i+1],terminator);}}// For the last element (if it is an abbreviation), just append the terminator
if(i===namelist.length-1){namelist[i]=namelist[i]+terminator;}}}// Remove trailing cruft and duplicate spaces, and return
return namelist.join("").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/,"").replace(/\s*\-\s*/g,"-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g," ");};CSL.Util.Names.doInitialize=function(state,namelist,terminator){var i,ilen,m,j,jlen,lst,n;for(i=0,ilen=namelist.length;i<ilen;i+=2){n=namelist[i];if(!n){continue;}m=n.match(CSL.NAME_INITIAL_REGEXP);if(!m&&!n.match(CSL.STARTSWITH_ROMANESQUE_REGEXP)&&n.length>1&&terminator.match("%s")){m=n.match(/(.)(.*)/);}if(m&&m[2]&&m[3]){m[1]=m[1]+m[2];m[2]="";}if(m&&m[1].slice(0,1)===m[1].slice(0,1).toUpperCase()){var extra="";if(m[2]){var s="";lst=m[2].split("");for(j=0,jlen=lst.length;j<jlen;j+=1){var c=lst[j];if(c===c.toUpperCase()){s+=c;}else{break;}}if(s.length<m[2].length){extra=CSL.toLocaleLowerCase.call(state,s);}}namelist[i]=m[1]+extra;if(i<ilen-1){if(terminator.match("%s")){namelist[i]=terminator.replace("%s",namelist[i]);}else{if(namelist[i+1].indexOf("-")>-1){namelist[i+1]=this.mergetag(state,namelist[i+1].replace("-",""),terminator)+"-";}else{namelist[i+1]=this.mergetag(state,namelist[i+1],terminator);}}}else{if(terminator.match("%s")){namelist[i]=terminator.replace("%s",namelist[i]);}else{namelist.push(terminator);}}}else if(n.match(CSL.ROMANESQUE_REGEXP)&&(!m||!m[3])){namelist[i]=" "+n;}}var ret=namelist.join("");ret=ret.replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/,"").replace(/\s*\-\s*/g,"-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g," ");return ret;};CSL.Util.Names.getRawName=function(name){var ret=[];if(name.literal){ret.push(name.literal);}else{if(name.given){ret.push(name.given);}if(name.family){ret.push(name.family);}}return ret.join(" ");};/*global CSL: true */ /**
 * Date mangling functions.
 * @namespace Date construction utilities
 */CSL.Util.Dates={};/**
 * Year manglers
 * <p>short, long</p>
 */CSL.Util.Dates.year={};/**
 * Convert year to long form
 * <p>This just passes the number back as a string.</p>
 */CSL.Util.Dates.year["long"]=function(state,num){if(!num){if("boolean"===typeof num){num="";}else{num=0;}}return num.toString();};/**
 * Crudely convert to Japanese Imperial form.
 * <p>Returns the result as a string.</p>
 */CSL.Util.Dates.year.imperial=function(state,num,end){var year="";if(!num){if("boolean"===typeof num){num="";}else{num=0;}}end=end?"_end":"";var month=state.tmp.date_object["month"+end];month=month?""+month:"1";while(month.length<2){month="0"+month;}var day=state.tmp.date_object["day"+end];day=day?""+day:"1";while(day.length<2){day="0"+day;}var date=parseInt(num+month+day,10);var label;var offset;if(date>=18680908&&date<19120730){label='\u660e\u6cbb';offset=1867;}else if(date>=19120730&&date<19261225){label='\u5927\u6b63';offset=1911;}else if(date>=19261225&&date<19890108){label='\u662d\u548c';offset=1925;}else if(date>=19890108){label='\u5e73\u6210';offset=1988;}// This entire "imperial" code block should be cut. Scraped input
// for this will be too ratty to be useful anyway.
if(label&&offset){var normalizedKey=label;if(state.sys.normalizeAbbrevsKey){// The first argument does not need to specify the exact variable
// name.
normalizedKey=state.sys.normalizeAbbrevsKey("number",label);}if(!state.transform.abbrevs['default']['number'][normalizedKey]){// loadAbbreviation normally takes an item as fourth argument.
// It is not available here, 
state.transform.loadAbbreviation('default',"number",normalizedKey,null);}if(state.transform.abbrevs['default']['number'][normalizedKey]){label=state.transform.abbrevs['default']['number'][normalizedKey];}year=label+(num-offset);}return year;};/**
 * Convert year to short form
 * <p>Just crops any 4-digit year to the last two digits.</p>
 */CSL.Util.Dates.year["short"]=function(state,num){num=num.toString();if(num&&num.length===4){return num.substr(2);}};/**
 * Convert year to short form
 * <p>Just crops any 4-digit year to the last two digits.</p>
 */CSL.Util.Dates.year.numeric=function(state,num){var m,pre;num=""+num;var m=num.match(/([0-9]*)$/);if(m){pre=num.slice(0,m[1].length*-1);num=m[1];}else{pre=num;num="";}while(num.length<4){num="0"+num;}return pre+num;};/*
 * MONTH manglers
 * normalize
 * long, short, numeric, numeric-leading-zeros
 */CSL.Util.Dates.normalizeMonth=function(num,useSeason){var ret;if(!num){num=0;}num=""+num;if(!num.match(/^[0-9]+$/)){num=0;}num=parseInt(num,10);if(useSeason){var res={stub:"month-",num:num};if(res.num<1||res.num>24){res.num=0;}else{while(res.num>16){res.num=res.num-4;}if(res.num>12){res.stub="season-";res.num=res.num-12;}}ret=res;}else{if(num<1||num>12){num=0;}ret=num;}return ret;};CSL.Util.Dates.month={};/**
 * Convert month to numeric form
 * <p>This just passes the number back as a string.</p>
 */CSL.Util.Dates.month.numeric=function(state,num){var num=CSL.Util.Dates.normalizeMonth(num);if(!num){num="";}return num;};/**
 * Convert month to numeric-leading-zeros form
 * <p>This just passes the number back as string padded with zeros.</p>
 */CSL.Util.Dates.month["numeric-leading-zeros"]=function(state,num){var num=CSL.Util.Dates.normalizeMonth(num);if(!num){num="";}else{num=""+num;while(num.length<2){num="0"+num;}}return num;};/**
 * Convert month to long form
 * <p>This passes back the month of the locale in long form.</p>
 */ // Gender is not currently used. Is it needed?
CSL.Util.Dates.month["long"]=function(state,num,gender,forceDefaultLocale){var res=CSL.Util.Dates.normalizeMonth(num,true);var num=res.num;if(!num){num="";}else{num=""+num;while(num.length<2){num="0"+num;}num=state.getTerm(res.stub+num,"long",0,0,false,forceDefaultLocale);}return num;};/**
 * Convert month to long form
 * <p>This passes back the month of the locale in short form.</p>
 */ // See above.
CSL.Util.Dates.month["short"]=function(state,num,gender,forceDefaultLocale){var res=CSL.Util.Dates.normalizeMonth(num,true);var num=res.num;if(!num){num="";}else{num=""+num;while(num.length<2){num="0"+num;}num=state.getTerm(res.stub+num,"short",0,0,false,forceDefaultLocale);}return num;};/*
 * DAY manglers
 * numeric, numeric-leading-zeros, ordinal
 */CSL.Util.Dates.day={};/**
 * Convert day to numeric form
 * <p>This just passes the number back as a string.</p>
 */CSL.Util.Dates.day.numeric=function(state,num){return num.toString();};CSL.Util.Dates.day["long"]=CSL.Util.Dates.day.numeric;/**
 * Convert day to numeric-leading-zeros form
 * <p>This just passes the number back as a string padded with zeros.</p>
 */CSL.Util.Dates.day["numeric-leading-zeros"]=function(state,num){if(!num){num=0;}num=num.toString();while(num.length<2){num="0"+num;}return num.toString();};/**
 * Convert day to ordinal form
 * <p>This will one day pass back the number as a string with the
 * ordinal suffix appropriate to the locale.  For the present,
 * it just does what is most of the time right for English.</p>
 */CSL.Util.Dates.day.ordinal=function(state,num,gender){return state.fun.ordinalizer.format(num,gender);};/*global CSL: true */ /**
 * Helper functions for constructing sort keys.
 * @namespace Sort key utilities
 */CSL.Util.Sort={};/**
 * Strip prepositions from a string
 * <p>Used when generating sort keys.</p>
 */CSL.Util.Sort.strip_prepositions=function(str){var m;if("string"===typeof str){m=str.match(/^(([aA]|[aA][nN]|[tT][hH][eE])\s+)/);}if(m){str=str.substr(m[1].length);}return str;};/*global CSL: true */CSL.Util.substituteStart=function(state,target){var element_trace,display,bib_first,func,choose_start,if_start,nodetypes;func=function(state,Item,item){for(var i=0,ilen=this.decorations.length;i<ilen;i+=1){if("@strip-periods"===this.decorations[i][0]&&"true"===this.decorations[i][1]){state.tmp.strip_periods+=1;break;}}};this.execs.push(func);if(this.decorations&&state.opt.development_extensions.csl_reverse_lookup_support){this.decorations.reverse();this.decorations.push(["@showid","true",this.cslid]);this.decorations.reverse();}//
// Contains body code for both substitute and first-field/remaining-fields
// formatting.
//
nodetypes=["number","date","names"];if("text"===this.name&&!this.postponed_macro||nodetypes.indexOf(this.name)>-1){element_trace=function(state,Item,item){if(state.tmp.element_trace.value()==="author"||"names"===this.name){if(!state.tmp.just_looking&&item&&item["author-only"]&&state.tmp.area!=="intext"){if(!state.tmp.probably_rendered_something){}else{state.tmp.element_trace.push("suppress-me");}}if(!state.tmp.just_looking&&item&&item["suppress-author"]){if(!state.tmp.probably_rendered_something){state.tmp.element_trace.push("suppress-me");}}}else if("date"===this.name){if(!state.tmp.just_looking&&item&&item["author-only"]&&state.tmp.area!=="intext"){if(state.tmp.probably_rendered_something){state.tmp.element_trace.push("suppress-me");}}/*
                if (!state.tmp.just_looking && item && item["suppress-author"]) {
                    if (state.tmp.probably_rendered_something) {
                        //state.tmp.element_trace.push("suppress-me");
                    }
                }
                */}else{if(!state.tmp.just_looking&&item&&item["author-only"]&&state.tmp.area!=="intext"){// XXX can_block_substitute probably is doing nothing here. The value is always true.
if(!state.tmp.probably_rendered_something&&state.tmp.can_block_substitute){}else{state.tmp.element_trace.push("suppress-me");}}else if(item&&item["suppress-author"]){state.tmp.element_trace.push("do-not-suppress-me");}}};this.execs.push(element_trace);}display=this.strings.cls;this.strings.cls=false;if(state.build.render_nesting_level===0){//
// The markup formerly known as @bibliography/first
//
// Separate second-field-align from the generic display logic.
// There will be some code replication, but not in the
// assembled style.
//
if(state.build.area==="bibliography"&&state.bibliography.opt["second-field-align"]){bib_first=new CSL.Token("group",CSL.START);bib_first.decorations=[["@display","left-margin"]];func=function(state,Item){if(!state.tmp.render_seen){bib_first.strings.first_blob=Item.id;state.output.startTag("bib_first",bib_first);}};bib_first.execs.push(func);target.push(bib_first);}else if(CSL.DISPLAY_CLASSES.indexOf(display)>-1){bib_first=new CSL.Token("group",CSL.START);bib_first.decorations=[["@display",display]];func=function(state,Item){bib_first.strings.first_blob=Item.id;state.output.startTag("bib_first",bib_first);};bib_first.execs.push(func);target.push(bib_first);}state.build.cls=display;}state.build.render_nesting_level+=1;// Should this be render_nesting_level, with the increment
// below? ... ?
if(state.build.substitute_level.value()===1){//
// All top-level elements in a substitute environment get
// wrapped in conditionals.  The substitute_level variable
// is a stack, because spanned names elements (with their
// own substitute environments) can be nested inside
// a substitute environment.
//
// (okay, we use conditionals a lot more than that.
// we slot them in for author-only as well...)
choose_start=new CSL.Token("choose",CSL.START);CSL.Node.choose.build.call(choose_start,state,target);if_start=new CSL.Token("if",CSL.START);//
// Set a test of the shadow if token to skip this
// macro if we have acquired a name value.
// check for variable
func=function(){if(state.tmp.can_substitute.value()){return true;}return false;};if_start.tests?{}:if_start.tests=[];if_start.tests.push(func);if_start.test=state.fun.match.any(this,state,if_start.tests);target.push(if_start);}if(state.sys.variableWrapper&&this.variables_real&&this.variables_real.length){func=function(state,Item,item){if(!state.tmp.just_looking&&!state.tmp.suppress_decorations){// Attach item data and variable names.
// Do with them what you will.
var variable_entry=new CSL.Token("text",CSL.START);variable_entry.decorations=[["@showid","true"]];state.output.startTag("variable_entry",variable_entry);var position=null;if(item){position=item.position;}if(!position){position=0;}var positionMap=["first","container-subsequent","subsequent","ibid","ibid-with-locator"];var noteNumber=0;if(item&&item.noteIndex){noteNumber=item.noteIndex;}var firstReferenceNoteNumber=0;if(item&&item['first-reference-note-number']){firstReferenceNoteNumber=item['first-reference-note-number'];}var firstContainerReferenceNoteNumber=0;if(item&&item['first-container-reference-note-number']){firstContainerReferenceNoteNumber=item['first-container-reference-note-number'];}var citationNumber=0;// XXX Will this EVER happen?
if(item&&item['citation-number']){citationNumber=item['citation-number'];}var index=0;if(item&&item.index){index=item.index;}var params={itemData:Item,variableNames:this.variables,context:state.tmp.area,xclass:state.opt.xclass,position:positionMap[position],"note-number":noteNumber,"first-reference-note-number":firstReferenceNoteNumber,"first-container-reference-note-number":firstContainerReferenceNoteNumber,"citation-number":citationNumber,"index":index,"mode":state.opt.mode};state.output.current.value().params=params;}};this.execs.push(func);}};CSL.Util.substituteEnd=function(state,target){var func,bib_first_end,bib_other,if_end,choose_end,author_substitute,str;if(state.sys.variableWrapper&&(this.hasVariable||this.variables_real&&this.variables_real.length)){func=function(state){if(!state.tmp.just_looking&&!state.tmp.suppress_decorations){state.output.endTag("variable_entry");}};this.execs.push(func);}func=function(state){for(var i=0,ilen=this.decorations.length;i<ilen;i+=1){if("@strip-periods"===this.decorations[i][0]&&"true"===this.decorations[i][1]){state.tmp.strip_periods+=-1;break;}}};this.execs.push(func);state.build.render_nesting_level+=-1;if(state.build.render_nesting_level===0){if(state.build.cls){func=function(state){state.output.endTag("bib_first");};this.execs.push(func);state.build.cls=false;}else if(state.build.area==="bibliography"&&state.bibliography.opt["second-field-align"]){bib_first_end=new CSL.Token("group",CSL.END);// first func end
func=function(state){if(!state.tmp.render_seen){state.output.endTag("bib_first");// closes bib_first
}};bib_first_end.execs.push(func);target.push(bib_first_end);bib_other=new CSL.Token("group",CSL.START);bib_other.decorations=[["@display","right-inline"]];func=function(state){if(!state.tmp.render_seen){state.tmp.render_seen=true;state.output.startTag("bib_other",bib_other);}};bib_other.execs.push(func);target.push(bib_other);}}if(state.build.substitute_level.value()===1){if_end=new CSL.Token("if",CSL.END);target.push(if_end);choose_end=new CSL.Token("choose",CSL.END);CSL.Node.choose.build.call(choose_end,state,target);}if("names"===this.name||"text"===this.name&&this.variables_real!=="title"){author_substitute=new CSL.Token("text",CSL.SINGLETON);var substitution_name=this.name;func=function(state,Item){if(state.tmp.area!=="bibliography"){return;}if("string"!==typeof state.bibliography.opt["subsequent-author-substitute"]){return;}if(this.variables_real&&!Item[this.variables_real]){return;}// The logic of these two is not obvious. The effect is to enable placeholder substitution
// on a text macro name substitution, without printing both the text macro AND the placeholder.
// See https://forums.zotero.org/discussion/comment/350407
if(this.variables_real&&substitution_name==="names"){return;}var subrule=state.bibliography.opt["subsequent-author-substitute-rule"];var i,ilen;//var text_esc = CSL.getSafeEscape(state);
var printing=!state.tmp.suppress_decorations;if(printing&&state.tmp.subsequent_author_substitute_ok){if(state.tmp.rendered_name){if("partial-each"===subrule||"partial-first"===subrule){var dosub=true;var rendered_name=[];// This is a wee bit risky, as we're assuming that the name
// children and the list of stringified names are congruent.
// That *should* always be true, but you never know.
for(i=0,ilen=state.tmp.name_node.children.length;i<ilen;i+=1){var name=state.tmp.rendered_name[i];if(dosub&&state.tmp.last_rendered_name&&state.tmp.last_rendered_name.length>i-1&&name&&!name.localeCompare(state.tmp.last_rendered_name[i])){str=new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);state.tmp.name_node.children[i].blobs=[str];if("partial-first"===subrule){dosub=false;}}else{dosub=false;}rendered_name.push(name);}// might want to slice this?
state.tmp.last_rendered_name=rendered_name;}else if("complete-each"===subrule){var rendered_name=state.tmp.rendered_name.join(",");if(rendered_name){if(state.tmp.last_rendered_name&&!rendered_name.localeCompare(state.tmp.last_rendered_name)){for(i=0,ilen=state.tmp.name_node.children.length;i<ilen;i+=1){str=new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);state.tmp.name_node.children[i].blobs=[str];}}state.tmp.last_rendered_name=rendered_name;}}else{var rendered_name=state.tmp.rendered_name.join(",");if(rendered_name){if(state.tmp.last_rendered_name&&!rendered_name.localeCompare(state.tmp.last_rendered_name)){str=new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);if(state.tmp.label_blob){state.tmp.name_node.top.blobs=[str,state.tmp.label_blob];}else if(state.tmp.name_node.top.blobs.length){state.tmp.name_node.top.blobs[0].blobs=[str];}else{state.tmp.name_node.top.blobs=[str];}state.tmp.substituted_variable=substitution_name;}state.tmp.last_rendered_name=rendered_name;}}state.tmp.subsequent_author_substitute_ok=false;}}};this.execs.push(func);}if("text"===this.name&&!this.postponed_macro||["number","date","names"].indexOf(this.name)>-1){// element trace
func=function(state,Item){// element_trace is a mess, but it's trying to do something simple.
// A queue append is done, and element_trace.value() returns "suppress-me"
// the append is aborted. That's it.
// It seems only to be used on numeric elements of numeric styles ATM.
// If used only for that purpose, it could be greatly simplified.
// If cleaned up, it could do more interesting things, like control
// the suppression of names set later than first position.
if(state.tmp.element_trace.mystack.length>1){state.tmp.element_trace.pop();}};this.execs.push(func);}};/*global CSL: true */CSL.Util.padding=function(num){var m=num.match(/\s*(-{0,1}[0-9]+)/);if(m){num=parseInt(m[1],10);if(num<0){num=99999999999999999999+num;}num=""+num;while(num.length<20){num="0"+num;}}return num;};CSL.Util.LongOrdinalizer=function(){};CSL.Util.LongOrdinalizer.prototype.init=function(state){this.state=state;};CSL.Util.LongOrdinalizer.prototype.format=function(num,gender){if(num<10){num="0"+num;}// Argument true means "loose".
var ret=CSL.Engine.getField(CSL.LOOSE,this.state.locale[this.state.opt.lang].terms,"long-ordinal-"+num,"long",0,gender);if(!ret){ret=this.state.fun.ordinalizer.format(num,gender);}// Probably too optimistic -- what if only renders in _sort?
this.state.tmp.cite_renders_content=true;return ret;};CSL.Util.Ordinalizer=function(state){this.state=state;this.suffixes={};};CSL.Util.Ordinalizer.prototype.init=function(){if(!this.suffixes[this.state.opt.lang]){this.suffixes[this.state.opt.lang]={};for(var i=0,ilen=3;i<ilen;i+=1){var gender=[undefined,"masculine","feminine"][i];this.suffixes[this.state.opt.lang][gender]=[];for(var j=1;j<5;j+=1){var ordinal=this.state.getTerm("ordinal-0"+j,"long",false,gender);if("undefined"===typeof ordinal){delete this.suffixes[this.state.opt.lang][gender];break;}this.suffixes[this.state.opt.lang][gender].push(ordinal);}}}};CSL.Util.Ordinalizer.prototype.format=function(num,gender){var str;num=parseInt(num,10);str=""+num;var suffix="";var trygenders=[];if(gender){trygenders.push(gender);}trygenders.push("neuter");if(this.state.locale[this.state.opt.lang].ord["1.0.1"]){suffix=this.state.getTerm("ordinal",false,0,gender);var trygender;for(var i=0,ilen=trygenders.length;i<ilen;i+=1){trygender=trygenders[i];var ordinfo=this.state.locale[this.state.opt.lang].ord["1.0.1"];if(ordinfo["whole-number"][str]&&ordinfo["whole-number"][str][trygender]){suffix=this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["whole-number"][str][trygender],false,0,gender);}else if(ordinfo["last-two-digits"][str.slice(str.length-2)]&&ordinfo["last-two-digits"][str.slice(str.length-2)][trygender]){suffix=this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-two-digits"][str.slice(str.length-2)][trygender],false,0,gender);}else if(ordinfo["last-digit"][str.slice(str.length-1)]&&ordinfo["last-digit"][str.slice(str.length-1)][trygender]){suffix=this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-digit"][str.slice(str.length-1)][trygender],false,0,gender);}if(suffix){break;}}}else{if(!gender){// XXX hack to prevent crash on CSL 1.0 styles.
// Reported by Carles.
gender=undefined;}this.state.fun.ordinalizer.init();if(num/10%10===1||num>10&&num<20){suffix=this.suffixes[this.state.opt.lang][gender][3];}else if(num%10===1&&num%100!==11){suffix=this.suffixes[this.state.opt.lang][gender][0];}else if(num%10===2&&num%100!==12){suffix=this.suffixes[this.state.opt.lang][gender][1];}else if(num%10===3&&num%100!==13){suffix=this.suffixes[this.state.opt.lang][gender][2];}else{suffix=this.suffixes[this.state.opt.lang][gender][3];}}str=str+=suffix;return str;};CSL.Util.Romanizer=function(){};CSL.Util.Romanizer.prototype.format=function(num){var ret,pos,n,numstr,len;ret="";if(num<6000){numstr=num.toString().split("");numstr.reverse();pos=0;n=0;len=numstr.length;for(pos=0;pos<len;pos+=1){n=parseInt(numstr[pos],10);ret=CSL.ROMAN_NUMERALS[pos][n]+ret;}}return ret;};/**
 * Create a suffix formed from a list of arbitrary characters of arbitrary length.
 * <p>This is a <i>lot</i> harder than it seems.</p>
 */CSL.Util.Suffixator=function(slist){if(!slist){slist=CSL.SUFFIX_CHARS;}this.slist=slist.split(",");};/**
 * The format method.
 * <p>This method is used in generating ranges.  Every numeric
 * formatter (of which Suffixator is one) must be an instantiated
 * object with such a "format" method.</p>
 */CSL.Util.Suffixator.prototype.format=function(N){// Many thanks to Avram Lyon for this code, and good
// riddance to the several functions that it replaces.
var X;N+=1;var key="";do{X=N%26===0?26:N%26;var key=this.slist[X-1]+key;N=(N-X)/26;}while(N!==0);return key;};CSL.Engine.prototype.processNumber=function(node,ItemObject,variable){//print("** processNumber() ItemObject[variable]="+ItemObject[variable]);
var val;var me=this;var realVariable=variable;variable=variable==="page-first"?"page":variable;var fullformAnd=",\\s+and\\s+|\\s+and\\s+";if(this.opt.lang.slice(0,2)!=="en"){fullformAnd+="|,\\s+"+this.getTerm("and")+"\\s+|\\s+"+this.getTerm("and")+"\\s+";}var symbolAnd="\\s*&\\s*";var andRex=new RegExp("^"+symbolAnd+"$");var joinerMatchRex=new RegExp("("+symbolAnd+"|"+fullformAnd+"|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)","g");var joinerSplitRex=new RegExp("(?:"+symbolAnd+"|"+fullformAnd+"|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)");// This guesses whether the symbol form is defined or not.
// It's the best we can do, because when locales are built, all of the
// holes are filled explictly with fallback values: the symbol form is never undefined.
var localeAnd=this.getTerm("and");var localeAmpersand=this.getTerm("and","symbol");if(localeAnd===localeAmpersand){localeAmpersand="&";}// XXXX shadow_numbers should carry an array of objects with
// XXXX full data for each. The test of a number should be
// XXXX a separate function, possibly supported by a splitter
// XXXX method also used here. Keep code for each action in one place,
// XXXX to prevent debugging from becoming a nightmare.
// The capture pattern below would apply affixes to all sub-elements,
// which is not what we want. Sub-elements should nest within, or
// affixes should be edited. The latter is probably easier to handle.
// values = [
//   {
//     label: "sec.",
//     label-form: "plural",
//     value: 100,
//     styling: [object],
//     numeric: true
//     joiningSuffix: " & ",
//   },
//   {
//     label: "sec.",
//     label-form: "none",
//     value: 103,
//     styling: [object],
//     numeric: true,
//     joiningSuffix: ""
//   }
// ]
function normalizeFieldValue(str){str=str.trim();var m=str.match(/^([^ ]+)/);if(m&&!CSL.STATUTE_SUBDIV_STRINGS[m[1]]){var embeddedLabel=null;if(["locator","locator-extra","page"].indexOf(variable)>-1){if(ItemObject.label){embeddedLabel=CSL.STATUTE_SUBDIV_STRINGS_REVERSE[ItemObject.label];}else{embeddedLabel="p.";}}else{embeddedLabel=CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable];}if(embeddedLabel){str=embeddedLabel+" "+str;}}return str;}function composeNumberInfo(origLabel,label,val,joiningSuffix,parsePosition){joiningSuffix=joiningSuffix?joiningSuffix:"";var info={};if(!label&&!CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable]){label="var:"+variable;}if(label){var m=label.match(/(\s*)([^\s]+)(\s*)/);if(realVariable==="page"&&parsePosition===0&&["p.","pp."].indexOf(m[2])===-1){info.gotosleepability=true;info.labelVisibility=true;}else{info.labelVisibility=false;}info.label=m[2];info.origLabel=origLabel;info.labelSuffix=m[3]?m[3]:"";info.plural=0;}var m=val.match(/^([0-9]*[a-zA-Z]+0*)?([0-9]+(?:[a-zA-Z]*|[-,a-zA-Z]+))$/);//var m = val.match(/^([0-9]*[a-zA-Z]0*)([0-9]+(?:[a-zA-Z]*|[-,a-zA-Z]+))$/);
if(m){info.particle=m[1]?m[1]:"";info.value=m[2];}else{info.particle="";info.value=val;}info.joiningSuffix=joiningSuffix.replace(/\s*-\s*/,"-");return info;}function fixupSubsections(elems){// This catches things like p. 12a-c, recombining content to yield
// numeric true despite the hyphen.
for(var i=elems.length-2;i>-1;i-=2){if(elems[i]==="-"&&elems[i-1].match(/^(?:(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\.  *)*[0-9]+[,a-zA-Z]+$/)&&elems[i+1].match(/^[,a-zA-Z]+$/)){elems[i-1]=elems.slice(i-1,i+2).join("");elems=elems.slice(0,i).concat(elems.slice(i+2));}}return elems;}function parseString(str,defaultLabel){defaultLabel=defaultLabel?defaultLabel:"";str=normalizeFieldValue(str,defaultLabel);var jmrex,jsrex,mystr;if(str.indexOf("\u2013")>-1){str=str.replace(/\u2013/g,"-");}if(str.indexOf("\\-")>-1){jmrex=new RegExp(joinerMatchRex.source.replace("\\-",""));jsrex=new RegExp(joinerSplitRex.source.replace("\\-",""));var lst=str.split("\\-");for(var i=0,ilen=lst.length;i<ilen;i++){lst[i]=lst[i].replace(/\-/g,"\u2013");}mystr=lst.join("\\-");mystr=mystr.replace(/\\/g,"");}else{jmrex=joinerMatchRex;jsrex=joinerSplitRex;mystr=str;}// jmrex = joinerMatchRex;
// jsrex = joinerSplitRex;
// Split chunks and collate delimiters.
var elems=[];var m=mystr.match(jmrex);if(m){var lst=mystr.split(jsrex);for(var i=0,ilen=m.length;i<ilen;i++){if(m[i].match(andRex)){if(lst[i].match(/[a-zA-Z]$/)&&lst[i].match(/^[a-zA-Z]/)){m[i]=localeAmpersand;}else{m[i]=" "+localeAmpersand+" ";}}}var recombine=false;for(var i in lst){if((""+lst[i]).replace(/^[a-z]\.\s+/,"").match(/[^\s0-9ivxlcmIVXLCM]/)){//recombine = true;
break;}}if(recombine){elems=[mystr];}else{for(var i=0,ilen=lst.length-1;i<ilen;i++){elems.push(lst[i]);elems.push(m[i]);}elems.push(lst[lst.length-1]);//print("ELEMS: "+elems);
elems=fixupSubsections(elems);//print("  fixup: "+elems);
}}else{var elems=[mystr];}// Split elements within each chunk build list of value objects.
var values=[];var label=defaultLabel;var origLabel="";for(var i=0,ilen=elems.length;i<ilen;i+=2){// AHA! HERE'S THE CULPRIT!!!
// Words up to four characters are treated as honorary short-form labels.
// Some valid labels are longer than four chars, so we stir those in explicitly
var m=elems[i].match(/((?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/g);if(m){var lst=elems[i].split(/(?:(?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/);// Head off disaster by merging parsed labels on non-numeric values into content
for(var j=lst.length-1;j>0;j--){if(lst[j-1]&&(!lst[j].match(/^[0-9]+([-;,:a-zA-Z]*)$/)||!lst[j-1].match(/^[0-9]+([-;,:a-zA-Z]*)$/))){lst[j-1]=lst[j-1]+m[j-1]+lst[j];lst=lst.slice(0,j).concat(lst.slice(j+1));m=m.slice(0,j-1).concat(m.slice(j));}}// merge bad leading label into content
if(m.length>0){var slug=m[0].trim();var notAlabel=!CSL.STATUTE_SUBDIV_STRINGS[slug]||"undefined"===typeof me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[slug])||["locator","number","locator-extra","page"].indexOf(variable)===-1&&CSL.STATUTE_SUBDIV_STRINGS[slug]!==variable;if(notAlabel){if(i===0){m=m.slice(1);lst[0]=lst[0]+" "+slug+" "+lst[1];lst=lst.slice(0,1).concat(lst.slice(2));}}else{origLabel=slug;}}for(var j=0,jlen=lst.length;j<jlen;j++){if(lst[j]||j===lst.length-1){var filteredOrigLabel;label=m[j-1]?m[j-1]:label;if(origLabel===label.trim()){filteredOrigLabel="";}else{filteredOrigLabel=origLabel;}//var origLabel = j > 1 ? m[j-1] : "";
mystr=lst[j]?lst[j].trim():"";if(j===lst.length-1){values.push(composeNumberInfo(filteredOrigLabel,label,mystr,elems[i+1],i));}else{values.push(composeNumberInfo(filteredOrigLabel,label,mystr,null,i));}}}}else{var filteredOrigLabel;if(origLabel===label.trim()){filteredOrigLabel="";}else{filteredOrigLabel=origLabel;}values.push(composeNumberInfo(filteredOrigLabel,label,elems[i],elems[i+1]));}}return values;}function setSpaces(values){// Add space joins (is this really right?)
for(var i=0,ilen=values.length-1;i<ilen;i++){if(!values[i].joiningSuffix&&values[i+1].label){values[i].joiningSuffix=" ";}}}function fixNumericAndCount(values,i,currentLabelInfo){var master=values[currentLabelInfo.pos];var val=values[i].value;var isEscapedHyphen=master.joiningSuffix==="\\-";if(val.particle&&val.particle!==master.particle){currentLabelInfo.collapsible=false;}var mVal=val.match(/^[0-9]+([-,:a-zA-Z]*)$/);var mCurrentLabel=master.value.match(/^(?:[0-9]+|[ixv]+)([-,:a-zA-Z]*|\-[\-0-9]+)$/);if(!val||!mVal||!mCurrentLabel||isEscapedHyphen){currentLabelInfo.collapsible=false;if(!val||!mCurrentLabel){currentLabelInfo.numeric=false;}if(isEscapedHyphen){currentLabelInfo.count--;}}if(mVal&&mVal[1]||mCurrentLabel&&mCurrentLabel[1]){currentLabelInfo.collapsible=false;}if(undefined===values[i].collapsible){for(var j=i,jlen=i+currentLabelInfo.count;j<jlen;j++){if(isNaN(parseInt(values[j].value))&&!values[j].value.match(/^[ivxlcmIVXLCM]+$/)){values[j].collapsible=false;}else{values[j].collapsible=true;}}currentLabelInfo.collapsible=values[i].collapsible;}var isCollapsible=currentLabelInfo.collapsible;for(var j=currentLabelInfo.pos,jlen=currentLabelInfo.pos+currentLabelInfo.count;j<jlen;j++){if(currentLabelInfo.count>1&&isCollapsible){values[j].plural=1;}values[j].numeric=currentLabelInfo.numeric;values[j].collapsible=currentLabelInfo.collapsible;}}function fixLabelVisibility(values,groupStartPos,currentLabelInfo){if(currentLabelInfo.label.slice(0,4)!=="var:"){if(currentLabelInfo.pos===0){if(["locator","number","locator-extra","page"].indexOf(variable)>-1){// Actually, shouldn't we do this always?
if("undefined"===typeof me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label])){values[currentLabelInfo.pos].labelVisibility=true;}}// If there is an explicit
// label embedded at the start of a field that
// does not match the context, it should be
// marked for rendering.
if(["locator","number","locator-extra","page"].indexOf(variable)===-1){if(CSL.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label]!==variable){values[0].labelVisibility=true;}}}else{// Also, mark initial mid-field labels for
// rendering.
//if (values[i-1].label !== values[i].label && currentLabelInfo.label.slice(0, 4) !== "var:") {
values[currentLabelInfo.pos].labelVisibility=true;//}
}}}function setPluralsAndNumerics(values){if(values.length===0){return;}var groupStartPos=0;var groupCount=1;for(var i=1,ilen=values.length;i<ilen;i++){var lastVal=values[i-1];var thisVal=values[i];if(lastVal.label===thisVal.label&&lastVal.particle===lastVal.particle){groupCount++;}else{var currentLabelInfo=JSON.parse(JSON.stringify(values[groupStartPos]));currentLabelInfo.pos=groupStartPos;currentLabelInfo.count=groupCount;currentLabelInfo.numeric=true;fixNumericAndCount(values,groupStartPos,currentLabelInfo);if(lastVal.label!==thisVal.label){fixLabelVisibility(values,groupStartPos,currentLabelInfo);}groupStartPos=i;groupCount=1;}}// Not sure why this repetition is necessary?
var currentLabelInfo=JSON.parse(JSON.stringify(values[groupStartPos]));currentLabelInfo.pos=groupStartPos;currentLabelInfo.count=groupCount;currentLabelInfo.numeric=true;fixNumericAndCount(values,groupStartPos,currentLabelInfo);fixLabelVisibility(values,groupStartPos,currentLabelInfo);if(values.length&&values[0].numeric&&variable.slice(0,10)==="number-of-"){if(parseInt(ItemObject[realVariable],10)>1){values[0].plural=1;}}}function stripHyphenBackslash(joiningSuffix){return joiningSuffix.replace("\\-","-");}function setStyling(values){var masterNode=CSL.Util.cloneToken(node);var masterStyling=new CSL.Token();if(!me.tmp.just_looking){// Per discussion @ https://discourse.citationstyles.org/t/formatting-attributes-and-hyphen/1518
masterStyling.decorations=masterNode.decorations;masterNode.decorations=[];//for (var j=masterNode.decorations.length-1;j>-1;j--) {
//    if (masterNode.decorations[j][0] === "@quotes") {
//        // Add to styling
//        masterStyling.decorations = masterStyling.decorations.concat(masterNode.decorations.slice(j, j+1));
//        // Remove from node
//        masterNode.decorations = masterNode.decorations.slice(0, j).concat(masterNode.decorations.slice(j+1));
//    }
//}
masterStyling.strings.prefix=masterNode.strings.prefix;masterNode.strings.prefix="";masterStyling.strings.suffix=masterNode.strings.suffix;masterNode.strings.suffix="";}var masterLabel=values.length?values[0].label:null;if(values.length){for(var i=0,ilen=values.length;i<ilen;i++){var val=values[i];// Clone node, make styling parameters on each instance sane.
var newnode=CSL.Util.cloneToken(masterNode);newnode.gender=node.gender;if(masterLabel===val.label){newnode.formatter=node.formatter;}if(val.numeric){newnode.successor_prefix=val.successor_prefix;}newnode.strings.suffix=newnode.strings.suffix+stripHyphenBackslash(val.joiningSuffix);val.styling=newnode;}if(!me.tmp.just_looking){if(values[0].value.slice(0,1)==="\""&&values[values.length-1].value.slice(-1)==="\""){values[0].value=values[0].value.slice(1);values[values.length-1].value=values[values.length-1].value.slice(0,-1);masterStyling.decorations.push(["@quotes",true]);}}}return masterStyling;}function checkTerm(variable,val){var ret=true;if(["locator","locator-extra","page"].indexOf(variable)>-1){var label;if(val.origLabel){label=val.origLabel;}else{label=val.label;}ret=!!me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[label]);}return ret;}function checkPage(variable,val){return"page"===variable||["locator","locator-extra"].indexOf(variable)>-1&&(["p."].indexOf(val.label)>-1||["p."].indexOf(val.origLabel)>-1);}function fixupRangeDelimiter(variable,val,rangeDelimiter,isNumeric){var isPage=checkPage(variable,val);var hasTerm=checkTerm(variable,val);if(hasTerm&&rangeDelimiter==="-"){if(isNumeric){if(isPage||["locator","locator-extra","issue","volume","edition","number"].indexOf(variable)>-1){rangeDelimiter=me.getTerm("page-range-delimiter");if(!rangeDelimiter){rangeDelimiter="\u2013";}}if(variable==="collection-number"){rangeDelimiter=me.getTerm("year-range-delimiter");if(!rangeDelimiter){rangeDelimiter="\u2013";}}}}//if (rangeDelimiter === "\\-") {
//    rangeDelimiter = "-";
//}
return rangeDelimiter;}function manglePageNumbers(values,i,currentInfo){if(i<1){return;}if(currentInfo.count!==2){return;}if(values[i-1].particle!==values[i].particle){return;}if(values[i-1].joiningSuffix!=="-"){currentInfo.count=1;return;}if(!me.opt["page-range-format"]&&parseInt(values[i-1].value,10)>parseInt(values[i].value,10)){values[i-1].joiningSuffix=fixupRangeDelimiter(variable,values[i],values[i-1].joiningSuffix,true);return;}var val=values[i];var isPage=checkPage(variable,val);var str;if(isPage&&!isNaN(parseInt(values[i-1].value))&&!isNaN(parseInt(values[i].value))){str=values[i-1].particle+values[i-1].value+" - "+values[i].particle+values[i].value;str=me.fun.page_mangler(str);}else{// if (("" + values[i-1].value).match(/[0-9]$/) && ("" + values[i].value).match(/^[0-9]/)) {
if((""+values[i-1].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/)&&(""+values[i].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/)){values[i-1].joiningSuffix=me.getTerm("page-range-delimiter");}str=values[i-1].value+stripHyphenBackslash(values[i-1].joiningSuffix)+values[i].value;}var m=str.match(/^((?:[0-9]*[a-zA-Z]+0*))?([0-9]+[a-z]*)(\s*[^0-9]+\s*)([-,a-zA-Z]?0*)([0-9]+[a-z]*)$/);// var m = str.match(/^((?:[0-9]*[a-zA-Z]+0*))?([0-9]+[a-z]*)(\s*[^0-9]+\s*)([-,a-zA-Z]?0*)([0-9]+[a-z]*)$/);
if(m){var rangeDelimiter=m[3];rangeDelimiter=fixupRangeDelimiter(variable,val,rangeDelimiter,values[i].numeric);values[i-1].particle=m[1];values[i-1].value=m[2];values[i-1].joiningSuffix=rangeDelimiter;values[i].particle=m[4];values[i].value=m[5];}currentInfo.count=0;}function fixRanges(values){if(!node){return;}if(["page","chapter-number","collection-number","edition","issue","number","number-of-pages","number-of-volumes","volume","locator","locator-extra"].indexOf(variable)===-1){return;}var currentInfo={count:0,label:null,lastHadRangeDelimiter:false};for(var i=0,ilen=values.length;i<ilen;i++){var val=values[i];if(!val.collapsible){currentInfo.count=0;currentInfo.label=null;var isNumeric=val.numeric;val.joiningSuffix=fixupRangeDelimiter(variable,val,val.joiningSuffix,isNumeric);}else if(currentInfo.label===val.label&&val.joiningSuffix==="-"){// So if there is a hyphen here, and none previous, reset to 1
currentInfo.count=1;}else if(currentInfo.label===val.label&&val.joiningSuffix!=="-"){// If there is NO hyphen here, count up
currentInfo.count++;if(currentInfo.count===2){manglePageNumbers(values,i,currentInfo);}}else if(currentInfo.label!==val.label){// If the label doesn't match and count is 2, process
currentInfo.label=val.label;currentInfo.count=1;}else{// Safety belt: label doesn't match and count is some other value, so reset to 1
// This never happens, though.
currentInfo.count=1;currentInfo.label=val.label;}}// Finally clear, if needed
if(currentInfo.count===2){manglePageNumbers(values,values.length-1,currentInfo);}}function setVariableParams(shadow_numbers,realVariable,values){var obj=shadow_numbers[realVariable];if(values.length){obj.numeric=values[0].numeric;obj.collapsible=values[0].collapsible;obj.plural=values[0].plural;obj.label=CSL.STATUTE_SUBDIV_STRINGS[values[0].label];if(variable==="number"&&obj.label==="issue"&&me.getTerm("number")){obj.label="number";}}}// Split out the labels and values.
// short-circuit if object exists: if numeric, set styling, no other action
if(node&&this.tmp.shadow_numbers[realVariable]&&this.tmp.shadow_numbers[realVariable].values.length){var values=this.tmp.shadow_numbers[realVariable].values;fixRanges(values);//if (!this.tmp.shadow_numbers[variable].masterStyling && !this.tmp.just_looking) {
this.tmp.shadow_numbers[realVariable].masterStyling=setStyling(values);//}
return;}// info.styling = node;
// This carries value, pluralization and numeric info for use in other contexts.
// XXX We used to use one set of params for the entire variable value.
// XXX Now params are set on individual objects, of which there may be several after parsing.
if(!this.tmp.shadow_numbers[realVariable]){this.tmp.shadow_numbers[realVariable]={values:[]};}//this.tmp.shadow_numbers[variable].values = [];
//this.tmp.shadow_numbers[variable].plural = 0;
//this.tmp.shadow_numbers[variable].numeric = false;
//this.tmp.shadow_numbers[variable].label = false;
if(!ItemObject){return;}// Possibly apply multilingual transform
var languageRole=CSL.LangPrefsMap[variable];if(languageRole){var localeType=this.opt["cite-lang-prefs"][languageRole][0];val=this.transform.getTextSubField(ItemObject,realVariable,"locale-"+localeType,true);val=val.name;}else{val=ItemObject[realVariable];}if(val&&realVariable==="number"&&ItemObject.type==="legal_case"){val=val.replace(/[\\]*-/g,"\\-");}// XXX HOLDING THIS
// Apply short form ONLY if first element tests is-numeric=false
if(val&&this.sys.getAbbreviation){// RefMe bug report: print("XX D'oh! (3): "+num);
// true as the fourth argument suppresses update of the UI
// No need for this.
//val = ("" + val).replace(/^\"/, "").replace(/\"$/, "");
if(this.sys.normalizeAbbrevsKey){var normval=this.sys.normalizeAbbrevsKey(realVariable,val);}else{var normval=val;}var jurisdiction=this.transform.loadAbbreviation(ItemObject.jurisdiction,"number",normval,ItemObject.language);if(this.transform.abbrevs[jurisdiction].number){if(this.transform.abbrevs[jurisdiction].number[normval]){val=this.transform.abbrevs[jurisdiction].number[normval];}else{// *** This is terrible ***
// Strings rendered via cs:number should not be added to the abbreviations
// UI unless they test non-numeric. The test happens below.
if("undefined"!==typeof this.transform.abbrevs[jurisdiction].number[normval]){delete this.transform.abbrevs[jurisdiction].number[normval];}}}}//   {
//     label: "sec.",
//     labelForm: "plural",
//     labelVisibility: true,
//     value: 100,
//     styling: [object],
//     numeric: true
//     joiningSuffix: " & ",
//   },
// Process only if there is a value.
if("undefined"!==typeof val&&("string"===typeof val||"number"===typeof val)){if("number"===typeof val){val=""+val;}var defaultLabel=CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable];if(this.tmp.shadow_numbers[realVariable].values.length===0){// XXX
var values=parseString(val,defaultLabel);setSpaces(values);//print("setSpaces(): "+JSON.stringify(values, null, 2));
setPluralsAndNumerics(values);//print("setPluralsAndNumerics(): "+JSON.stringify(values, null, 2));
for(var obj of values){if(!obj.numeric)obj.plural=0;}this.tmp.shadow_numbers[realVariable].values=values;// me.sys.print(JSON.stringify(values))
if(node){fixRanges(values);this.tmp.shadow_numbers[realVariable].masterStyling=setStyling(values);// me.sys.print("setStyling(): "+JSON.stringify(values, null, 2));
}setVariableParams(this.tmp.shadow_numbers,realVariable,values);}// hack in support for non-numeric numerics like "91 Civ. 5442 (RPP)|91 Civ. 5471"
var info=this.tmp.shadow_numbers[realVariable];if(variable==="number"){if(info.values.length===1&&info.values[0].value.indexOf("|")>-1){info.values[0].value=info.values[0].value.replace(/\|/g,", ");info.values[0].numeric=true;info.values[0].plural=1;info.values[0].collapsible=false;info.numeric=true;info.plural=1;info.collapsible=false;}}if(info.values.length===1){if(info.values[0].value.match(/^[0-9]+(?:\/[0-9]+)+$/)){info.values[0].numeric=true;info.values[0].plural=0;info.values[0].collapsible=false;info.numeric=true;info.plural=0;info.collapsible=false;}}if(variable==="page"){if(info.values.length>0){if(info.values[0].gotosleepability){info.labelForm="short";}}}//this.sys.print("OK "+JSON.stringify(values, ["label", "origLabel", "labelSuffix", "particle", "collapsible", "value", "numeric", "joiningSuffix", "labelVisibility", "plural"], 2));
}};CSL.Util.outputNumericField=function(state,varname,itemID){state.output.openLevel(state.tmp.shadow_numbers[varname].masterStyling);var masterStyling=state.tmp.shadow_numbers[varname].masterStyling;var nums=state.tmp.shadow_numbers[varname].values;var masterLabel=nums.length?nums[0].label:null;var labelForm=state.tmp.shadow_numbers[varname].labelForm;var tryStatic=state.tmp.group_context.tip.label_static;var embeddedLabelForm;if(labelForm){embeddedLabelForm=labelForm;}else{embeddedLabelForm="short";//labelForm = "short";
}var labelCapitalizeIfFirst=state.tmp.shadow_numbers[varname].labelCapitalizeIfFirst;var labelDecorations=state.tmp.shadow_numbers[varname].labelDecorations;var lastLabelName=null;for(var i=0,ilen=nums.length;i<ilen;i++){var num=nums[i];var label="";var labelName;if(num.label){if('var:'===num.label.slice(0,4)){labelName=num.label.slice(4);}else{labelName=CSL.STATUTE_SUBDIV_STRINGS[num.label];}if(labelName){// Simplify this some day.
if(num.label===masterLabel){if(tryStatic){label=state.getTerm(labelName,"static",num.plural);if(label.indexOf("%s")===-1){label="";}}if(!label){label=state.getTerm(labelName,labelForm,num.plural);}}else{if(tryStatic){label=state.getTerm(labelName,"static",num.plural);if(label.indexOf("%s")===-1){label="";}}if(!label){label=state.getTerm(labelName,embeddedLabelForm,num.plural);}}if(labelCapitalizeIfFirst){label=CSL.Output.Formatters["capitalize-first"](state,label);}}}var labelPlaceholderPos=-1;if(label){labelPlaceholderPos=label.indexOf("%s");}var numStyling=CSL.Util.cloneToken(num.styling);numStyling.formatter=num.styling.formatter;numStyling.type=num.styling.type;numStyling.num=num.styling.num;numStyling.gender=num.styling.gender;if(labelPlaceholderPos>0&&labelPlaceholderPos<label.length-2){numStyling.strings.prefix+=label.slice(0,labelPlaceholderPos);numStyling.strings.suffix=label.slice(labelPlaceholderPos+2)+numStyling.strings.suffix;}else if(num.labelVisibility){if(!label){label=num.label;labelName=num.label;}if(labelPlaceholderPos>0){var prefixLabelStyling=new CSL.Token();prefixLabelStyling.decorations=labelDecorations;state.output.append(label.slice(0,labelPlaceholderPos),prefixLabelStyling);}else if(labelPlaceholderPos===label.length-2||labelPlaceholderPos===-1){// And add a trailing delimiter.
state.output.append(label+num.labelSuffix,"empty");}}CSL.UPDATE_GROUP_CONTEXT_CONDITION(state,masterStyling.strings.prefix,null,masterStyling,`${num.particle}${num.value}`);if(num.collapsible){var blob;if(num.value.match(/^[1-9][0-9]*$/)){blob=new CSL.NumericBlob(num.particle,parseInt(num.value,10),numStyling,itemID);}else{blob=new CSL.NumericBlob(num.particle,num.value,numStyling,itemID);}if("undefined"===typeof blob.gender){blob.gender=state.locale[state.opt.lang]["noun-genders"][varname];}state.output.append(blob,"literal");}else{state.output.append(num.particle+num.value,numStyling);}if(labelPlaceholderPos===0&&labelPlaceholderPos<label.length-2){// Only and always if this is the last entry of this label
if(lastLabelName===null){lastLabelName=labelName;}if(labelName!==lastLabelName||i===nums.length-1){var suffixLabelStyling=new CSL.Token();suffixLabelStyling.decorations=labelDecorations;state.output.append(label.slice(labelPlaceholderPos+2),suffixLabelStyling);}}lastLabelName=labelName;state.tmp.term_predecessor=true;}state.output.closeLevel();};/*global CSL: true */CSL.Util.PageRangeMangler={};CSL.Util.PageRangeMangler.getFunction=function(state,rangeType){var rangerex,pos,len,stringify,listify,expand,minimize,minimize_internal,chicago,lst,m,b,e,ret,begin,end,ret_func;var range_delimiter=state.getTerm(rangeType+"-range-delimiter");rangerex=/([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)\s*(?:\u2013|-)\s*([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)/;stringify=function(lst){len=lst.length;for(pos=1;pos<len;pos+=2){if("object"===typeof lst[pos]){lst[pos]=lst[pos].join("");}}var ret=lst.join("");ret=ret.replace(/([^\\])\-/g,"$1"+state.getTerm(rangeType+"-range-delimiter"));return ret;};listify=function(str){var m,lst,ret;// Normalized delimiter form, for use in regexps
var hyphens="\\s+\\-\\s+";// Normalize delimiters to hyphen wrapped in single spaces
var this_range_delimiter=range_delimiter==="-"?"":range_delimiter;var delimRex=new RegExp("([^\\\\])[-"+this_range_delimiter+"\\u2013]","g");str=str.replace(delimRex,"$1 - ").replace(/\s+-\s+/g," - ");// Workaround for Internet Explorer
//var rexm = new RegExp("((?:[0-9]*[a-zA-Z]+)?[0-9]+" + hyphens + "(?:[0-9]*[a-zA-Z]+)?[0-9]+)", "g");
//var rexlst = new RegExp("(?:[0-9]*[a-zA-Z]+)?[0-9]+" + hyphens + "(?:[0-9]*[a-zA-Z]+)?[0-9]+");
var rexm=new RegExp("((?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*"+hyphens+"(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*)","g");var rexlst=new RegExp("(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*"+hyphens+"(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*");m=str.match(rexm);lst=str.split(rexlst);if(lst.length===0){ret=m;}else{ret=[lst[0]];for(pos=1,len=lst.length;pos<len;pos+=1){ret.push(m[pos-1].replace(/\s*\-\s*/g,"-"));ret.push(lst[pos]);}}return ret;};expand=function(str){str=""+str;lst=listify(str);len=lst.length;for(pos=1;pos<len;pos+=2){m=lst[pos].match(rangerex);if(m){if(!m[3]||m[1]===m[3]){if(m[4].length<m[2].length){m[4]=m[2].slice(0,m[2].length-m[4].length)+m[4];}if(parseInt(m[2],10)<parseInt(m[4],10)){m[3]=range_delimiter+(m[1]?m[1]:"");lst[pos]=m.slice(1);}}}if("string"===typeof lst[pos]){lst[pos]=lst[pos].replace(/\-/g,range_delimiter);}}return lst;};minimize=function(lst,minchars,isyear){len=lst.length;for(var i=1,ilen=lst.length;i<ilen;i+=2){if("object"===typeof lst[i]){lst[i][3]=minimize_internal(lst[i][1],lst[i][3],minchars,isyear);if(lst[i][2].slice(1)===lst[i][0]){lst[i][2]=range_delimiter;}}}return stringify(lst);};minimize_internal=function(begin,end,minchars,isyear){if(!minchars){minchars=0;}b=(""+begin).split("");e=(""+end).split("");ret=e.slice();ret.reverse();if(b.length===e.length){for(var i=0,ilen=b.length;i<ilen;i+=1){if(b[i]===e[i]&&ret.length>minchars){ret.pop();}else{if(minchars&&isyear&&ret.length===3){var front=b.slice(0,i);front.reverse();ret=ret.concat(front);}break;}}}ret.reverse();return ret.join("");};chicago=function(lst){len=lst.length;for(pos=1;pos<len;pos+=2){if("object"===typeof lst[pos]){m=lst[pos];begin=parseInt(m[1],10);end=parseInt(m[3],10);if(begin>100&&begin%100&&parseInt(begin/100,10)===parseInt(end/100,10)){m[3]=""+end%100;}else if(begin>=10000){m[3]=""+end%1000;}}if(m[2].slice(1)===m[0]){m[2]=range_delimiter;}}return stringify(lst);};//
// The top-level option handlers.
//
var sniff=function(str,func,minchars,isyear){var ret;str=""+str;var lst=expand(str);var ret=func(lst,minchars,isyear);return ret;};if(!state.opt[rangeType+"-range-format"]){ret_func=function(str){//return str.replace("-", "\u2013", "g");
return sniff(str,stringify);};}else if(state.opt[rangeType+"-range-format"]==="expanded"){ret_func=function(str){return sniff(str,stringify);};}else if(state.opt[rangeType+"-range-format"]==="minimal"){ret_func=function(str){return sniff(str,minimize);};}else if(state.opt[rangeType+"-range-format"]==="minimal-two"){ret_func=function(str,isyear){return sniff(str,minimize,2,isyear);};}else if(state.opt[rangeType+"-range-format"]==="chicago"){ret_func=function(str){return sniff(str,chicago);};}return ret_func;};/*global CSL: true */ // Use a state machine
// Okay, good!
// Needs some tweaks:
// 1. First pass: quotes only
//    Special: Convert all sandwiched single-quote markup to apostrophe
// 2. Second pass: tags
CSL.Util.FlipFlopper=function(state){/**
     * INTERNAL
     */var _nestingState=[];var _nestingData={"<span class=\"nocase\">":{type:"nocase",opener:"<span class=\"nocase\">",closer:"</span>",attr:null,outer:null,flipflop:null},"<span class=\"nodecor\">":{type:"nodecor",opener:"<span class=\"nodecor\">",closer:"</span>",attr:"@class",outer:"nodecor",flipflop:{"nodecor":"nodecor"}},"<span style=\"font-variant:small-caps;\">":{type:"tag",opener:"<span style=\"font-variant:small-caps;\">",closer:"</span>",attr:"@font-variant",outer:"small-caps",flipflop:{"small-caps":"normal","normal":"small-caps"}},"<sc>":{type:"tag",opener:"<sc>",closer:"</sc>",attr:"@font-variant",outer:"small-caps",flipflop:{"small-caps":"normal","normal":"small-caps"}},"<i>":{type:"tag",opener:"<i>",closer:"</i>",attr:"@font-style",outer:"italic",flipflop:{"italic":"normal","normal":"italic"}},"<b>":{type:"tag",opener:"<b>",closer:"</b>",attr:"@font-weight",outer:"bold",flipflop:{"bold":"normal","normal":"bold"}},"<sup>":{type:"tag",opener:"<sup>",closer:"</sup>",attr:"@vertical-align",outer:"sup",flipflop:{"sub":"sup","sup":"sup"}},"<sub>":{type:"tag",opener:"<sub>",closer:"</sub>",attr:"@vertical-align",outer:"sub",flipflop:{"sup":"sub","sub":"sub"}}," \"":{type:"quote",opener:" \"",closer:"\"",attr:"@quotes",outer:"true",flipflop:{"true":"inner","inner":"true","false":"true"}}," \'":{type:"quote",opener:" \'",closer:"\'",attr:"@quotes",outer:"inner",flipflop:{"true":"inner","inner":"true","false":"true"}}};_nestingData["(\""]=_nestingData[" \""];_nestingData["(\'"]=_nestingData[" \'"];var localeOpenQuote=state.getTerm("open-quote");var localeCloseQuote=state.getTerm("close-quote");var localeOpenInnerQuote=state.getTerm("open-inner-quote");var localeCloseInnerQuote=state.getTerm("close-inner-quote");// If locale uses straight quotes, do not register them. All will be well.
// Otherwise, clone straight-quote data, and adjust.
if(localeOpenQuote&&localeCloseQuote&&[" \""," \'","\"","\'"].indexOf(localeOpenQuote)===-1){_nestingData[localeOpenQuote]=JSON.parse(JSON.stringify(_nestingData[" \""]));_nestingData[localeOpenQuote].opener=localeOpenQuote;_nestingData[localeOpenQuote].closer=localeCloseQuote;}if(localeOpenInnerQuote&&localeCloseInnerQuote&&[" \""," \'","\"","\'"].indexOf(localeOpenInnerQuote)===-1){_nestingData[localeOpenInnerQuote]=JSON.parse(JSON.stringify(_nestingData[" \'"]));_nestingData[localeOpenInnerQuote].opener=localeOpenInnerQuote;_nestingData[localeOpenInnerQuote].closer=localeCloseInnerQuote;}function _setOuterQuoteForm(quot){var flip={" \'":" \""," \"":" \'","(\"":"(\'","(\'":"(\""};_nestingData[quot].outer="true";_nestingData[flip[quot]].outer="inner";}function _getNestingOpenerParams(opener){var openers=[];var keys=Object.keys(_nestingData);for(var i=0,l=keys.length;i<l;i++){var key=keys[i];if(_nestingData[opener].type!=="quote"||!_nestingData[opener]){openers.push(key);}}var ret=_nestingData[opener];ret.opener=new RegExp("^(?:"+openers.map(function(str){return str.replace("(","\\(");}).join("|")+")");return ret;}var _nestingParams=function(){var ret={};var keys=Object.keys(_nestingData);for(var i=0,l=keys.length;i<l;i++){var key=keys[i];ret[key]=_getNestingOpenerParams(key);}return ret;}();var _tagRex=function(){var openers=[];var closers=[];var vals={};for(var opener in _nestingParams){openers.push(opener);vals[_nestingParams[opener].closer]=true;}var keys=Object.keys(vals);for(var i=0,l=keys.length;i<l;i++){var closer=keys[i];closers.push(closer);}var all=openers.concat(closers).map(function(str){return str.replace("(","\\(");}).join("|");return{matchAll:new RegExp("((?:"+all+"))","g"),splitAll:new RegExp("(?:"+all+")","g"),open:new RegExp("(^(?:"+openers.map(function(str){return str.replace("(","\\(");}).join("|")+")$)"),close:new RegExp("(^(?:"+closers.join("|")+")$)")};}();function _tryOpen(tag,pos){var params=_nestingState[_nestingState.length-1];if(!params||tag.match(params.opener)){_nestingState.push({type:_nestingParams[tag].type,opener:_nestingParams[tag].opener,closer:_nestingParams[tag].closer,pos:pos});return false;}else{_nestingState.pop();_nestingState.push({type:_nestingParams[tag].type,opener:_nestingParams[tag].opener,closer:_nestingParams[tag].closer,pos:pos});return{fixtag:params.pos};}}function _tryClose(tag,pos){var params=_nestingState[_nestingState.length-1];if(params&&tag===params.closer){_nestingState.pop();if(params.type==="nocase"){return{nocase:{open:params.pos,close:pos}};}else{return false;}}else{if(params){return{fixtag:params.pos};}else{return{fixtag:pos};}}}function _pushNestingState(tag,pos){if(tag.match(_tagRex.open)){return _tryOpen(tag,pos);}else{return _tryClose(tag,pos);}}function _doppelString(str){var forcedSpaces=[];// Normalize markup
str=str.replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?\"[^>]*(>)/g,"$1 $2$3;\"$4");str=str.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g,"$1 $2$3");var match=str.match(_tagRex.matchAll);if(!match){return{tags:[],strings:[str],forcedSpaces:[]};}var split=str.split(_tagRex.splitAll);for(var i=0,ilen=match.length-1;i<ilen;i++){if(_nestingData[match[i]]){if(split[i+1]===""&&["\"","'"].indexOf(match[i+1])>-1){match[i+1]=" "+match[i+1];forcedSpaces.push(true);}else{forcedSpaces.push(false);}}}return{tags:match,strings:split,forcedSpaces:forcedSpaces};}var TagReg=function(blob){var _stack=[];this.set=function(tag){var attr=_nestingData[tag].attr;var decor=null;for(var i=_stack.length-1;i>-1;i--){var _decor=_stack[i];if(_decor[0]===attr){decor=_decor;break;}}if(!decor){var allTheDecor=[state[state.tmp.area].opt.layout_decorations].concat(blob.alldecor);outer:for(var i=allTheDecor.length-1;i>-1;i--){var decorset=allTheDecor[i];if(!decorset){continue;}for(var j=decorset.length-1;j>-1;j--){var _decor=decorset[j];if(_decor[0]===attr){decor=_decor;break outer;}}}}if(!decor){decor=[attr,_nestingData[tag].outer];}else{decor=[attr,_nestingData[tag].flipflop[decor[1]]];}_stack.push(decor);};this.pair=function(){return _stack[_stack.length-1];};this.pop=function(){_stack.pop();};};function _apostropheForce(tag,str){if(tag==="\'"){if(str&&str.match(/^[^\,\.\?\:\;\ ]/)){return"\u2019";}}else if(tag===" \'"&&str&&str.match(/^[\ ]/)){return" \u2019";}return false;}function _undoppelToQueue(blob,doppel,leadingSpace){var firstString=true;var tagReg=new TagReg(blob);blob.blobs=[];function Stack(blob){this.stack=[blob];this.latest=blob;this.addStyling=function(str,decor){if(firstString){if(str.slice(0,1)===" "){str=str.slice(1);}if(str.slice(0,1)===" "){str=str.slice(1);}firstString=false;}this.latest=this.stack[this.stack.length-1];if(decor){if("string"===typeof this.latest.blobs){var child=new CSL.Blob();child.blobs=this.latest.blobs;child.alldecor=this.latest.alldecor.slice();this.latest.blobs=[child];}var tok=new CSL.Token();var newblob=new CSL.Blob(null,tok);newblob.alldecor=this.latest.alldecor.slice();// AHA! Bad naming. There is _decorset from the list, and
// there WAS decorset that we are building. Dumb. Fix the
// names and fix it up.
if(decor[0]==="@class"&&decor[1]==="nodecor"){var newdecorset=[];var seen={};var allTheDecor=[state[state.tmp.area].opt.layout_decorations].concat(newblob.alldecor);for(var i=allTheDecor.length-1;i>-1;i--){var _decorset=allTheDecor[i];if(!_decorset){continue;}for(var j=_decorset.length-1;j>-1;j--){var _olddecor=_decorset[j];if(["@font-weight","@font-style","@font-variant"].indexOf(_olddecor[0])>-1&&!seen[_olddecor[0]]){if(decor[1]!=="normal"){newblob.decorations.push([_olddecor[0],"normal"]);newdecorset.push([_olddecor[0],"normal"]);}seen[_olddecor[0]]=true;}}}newblob.alldecor.push(newdecorset);}else{newblob.decorations.push(decor);newblob.alldecor.push([decor]);}this.latest.blobs.push(newblob);this.stack.push(newblob);this.latest=newblob;if(str){var tok=new CSL.Token();var newblob=new CSL.Blob(null,tok);newblob.blobs=str;newblob.alldecor=this.latest.alldecor.slice();this.latest.blobs.push(newblob);}}else{if(str){var child=new CSL.Blob();child.blobs=str;child.alldecor=this.latest.alldecor.slice();this.latest.blobs.push(child);}}};this.popStyling=function(){this.stack.pop();};}var stack=new Stack(blob);if(doppel.strings.length){var str=doppel.strings[0];if(leadingSpace){str=" "+str;}stack.addStyling(str);}for(var i=0,ilen=doppel.tags.length;i<ilen;i++){var tag=doppel.tags[i];var str=doppel.strings[i+1];if(tag.match(_tagRex.open)){tagReg.set(tag);stack.addStyling(str,tagReg.pair());}else{tagReg.pop();stack.popStyling();stack.addStyling(str);}}}/**
     * PUBLIC
     */this.processTags=function(blob){var str=blob.blobs;var leadingSpace=false;if(str.slice(0,1)===" "&&!str.match(/^\s+[\'\"]/)){leadingSpace=true;}var rex=new RegExp("("+CSL.ROMANESQUE_REGEXP.source+")\u2019("+CSL.ROMANESQUE_REGEXP.source+")","g");var str=" "+str.replace(rex,"$1\'$2");var doppel=_doppelString(str);if(doppel.tags.length===0){return;}var quoteFormSeen=false;for(var i=0,ilen=doppel.tags.length;i<ilen;i++){var tag=doppel.tags[i];var str=doppel.strings[i+1];var apostrophe=_apostropheForce(tag,str);if(apostrophe){doppel.strings[i+1]=apostrophe+doppel.strings[i+1];doppel.tags[i]="";}else{var tagInfo;while(true){tagInfo=_pushNestingState(tag,i);if(tagInfo){if(Object.keys(tagInfo).indexOf("fixtag")>-1){if(tag.match(_tagRex.close)&&tag==="\'"){doppel.strings[i+1]="\u2019"+doppel.strings[i+1];doppel.tags[i]="";}else{var failedTag=doppel.tags[tagInfo.fixtag];if(doppel.forcedSpaces[tagInfo.fixtag-1]){failedTag=failedTag.slice(1);}doppel.strings[tagInfo.fixtag+1]=failedTag+doppel.strings[tagInfo.fixtag+1];doppel.tags[tagInfo.fixtag]="";}if(_nestingState.length>0){if(tag!=="\'"){_nestingState.pop();}else{break;}}else{break;}}else if(tagInfo.nocase){doppel.tags[tagInfo.nocase.open]="";doppel.tags[tagInfo.nocase.close]="";break;}else{break;}}else{break;}}if(tagInfo&&(tagInfo.fixtag||tagInfo.fixtag===0)){doppel.strings[i+1]=doppel.tags[i]+doppel.strings[i+1];doppel.tags[i]="";}}}// Stray tags are neutralized here
for(var i=_nestingState.length-1;i>-1;i--){var tagPos=_nestingState[i].pos;var tag=doppel.tags[tagPos];if(tag===" \'"||tag==="\'"){doppel.strings[tagPos+1]=" \u2019"+doppel.strings[tagPos+1];}else{doppel.strings[tagPos+1]=doppel.tags[tagPos]+doppel.strings[tagPos+1];}doppel.tags[tagPos]="";_nestingState.pop();}for(var i=doppel.tags.length-1;i>-1;i--){if(!doppel.tags[i]){doppel.tags=doppel.tags.slice(0,i).concat(doppel.tags.slice(i+1));doppel.strings[i]=doppel.strings[i]+doppel.strings[i+1];doppel.strings=doppel.strings.slice(0,i+1).concat(doppel.strings.slice(i+2));}}// Sniff initial (outer) quote form (single or double) and configure parser
// Also add leading spaces.
for(var i=0,ilen=doppel.tags.length;i<ilen;i++){var tag=doppel.tags[i];var forcedSpace=doppel.forcedSpaces[i-1];if([" \""," \'","(\"","(\'"].indexOf(tag)>-1){if(!quoteFormSeen){_setOuterQuoteForm(tag);quoteFormSeen=true;}if(!forcedSpace){doppel.strings[i]+=tag.slice(0,1);}}}//print(JSON.stringify(doppel, null, 2))
//print(_undoppelString(doppel));
_undoppelToQueue(blob,doppel,leadingSpace);};};/*global CSL: true */CSL.Output.Formatters=function(){var rexStr="(?:\u2018|\u2019|\u201C|\u201D| \"| \'|\"|\'|[-\u2013\u2014\/.,;?!:]|\\[|\\]|\\(|\\)|<span style=\"font-variant: small-caps;\">|<span class=\"no(?:case|decor)\">|<\/span>|<\/?(?:i|sc|b|sub|sup)>)";var tagDoppel=new CSL.Doppeler(rexStr,function(str){return str.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g,"$1 $2$3").replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?(\")[^>]*(>)/g,"$1 $2 $3;$4$5");});var rexNameStr="(?:[-\\s]*<\\/*(?:span\s+class=\"no(?:case|decor)\"|i|sc|b|sub|sup)>[-\\s]*|[-\\s]+)";var nameDoppel=new CSL.Doppeler(rexNameStr);var wordDoppel=new CSL.Doppeler("(?:[\u0020\u00A0\u2000-\u200B\u205F\u3000]+)");/**
     * INTERNAL
     */var _tagParams={"<span style=\"font-variant: small-caps;\">":"</span>","<span class=\"nocase\">":"</span>","<span class=\"nodecor\">":"</span>","<sc>":"</sc>","<sub>":"</sub>","<sup>":"</sup>"};function _capitalise(word){// Weird stuff is (.) transpiled with regexpu
//   https://github.com/mathiasbynens/regexpu
var m=word.match(/(^\s*)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))(.*)/);// Do not uppercase lone Greek letters
// (No case transforms in Greek citations, but chars used in titles to science papers)
if(m&&!(m[2].match(/^[\u0370-\u03FF]$/)&&!m[3])){return m[1]+CSL.toLocaleUpperCase.call(this,m[2])+m[3];}return word;}function _textcaseEngine(config,string){if(!string){return"";}config.doppel=tagDoppel.split(string);var quoteParams={" \"":{opener:" \'",closer:"\""}," \'":{opener:" \"",closer:"\'"},"\u2018":{opener:"\u2018",closer:"\u2019"},"\u201C":{opener:"\u201C",closer:"\u201D"}};function tryOpen(tag,pos){if(config.quoteState.length===0||tag===config.quoteState[config.quoteState.length-1].opener){config.quoteState.push({opener:quoteParams[tag].opener,closer:quoteParams[tag].closer,pos:pos});return false;}else{var prevPos=config.quoteState[config.quoteState.length-1].pos;config.quoteState.pop();config.quoteState.push({opener:quoteParams[tag].opener,closer:quoteParams[tag].closer,positions:pos});return prevPos;}}function tryClose(tag,pos){if(config.quoteState.length>0&&tag===config.quoteState[config.quoteState.length-1].closer){config.quoteState.pop();}else{return pos;}}function pushQuoteState(tag,pos){var isOpener=["\u201C","\u2018"," \""," \'"].indexOf(tag)>-1?true:false;if(isOpener){return tryOpen(tag,pos);}else{return tryClose(tag,pos);}}function quoteFix(tag,positions){var m=tag.match(/(^(?:\u2018|\u2019|\u201C|\u201D|\"|\')|(?: \"| \')$)/);if(m){return pushQuoteState(m[1],positions);}}// Run state machine
if(config.doppel.strings.length&&config.doppel.strings[0].trim()){config.doppel.strings[0]=config.capitaliseWords(config.doppel.strings[0],0,config.doppel.tags[0]);}for(var i=0,ilen=config.doppel.tags.length;i<ilen;i++){var tag=config.doppel.tags[i];var str=config.doppel.strings[i+1];if(config.tagState!==null){// Evaluate tag state for current string
if(_tagParams[tag]){config.tagState.push(_tagParams[tag]);}else if(config.tagState.length&&tag===config.tagState[config.tagState.length-1]){config.tagState.pop();}}if(config.afterPunct!==null){// Evaluate punctuation state of current string
if(tag.match(/[\!\?\:]$/)){config.afterPunct=true;}}// Process if outside tag scope, else noop for upper-casing
if(config.tagState.length===0){config.doppel.strings[i+1]=config.capitaliseWords(str,i+1,config.doppel,config.doppel.tags[i+1]);}else if(config.doppel.strings[i+1].trim()){config.lastWordPos=null;}if(config.quoteState!==null){// Evaluate quote state of current string and fix chars that have flown
var quotePos=quoteFix(tag,i);if(quotePos||quotePos===0){var origChar=config.doppel.origStrings[quotePos+1].slice(0,1);config.doppel.strings[quotePos+1]=origChar+config.doppel.strings[quotePos+1].slice(1);config.lastWordPos=null;}}// If there was a printable string, unset first-word and after-punctuation
if(config.isFirst){if(str.trim()){config.isFirst=false;}}if(config.afterPunct){if(str.trim()){config.afterPunct=false;}}}if(config.quoteState){for(var i=0,ilen=config.quoteState.length;i<ilen;i++){var quotePos=config.quoteState[i].pos;// Test for quotePos avoids a crashing error:
//   https://github.com/citation-style-language/test-suite/blob/master/processor-tests/humans/flipflop_OrphanQuote.txt
if(typeof quotePos!=='undefined'){var origChar=config.doppel.origStrings[quotePos+1].slice(0,1);config.doppel.strings[quotePos+1]=origChar+config.doppel.strings[quotePos+1].slice(1);}}}// Specially capitalize the last word if necessary (invert stop-word list)
if(config.lastWordPos){var lastWords=wordDoppel.split(config.doppel.strings[config.lastWordPos.strings]);var lastWord=lastWords.strings[config.lastWordPos.words];if(lastWord.length>1&&CSL.toLocaleLowerCase.call(this,lastWord).match(config.skipWordsRex)){lastWord=_capitalise.call(this,lastWord);lastWords.strings[config.lastWordPos.words]=lastWord;}config.doppel.strings[config.lastWordPos.strings]=wordDoppel.join(lastWords);}// Recombine the string
return tagDoppel.join(config.doppel);}/**
     * PUBLIC
     */ /**
     * A noop that just delivers the string.
     */function passthrough(state,str){return str;}/**
     * Force all letters in the string to lowercase, skipping nocase spans
     */function lowercase(state,string){var config={quoteState:null,capitaliseWords:function(str){var words=str.split(" ");for(var i=0,ilen=words.length;i<ilen;i++){var word=words[i];if(word){words[i]=CSL.toLocaleLowerCase.call(state,word);}}return words.join(" ");},skipWordsRex:null,tagState:[],afterPunct:null,isFirst:null};return _textcaseEngine.call(state,config,string);}/**
     * Force all letters in the string to uppercase.
     */function uppercase(state,string){var config={quoteState:null,capitaliseWords:function(str){var words=str.split(" ");for(var i=0,ilen=words.length;i<ilen;i++){var word=words[i];if(word){// Okay.
// So we need to pick up an array of locales from state.tmp.
// This function is invoked in the context of queue.js, so
// the item is not available here. Three levels to be included
// in the array:
// 1. Field language tag, if any
// 2. Item language tag, if any
// 3. Value of state.opt.lang
words[i]=CSL.toLocaleUpperCase.call(state,word);}}return words.join(" ");},skipWordsRex:null,tagState:[],afterPunct:null,isFirst:null};return _textcaseEngine.call(state,config,string);}/**
     * Similar to <b>capitalize_first</b>, but force the
     * subsequent characters to lowercase.
     */function sentence(state,string){var config={quoteState:[],capitaliseWords:function(str){var words=str.split(" ");for(var i=0,ilen=words.length;i<ilen;i++){var word=words[i];if(word){if(config.isFirst){words[i]=_capitalise.call(state,word);config.isFirst=false;}else{words[i]=CSL.toLocaleLowerCase.call(state,word);}}}return words.join(" ");},skipWordsRex:null,tagState:[],afterPunct:null,isFirst:true};return _textcaseEngine.call(state,config,string);}function title(state,string){var config={quoteState:[],capitaliseWords:function(str,i,followingTag){if(str.trim()){var words=str.split(/[ \u00A0]+/);var wordle=wordDoppel.split(str);var words=wordle.strings;for(var j=0,jlen=words.length;j<jlen;j++){var word=words[j];if(!word){continue;}if(word.length>1&&!CSL.toLocaleLowerCase.call(state,word).match(config.skipWordsRex)){// Capitalize every word that is not a stop-word
words[j]=_capitalise.call(state,words[j]);}else if(j===words.length-1&&followingTag==="-"){words[j]=_capitalise.call(state,words[j]);}else if(config.isFirst){// Capitalize first word, even if a stop-word
words[j]=_capitalise.call(state,words[j]);}else if(config.afterPunct){// Capitalize after punctuation
words[j]=_capitalise.call(state,words[j]);}config.afterPunct=false;config.isFirst=false;config.lastWordPos={strings:i,words:j};}str=wordDoppel.join(wordle);}return str;},skipWordsRex:state.locale[state.opt.lang].opts["skip-words-regexp"],tagState:[],afterPunct:false,isFirst:true};return _textcaseEngine.call(state,config,string);}/**
     * Force capitalization of the first letter in the string, leave
     * the rest of the characters untouched.
     */function capitalizeFirst(state,string){var config={quoteState:[],capitaliseWords:function(str){var words=str.split(" ");for(var i=0,ilen=words.length;i<ilen;i++){var word=words[i];if(word){if(config.isFirst){words[i]=_capitalise.call(state,word);config.isFirst=false;break;}}}return words.join(" ");},skipWordsRex:null,tagState:[],afterPunct:null,isFirst:true};return _textcaseEngine.call(state,config,string);}/**
     * Force the first letter of each space-delimited
     * word in the string to uppercase, and leave the remainder
     * of the string untouched.  Single characters are forced
     * to uppercase.
     */function capitalizeAll(state,string){var config={quoteState:[],capitaliseWords:function(str){var words=str.split(" ");for(var i=0,ilen=words.length;i<ilen;i++){var word=words[i];if(word){words[i]=_capitalise.call(state,word);}}return words.join(" ");},skipWordsRex:null,tagState:[],afterPunct:null,isFirst:null};return _textcaseEngine.call(state,config,string);}return{nameDoppel:nameDoppel,passthrough:passthrough,lowercase:lowercase,uppercase:uppercase,sentence:sentence,title:title,"capitalize-first":capitalizeFirst,"capitalize-all":capitalizeAll};}();/*global CSL: true */ /**
 * Output specifications.
 * @class
 */CSL.Output.Formats=function(){};/**
 * HTML output format specification.
 * <p>The headline says it all.  The source code for this
 * object can be used as a template for producing other
 * output modes.</p>
 */CSL.Output.Formats.prototype.html={//
// text_escape: Format-specific function for escaping text destined
// for output.  Takes the text to be escaped as sole argument.  Function
// will be run only once across each portion of text to be escaped, it
// need not be idempotent.
//
"text_escape":function(text){// Numeric entities, in case the output is processed as
// xml in an environment in which HTML named entities are
// not declared.
if(!text){text="";}return text.replace(/&/g,"&#38;").replace(/</g,"&#60;").replace(/>/g,"&#62;").replace(/\s\s/g,"\u00A0 ").replace(CSL.SUPERSCRIPTS_REGEXP,function(aChar){// return "&#60;sup&#62;" + CSL.SUPERSCRIPTS[aChar] + "&#60;/sup&#62;";
return"<sup>"+CSL.SUPERSCRIPTS[aChar]+"</sup>";});},"bibstart":"<div class=\"csl-bib-body\">\n","bibend":"</div>","@font-style/italic":"<i>%%STRING%%</i>","@font-style/oblique":"<em>%%STRING%%</em>","@font-style/normal":"<span style=\"font-style:normal;\">%%STRING%%</span>","@font-variant/small-caps":"<span style=\"font-variant:small-caps;\">%%STRING%%</span>","@passthrough/true":CSL.Output.Formatters.passthrough,"@font-variant/normal":"<span style=\"font-variant:normal;\">%%STRING%%</span>","@font-weight/bold":"<b>%%STRING%%</b>","@font-weight/normal":"<span style=\"font-weight:normal;\">%%STRING%%</span>","@font-weight/light":false,"@text-decoration/none":"<span style=\"text-decoration:none;\">%%STRING%%</span>","@text-decoration/underline":"<span style=\"text-decoration:underline;\">%%STRING%%</span>","@vertical-align/sup":"<sup>%%STRING%%</sup>","@vertical-align/sub":"<sub>%%STRING%%</sub>","@vertical-align/baseline":"<span style=\"baseline\">%%STRING%%</span>","@strip-periods/true":CSL.Output.Formatters.passthrough,"@strip-periods/false":CSL.Output.Formatters.passthrough,"@quotes/true":function(state,str){if("undefined"===typeof str){return state.getTerm("open-quote");}return state.getTerm("open-quote")+str+state.getTerm("close-quote");},"@quotes/inner":function(state,str){if("undefined"===typeof str){//
// Mostly right by being wrong (for apostrophes)
//
return"\u2019";}return state.getTerm("open-inner-quote")+str+state.getTerm("close-inner-quote");},"@quotes/false":false,//"@bibliography/body": function (state,str){
//    return "<div class=\"csl-bib-body\">\n"+str+"</div>";
//},
"@cite/entry":function(state,str){return state.sys.wrapCitationEntry(str,this.item_id,this.locator_txt,this.suffix_txt);},"@bibliography/entry":function(state,str){// Test for this.item_id to add decorations to
// bibliography output of individual entries.
//
// Full item content can be obtained from
// state.registry.registry[id].ref, using
// CSL variable keys.
//
// Example:
//
//   print(state.registry.registry[this.item_id].ref["title"]);
//
// At present, for parallel citations, only the
// id of the master item is supplied on this.item_id.
var insert="";if(state.sys.embedBibliographyEntry){insert=state.sys.embedBibliographyEntry(this.item_id)+"\n";}return"  <div class=\"csl-entry\">"+str+"</div>\n"+insert;},"@display/block":function(state,str){return"\n\n    <div class=\"csl-block\">"+str+"</div>\n";},"@display/left-margin":function(state,str){return"\n    <div class=\"csl-left-margin\">"+str+"</div>";},"@display/right-inline":function(state,str){return"<div class=\"csl-right-inline\">"+str+"</div>\n  ";},"@display/indent":function(state,str){return"<div class=\"csl-indent\">"+str+"</div>\n  ";},"@showid/true":function(state,str,cslid){if(!state.tmp.just_looking&&!state.tmp.suppress_decorations){if(cslid){return"<span class=\""+state.opt.nodenames[cslid]+"\" cslid=\""+cslid+"\">"+str+"</span>";}else if(this.params&&"string"===typeof str){var prePunct="";if(str){var m=str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);prePunct=m[1];str=m[2];}var postPunct="";if(str&&CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1))>-1){postPunct=str.slice(-1);str=str.slice(0,-1);}return state.sys.variableWrapper(this.params,prePunct,str,postPunct);}else{return str;}}else{return str;}},"@URL/true":function(state,str){return"<a href=\""+str+"\">"+str+"</a>";},"@DOI/true":function(state,str){var doiurl=str;if(!str.match(/^https?:\/\//)){doiurl="https://doi.org/"+str;}return"<a href=\""+doiurl+"\">"+str+"</a>";}};/**
 * Plain text output specification.
 *
 * (Code contributed by Simon Kornblith, Center for History and New Media,
 * George Mason University.)
 */CSL.Output.Formats.prototype.text={//
// text_escape: Format-specific function for escaping text destined
// for output.  Takes the text to be escaped as sole argument.  Function
// will be run only once across each portion of text to be escaped, it
// need not be idempotent.
//
"text_escape":function(text){if(!text){text="";}return text;},"bibstart":"","bibend":"","@font-style/italic":false,"@font-style/oblique":false,"@font-style/normal":false,"@font-variant/small-caps":false,"@passthrough/true":CSL.Output.Formatters.passthrough,"@font-variant/normal":false,"@font-weight/bold":false,"@font-weight/normal":false,"@font-weight/light":false,"@text-decoration/none":false,"@text-decoration/underline":false,"@vertical-align/baseline":false,"@vertical-align/sup":false,"@vertical-align/sub":false,"@strip-periods/true":CSL.Output.Formatters.passthrough,"@strip-periods/false":CSL.Output.Formatters.passthrough,"@quotes/true":function(state,str){if("undefined"===typeof str){return state.getTerm("open-quote");}return state.getTerm("open-quote")+str+state.getTerm("close-quote");},"@quotes/inner":function(state,str){if("undefined"===typeof str){//
// Mostly right by being wrong (for apostrophes)
//
return"\u2019";}return state.getTerm("open-inner-quote")+str+state.getTerm("close-inner-quote");},"@quotes/false":false,//"@bibliography/body": function (state,str){
//    return "<div class=\"csl-bib-body\">\n"+str+"</div>";
//},
"@cite/entry":function(state,str){return state.sys.wrapCitationEntry(str,this.item_id,this.locator_txt,this.suffix_txt);},"@bibliography/entry":function(state,str){return str+"\n";},"@display/block":function(state,str){return"\n"+str;},"@display/left-margin":function(state,str){return str;},"@display/right-inline":function(state,str){return str;},"@display/indent":function(state,str){return"\n    "+str;},"@showid/true":function(state,str){return str;},"@URL/true":function(state,str){return str;},"@DOI/true":function(state,str){return str;}};/**
 * Plain text output specification.
 *
 * (Code contributed by Simon Kornblith, Center for History and New Media,
 * George Mason University.)
 */CSL.Output.Formats.prototype.rtf={//
// text_escape: Format-specific function for escaping text destined
// for output.  Takes the text to be escaped as sole argument.  Function
// will be run only once across each portion of text to be escaped, it
// need not be idempotent.
//
"text_escape":function(text){if(!text){text="";}return text.replace(/([\\{}])/g,"\\$1").replace(CSL.SUPERSCRIPTS_REGEXP,function(aChar){return"\\super "+CSL.SUPERSCRIPTS[aChar]+"\\nosupersub{}";}).replace(/[\u007F-\uFFFF]/g,function(aChar){return"\\uc0\\u"+aChar.charCodeAt(0).toString()+"{}";}).split("\t").join("\\tab{}");},"@passthrough/true":CSL.Output.Formatters.passthrough,"@font-style/italic":"{\\i{}%%STRING%%}","@font-style/normal":"{\\i0{}%%STRING%%}","@font-style/oblique":"{\\i{}%%STRING%%}","@font-variant/small-caps":"{\\scaps %%STRING%%}","@font-variant/normal":"{\\scaps0{}%%STRING%%}","@font-weight/bold":"{\\b{}%%STRING%%}","@font-weight/normal":"{\\b0{}%%STRING%%}","@font-weight/light":false,"@text-decoration/none":false,"@text-decoration/underline":"{\\ul{}%%STRING%%}","@vertical-align/baseline":false,"@vertical-align/sup":"\\super %%STRING%%\\nosupersub{}","@vertical-align/sub":"\\sub %%STRING%%\\nosupersub{}","@strip-periods/true":CSL.Output.Formatters.passthrough,"@strip-periods/false":CSL.Output.Formatters.passthrough,"@quotes/true":function(state,str){if("undefined"===typeof str){return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote"));}return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote"))+str+CSL.Output.Formats.rtf.text_escape(state.getTerm("close-quote"));},"@quotes/inner":function(state,str){if("undefined"===typeof str){return CSL.Output.Formats.rtf.text_escape("\u2019");}return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-inner-quote"))+str+CSL.Output.Formats.rtf.text_escape(state.getTerm("close-inner-quote"));},"@quotes/false":false,"bibstart":"{\\rtf ","bibend":"}","@display/block":"\\line{}%%STRING%%\\line\r\n","@cite/entry":function(state,str){// If wrapCitationEntry does not exist, cite/entry 
// is not applied.
return state.sys.wrapCitationEntry(str,this.item_id,this.locator_txt,this.suffix_txt);},"@bibliography/entry":function(state,str){return str;},"@display/left-margin":function(state,str){return str+"\\tab ";},"@display/right-inline":function(state,str){return str+"\r\n";},"@display/indent":function(state,str){return"\n\\tab "+str+"\\line\r\n";},"@showid/true":function(state,str){if(!state.tmp.just_looking&&!state.tmp.suppress_decorations){var prePunct="";if(str){var m=str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);prePunct=m[1];str=m[2];}var postPunct="";if(str&&CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1))>-1){postPunct=str.slice(-1);str=str.slice(0,-1);}return state.sys.variableWrapper(this.params,prePunct,str,postPunct);}else{return str;}},"@URL/true":function(state,str){return str;},"@DOI/true":function(state,str){return str;}};/*

    This does not seem to work in Zotero plugins. For some reason the scope of the link does not
    close when interpreted by the LibreOffice. Perhaps this creates a field within a field,
    and that is not allowed?

    "@URL/true": function (state, str) {
        return "\\field{\\*\\fldinst{HYPERLINK \"" + str + "\"}}{\\fldrslt{"+ str +"}}";
    },
    "@DOI/true": function (state, str) {
        return "\\field{\\*\\fldinst{HYPERLINK \"https://doi.org/" + str + "\"}}{\\fldrslt{"+ str +"}}";
    }
*/ /**
 * AsciiDoc output specification.
 *
 * See http://asciidoc.org/ or https://asciidoctor.org/
 */CSL.Output.Formats.prototype.asciidoc={"text_escape":function(text){if(!text){text="";}return text.replace("*","pass:[*]","g").replace("_","pass:[_]","g").replace("#","pass:[#]","g").replace("^","pass:[^]","g").replace("~","pass:[~]","g").replace("[[","pass:[[[]","g").replace("  ","&#160; ","g").replace(CSL.SUPERSCRIPTS_REGEXP,function(aChar){return"^"+CSL.SUPERSCRIPTS[aChar]+"^";});},"bibstart":"","bibend":"","@passthrough/true":CSL.Output.Formatters.passthrough,"@font-style/italic":"__%%STRING%%__","@font-style/oblique":"__%%STRING%%__","@font-style/normal":false,"@font-variant/small-caps":"[small-caps]#%%STRING%%#","@font-variant/normal":false,"@font-weight/bold":"**%%STRING%%**","@font-weight/normal":false,"@font-weight/light":false,"@text-decoration/none":false,"@text-decoration/underline":"[underline]##%%STRING%%##","@vertical-align/sup":"^^%%STRING%%^^","@vertical-align/sub":"~~%%STRING%%~~","@vertical-align/baseline":false,"@strip-periods/true":CSL.Output.Formatters.passthrough,"@strip-periods/false":CSL.Output.Formatters.passthrough,"@quotes/true":function(state,str){if("undefined"===typeof str){return"``";}return"``"+str+"''";},"@quotes/inner":function(state,str){if("undefined"===typeof str){return"`";}return"`"+str+"'";},"@quotes/false":false,"@cite/entry":function(state,str){// if wrapCitationEntry does not exist, cite/entry is not applied
return state.sys.wrapCitationEntry(str,this.item_id,this.locator_txt,this.suffix_txt);},"@bibliography/entry":function(state,str){return str+"\n";},"@display/block":function(state,str){return str;},"@display/left-margin":function(state,str){return str;},"@display/right-inline":function(state,str){return" "+str;},"@display/indent":function(state,str){return" "+str;},"@showid/true":function(state,str){if(!state.tmp.just_looking&&!state.tmp.suppress_decorations&&this.params&&"string"===typeof str){var prePunct="";if(str){var m=str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);prePunct=m[1];str=m[2];}var postPunct="";if(str&&CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1))>-1){postPunct=str.slice(-1);str=str.slice(0,-1);}return state.sys.variableWrapper(this.params,prePunct,str,postPunct);}else{return str;}},"@URL/true":function(state,str){// AsciiDoc renders URLs automatically as links
return str;},"@DOI/true":function(state,str){var doiurl=str;if(!str.match(/^https?:\/\//)){doiurl="https://doi.org/"+str;}return doiurl+"["+str+"]";}};/**
 * Output specification for XSL-FO (Extensible Stylesheet
 * Language - Formatting Objects)
 *
 * See https://www.w3.org/TR/xsl11/#fo-section
 */CSL.Output.Formats.prototype.fo={"text_escape":function(text){if(!text){text="";}return text.replace(/&/g,"&#38;").replace(/</g,"&#60;").replace(/>/g,"&#62;").replace("  ","&#160; ","g").replace(CSL.SUPERSCRIPTS_REGEXP,function(aChar){return"<fo:inline vertical-align=\"super\">"+CSL.SUPERSCRIPTS[aChar]+"</fo:inline>";});},"bibstart":"","bibend":"","@passthrough/true":CSL.Output.Formatters.passthrough,"@font-style/italic":"<fo:inline font-style=\"italic\">%%STRING%%</fo:inline>","@font-style/oblique":"<fo:inline font-style=\"oblique\">%%STRING%%</fo:inline>","@font-style/normal":"<fo:inline font-style=\"normal\">%%STRING%%</fo:inline>","@font-variant/small-caps":"<fo:inline font-variant=\"small-caps\">%%STRING%%</fo:inline>","@font-variant/normal":"<fo:inline font-variant=\"normal\">%%STRING%%</fo:inline>","@font-weight/bold":"<fo:inline font-weight=\"bold\">%%STRING%%</fo:inline>","@font-weight/normal":"<fo:inline font-weight=\"normal\">%%STRING%%</fo:inline>","@font-weight/light":"<fo:inline font-weight=\"lighter\">%%STRING%%</fo:inline>","@text-decoration/none":"<fo:inline text-decoration=\"none\">%%STRING%%</fo:inline>","@text-decoration/underline":"<fo:inline text-decoration=\"underline\">%%STRING%%</fo:inline>","@vertical-align/sup":"<fo:inline vertical-align=\"super\">%%STRING%%</fo:inline>","@vertical-align/sub":"<fo:inline vertical-align=\"sub\">%%STRING%%</fo:inline>","@vertical-align/baseline":"<fo:inline vertical-align=\"baseline\">%%STRING%%</fo:inline>","@strip-periods/true":CSL.Output.Formatters.passthrough,"@strip-periods/false":CSL.Output.Formatters.passthrough,"@quotes/true":function(state,str){if("undefined"===typeof str){return state.getTerm("open-quote");}return state.getTerm("open-quote")+str+state.getTerm("close-quote");},"@quotes/inner":function(state,str){if("undefined"===typeof str){return"\u2019";}return state.getTerm("open-inner-quote")+str+state.getTerm("close-inner-quote");},"@quotes/false":false,"@cite/entry":function(state,str){return state.sys.wrapCitationEntry(str,this.item_id,this.locator_txt,this.suffix_txt);},"@bibliography/entry":function(state,str){var indent="";if(state.bibliography&&state.bibliography.opt&&state.bibliography.opt.hangingindent){var hi=state.bibliography.opt.hangingindent;indent=" start-indent=\""+hi+"em\" text-indent=\"-"+hi+"em\"";}var insert="";if(state.sys.embedBibliographyEntry){insert=state.sys.embedBibliographyEntry(this.item_id)+"\n";}return"<fo:block id=\""+this.system_id+"\""+indent+">"+str+"</fo:block>\n"+insert;},"@display/block":function(state,str){return"\n  <fo:block>"+str+"</fo:block>\n";},"@display/left-margin":function(state,str){return"\n  <fo:table table-layout=\"fixed\" width=\"100%\">\n    "+"<fo:table-column column-number=\"1\" column-width=\"$$$__COLUMN_WIDTH_1__$$$\"/>\n    "+"<fo:table-column column-number=\"2\" column-width=\"proportional-column-width(1)\"/>\n    "+"<fo:table-body>\n      "+"<fo:table-row>\n        "+"<fo:table-cell>\n          "+"<fo:block>"+str+"</fo:block>\n        "+"</fo:table-cell>\n        ";},"@display/right-inline":function(state,str){return"<fo:table-cell>\n          "+"<fo:block>"+str+"</fo:block>\n        "+"</fo:table-cell>\n      "+"</fo:table-row>\n    "+"</fo:table-body>\n  "+"</fo:table>\n";},"@display/indent":function(state,str){return"<fo:block margin-left=\"2em\">"+str+"</fo:block>\n";},"@showid/true":function(state,str){if(!state.tmp.just_looking&&!state.tmp.suppress_decorations&&this.params&&"string"===typeof str){var prePunct="";if(str){var m=str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);prePunct=m[1];str=m[2];}var postPunct="";if(str&&CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1))>-1){postPunct=str.slice(-1);str=str.slice(0,-1);}return state.sys.variableWrapper(this.params,prePunct,str,postPunct);}else{return str;}},"@URL/true":function(state,str){return"<fo:basic-link external-destination=\"url('"+str+"')\">"+str+"</fo:basic-link>";},"@DOI/true":function(state,str){var doiurl=str;if(!str.match(/^https?:\/\//)){doiurl="https://doi.org/"+str;}return"<fo:basic-link external-destination=\"url('"+doiurl+"')\">"+str+"</fo:basic-link>";}};/**
 * LaTeX .bbl output.
 *
 * (Code contributed by Egon Willighagen, based on the prototype.text code.)
 */CSL.Output.Formats.prototype.latex={"text_escape":function(text){if(!text){text="";}return text;},"bibstart":"\\begin{thebibliography}{4}","bibend":"\end{thebibliography}","@font-style/italic":"{\\em %%STRING%%}","@font-style/oblique":false,"@font-style/normal":false,"@font-variant/small-caps":false,"@passthrough/true":CSL.Output.Formatters.passthrough,"@font-variant/normal":false,"@font-weight/bold":"{\\bf %%STRING%%}","@font-weight/normal":false,"@font-weight/light":false,"@text-decoration/none":false,"@text-decoration/underline":false,"@vertical-align/baseline":false,"@vertical-align/sup":false,"@vertical-align/sub":false,"@strip-periods/true":CSL.Output.Formatters.passthrough,"@strip-periods/false":CSL.Output.Formatters.passthrough,"@quotes/true":function(state,str){if("undefined"===typeof str){return state.getTerm("open-quote");}return state.getTerm("open-quote")+str+state.getTerm("close-quote");},"@quotes/inner":function(state,str){if("undefined"===typeof str){//
// Mostly right by being wrong (for apostrophes)
//
return"\u2019";}return state.getTerm("open-inner-quote")+str+state.getTerm("close-inner-quote");},"@quotes/false":false,//"@bibliography/body": function (state,str){
//    return "<div class=\"csl-bib-body\">\n"+str+"</div>";
//},
"@cite/entry":function(state,str){return state.sys.wrapCitationEntry(str,this.item_id,this.locator_txt,this.suffix_txt);},"@bibliography/entry":function(state,str){return"\\bibitem{"+state.sys.embedBibliographyEntry(this.item_id)+"}\n";},"@display/block":function(state,str){return"\n"+str;},"@display/left-margin":function(state,str){return str;},"@display/right-inline":function(state,str){return str;},"@display/indent":function(state,str){return"\n    "+str;},"@showid/true":function(state,str,cslid){return str;},"@URL/true":function(state,str){return str;},"@DOI/true":function(state,str){return str;}};CSL.Output.Formats=new CSL.Output.Formats();/*global CSL: true */ //
// Time for a rewrite of this module.
//
// Simon has pointed out that list and hash behavior can
// be obtained by ... just using a list and a hash.  This
// is faster for batched operations, because sorting is
// greatly optimized.  Since most of the interaction
// with plugins at runtime will involve batches of
// references, there will be solid gains if the current,
// one-reference-at-a-time approach implemented here
// can be replaced with something that leverages the native
// sort method of the Array() type.
//
// That's going to take some redesign, but it will simplify
// things in the long run, so it might as well happen now.
//
// We'll keep makeCitationCluster and makeBibliography as
// simple methods that return a string.  Neither should
// have any effect on internal state.  This will be a change
// in behavior for makeCitationCluster.
//
// A new updateItems command will be introduced, to replace
// insertItems.  It will be a simple list of IDs, in the
// sequence of first reference in the document.
//
// The calling application should always invoke updateItems
// before makeCitationCluster.
//
//
// should allow batched registration of items by
// key.  should behave as an update, with deletion
// of items and the tainting of disambiguation
// partner sets affected by a deletes and additions.
//
//
// we'll need a reset method, to clear the decks
// in the citation area and start over.
/**
 * Registry of cited items.
 * <p>This is a persistent store of disambiguation and
 * sort order information relating to individual items
 * for which rendering is requested.  Item data is stored
 * in a hash, with the item key as hash key, for quick
 * retrieval.  A virtual sequence within the hashed store
 * is maintained on the fly as items are added to the
 * store, using <code>*_next</code> and <code>*_prev</code>
 * attributes on each item.  A separate hash of items
 * based on their undisambiguated cite form is
 * maintained, and the item id list and disambiguation
 * level for each set of disambiguation partners is shared
 * through the registry item.</p>
 * @class
 */CSL.Registry=function(state){this.debug=false;this.state=state;this.registry={};this.reflist=[];this.refhash={};this.namereg=new CSL.Registry.NameReg(state);this.citationreg=new CSL.Registry.CitationReg(state);// See CSL.NameOutput.prototype.outputNames
// and CSL.Registry.prototype.doinserts
this.authorstrings={};// for parallel delimiter support
this.masterMap={};//
// shared scratch vars
this.mylist=[];this.myhash={};this.deletes=[];this.inserts=[];this.uncited={};this.refreshes={};this.akeys={};this.oldseq={};this.return_data={};//
// each ambig is a list of the ids of other objects
// that have the same base-level rendering
this.ambigcites={};this.ambigresets={};this.sorter=new CSL.Registry.Comparifier(state,"bibliography_sort");//this.modes = CSL.getModes.call(this.state);
//this.checkerator = new CSL.Checkerator();
this.getSortedIds=function(){var ret=[];for(var i=0,ilen=this.reflist.length;i<ilen;i+=1){ret.push(""+this.reflist[i].id);}return ret;};this.getSortedRegistryItems=function(){var ret=[];for(var i=0,ilen=this.reflist.length;i<ilen;i+=1){ret.push(this.reflist[i]);}return ret;};};//
// Here's the sequence of operations to be performed on
// update:
//
//  1.  (o) [init] Receive list as function argument, store as hash and as list.
//  2.  (o) [init] Initialize refresh list.  Never needs sorting, only hash required.
//  3.  (o) [dodeletes] Delete loop.
//  3a. (o) [dodeletes] Delete names in items to be deleted from names reg.
//  3b. (o) [dodeletes] Complement refreshes list with items affected by
//      possible name changes.  We'll actually perform the refresh once
//      all of the necessary data and parameters have been established
//      in the registry.
//  3c. (o) [dodeletes] Delete all items to be deleted from their disambig pools.
//  3d. (o) [dodeletes] Delete all items in deletion list from hash.
//  4.  (o) [doinserts] Insert loop.
//  4a. (o) [doinserts] Retrieve entries for items to insert.
//  4b. (o) [doinserts] Generate ambig key.
//  4c. (o) [doinserts] Add names in items to be inserted to names reg
//      (implicit in getAmbiguousCite).
//  4d. (o) [doinserts] Record ambig pool key on akey list (used for updating further
//      down the chain).
//  4e. (o) [doinserts] Create registry token.
//  4f. (o) [doinserts] Add item ID to hash.
//  4g. (o) [doinserts] Set and record the base token to hold disambiguation
//      results ("disambig" in the object above).
//  5.  (o) [rebuildlist] Create "new" list of hash pointers, in the order given
//          in the argument to the update function.
//  6.  (o) [rebuildlist] Apply citation numbers to new list.
//  7.  (o) [dorefreshes] Refresh items requiring update.
//  5. (o) [delnames] Delete names in items to be deleted from names reg, and obtain IDs
//         of other items that would be affected by changes around that surname.
//  6. (o) [delnames] Complement delete and insert lists with items affected by
//         possible name changes.
//  7. (o) [delambigs] Delete all items to be deleted from their disambig pools.
//  8. (o) [delhash] Delete all items in deletion list from hash.
//  9. (o) [addtohash] Retrieve entries for items to insert.
// 10. (o) [addtohash] Add items to be inserted to their disambig pools.
// 11. (o) [addtohash] Add names in items to be inserted to names reg
//         (implicit in getAmbiguousCite).
// 12. (o) [addtohash] Create registry token for each item to be inserted.
// 13. (o) [addtohash] Add items for insert to hash.
// 14. (o) [buildlist] Create "new" list of hash pointers, in the order given in the argument
//         to the update function.
// 15. (o) [renumber] Apply citation numbers to new list.
// 16. (o) [setdisambigs] Set disambiguation parameters on each inserted item token.
// 17. (o) [setsortkeys] Set sort keys on each item token.
// 18. (o) [sorttokens] Resort token list
// 19. (o) [renumber] Reset citation numbers on list items
//
CSL.Registry.prototype.init=function(itemIDs,uncited_flag){var i,ilen;this.oldseq={};//  1. Receive list as function argument, store as hash and as list.
//
// Result:
//   this.mylist: a list of all itemIDs of referenced items, cited and uncited.
//   this.myhash: a hash of index positions in this.mylist.
//   this.uncited: hash of uncited itemIDs.
//
// Proceed as follows.
//
if(uncited_flag){// If uncited_flag is non-nil, add any missing itemIDs to this.mylist
// from itemIDs input list, and set the itemIDs in itemIDs on this.uncited.
this.uncited={};for(var i=0,ilen=itemIDs.length;i<ilen;i+=1){if(!this.myhash[itemIDs[i]]){this.mylist.push(""+itemIDs[i]);}this.uncited[itemIDs[i]]=true;this.myhash[itemIDs[i]]=true;}}else{// If uncited_flag is nil, remove duplicate itemIDs from itemIDs input
// list, set the result on this.mylist, and add missing itemIDs to
// this.mylist from itemIDs input list.
for(var key in this.uncited){itemIDs.push(key);}var myhash={};for(i=itemIDs.length-1;i>-1;i+=-1){if(myhash[itemIDs[i]]){itemIDs=itemIDs.slice(0,i).concat(itemIDs.slice(i+1));}else{myhash[itemIDs[i]]=true;}}this.mylist=itemIDs;this.myhash=myhash;}//
//  2. Initialize refresh list.  Never needs sorting, only hash required.
//
this.refreshes={};this.touched={};this.ambigsTouched={};this.ambigresets={};};CSL.Registry.prototype.dopurge=function(myhash){// Remove any uncited items not in myhash
for(var i=this.mylist.length-1;i>-1;i+=-1){// Might not want to be quite this restrictive.
if(this.citationreg.citationsByItemId){if((!this.citationreg.citationsByItemId||!this.citationreg.citationsByItemId[this.mylist[i]])&&!myhash[this.mylist[i]]){delete this.myhash[this.mylist[i]];delete this.uncited[this.mylist[i]];this.mylist=this.mylist.slice(0,i).concat(this.mylist.slice(i+1));}}}this.dodeletes(this.myhash);};CSL.Registry.prototype.dodeletes=function(myhash){var otheritems,key,ambig,pos,len,items,kkey,mypos,id;if("string"===typeof myhash){var key=myhash;myhash={};myhash[key]=true;}//
//  3. Delete loop.
//
for(var key in this.registry){if(!myhash[key]){// skip items explicitly marked as uncited
if(this.uncited[key]){continue;}//
//  3a. Delete names in items to be deleted from names reg.
//
otheritems=this.namereg.delitems(key);//
//  3b. Complement refreshes list with items affected by
//      possible name changes.  We'll actually perform the refresh once
//      all of the necessary data and parameters have been established
//      in the registry.
//
for(kkey in otheritems){this.refreshes[kkey]=true;}//
//  3c. Delete all items to be deleted from their disambig pools.
//
ambig=this.registry[key].ambig;mypos=this.ambigcites[ambig].indexOf(key);if(mypos>-1){items=this.ambigcites[ambig].slice();this.ambigcites[ambig]=items.slice(0,mypos).concat(items.slice(mypos+1,items.length));this.ambigresets[ambig]=this.ambigcites[ambig].length;}//
// XX. What we've missed is to provide an update of all
// items sharing the same ambig  += -1 the remaining items in
// ambigcites.  So let's do that here, just in case the
// names update above doesn't catch them all.
//
len=this.ambigcites[ambig].length;for(pos=0;pos<len;pos+=1){id=""+this.ambigcites[ambig][pos];this.refreshes[id]=true;}//
// 3d-0. Remove parallel id references and realign
// parallel ID refs.
//
if(this.registry[key].siblings){if(this.registry[key].siblings.length==1){var loneSiblingID=this.registry[key].siblings[0];if(this.registry[loneSiblingID].siblings){this.registry[loneSiblingID].siblings.pop();this.registry[loneSiblingID].master=true;// this.registry[loneSiblingID].parallel = false;
}}else if(this.registry[key].siblings.length>1){var removeIDs=[key];if(this.registry[key].master){var newmasterID=this.registry[key].siblings[0];var newmaster=this.registry[newmasterID];newmaster.master=true;// newmaster.parallel_delimiter is set externally, if at all
// newmaster.parallel = false;
removeIDs.push(newmasterID);// for (var k = 0, klen = this.registry[key].siblings.length; k < klen; k += 1) {
//     this.registry[this.registry[key].siblings[k]].parallel = newmasterID;
// }
}var buffer=[];for(var k=this.registry[key].siblings.length-1;k>-1;k+=-1){var siblingID=this.registry[key].siblings.pop();if(removeIDs.indexOf(siblingID)===-1){buffer.push(siblingID);}}for(var k=buffer.length-1;k>-1;k+=-1){this.registry[key].siblings.push(buffer[k]);}}}//
// 3d-1. Remove item from reflist
for(var i=this.reflist.length-1;i>-1;i--){if(this.reflist[i].id===key){this.reflist=this.reflist.slice(0,i).concat(this.reflist.slice(i+1));}}//
//  3d. Delete all items in deletion list from hash.
//
delete this.registry[key];delete this.refhash[key];// For processCitationCluster()
this.return_data.bibchange=true;}}// Disabled.  See formats.js for code.
// this.state.fun.decorate.items_delete( this.state.output[this.state.opt.mode].tmp, myhash );
};CSL.Registry.prototype.doinserts=function(mylist){var item,Item,akey,newitem,abase,i,ilen;if("string"===typeof mylist){mylist=[mylist];}//
//  4. Insert loop.
//
for(var i=0,ilen=mylist.length;i<ilen;i+=1){item=mylist[i];if(!this.registry[item]){//
//  4a. Retrieve entries for items to insert.
//
Item=this.state.retrieveItem(item);//
//  4b. Generate ambig key.
//
// AND
//
//  4c. Add names in items to be inserted to names reg
//      (implicit in getAmbiguousCite).
//
akey=CSL.getAmbiguousCite.call(this.state,Item);this.ambigsTouched[akey]=true;//
//  4d. Record ambig pool key on akey list (used for updating further
//      down the chain).
//
if(!Item.legislation_id){this.akeys[akey]=true;}//
//  4e. Create registry token.
//
newitem={"id":""+item,"seq":0,"offset":0,"sortkeys":false,"ambig":false,"rendered":false,"disambig":false,"ref":Item,"newItem":true};//
//
//  4f. Add item ID to hash.
//
this.registry[item]=newitem;//
//  4f(a). Add first reference note number
//         (this may be redundant)
if(this.citationreg.citationsByItemId&&this.citationreg.citationsByItemId[item]){this.registry[item]["first-reference-note-number"]=this.citationreg.citationsByItemId[item][0].properties.noteIndex;}//
//  4g. Set and record the base token to hold disambiguation
//      results ("disambig" in the object above).
//
abase=CSL.getAmbigConfig.call(this.state);this.registerAmbigToken(akey,item,abase);//if (!this.ambigcites[akey]){
//    this.ambigcites[akey] = [];
//}
//CSL.debug("Run: "+item+"("+this.ambigcites[akey]+")");
//if (this.ambigcites[akey].indexOf(item) === -1){
//    CSL.debug("  Add: "+item);
//    this.ambigcites[akey].push(item);
//}
//
//  4h. Make a note that this item needs its sort keys refreshed.
//
this.touched[item]=true;// For processCitationCluster()
this.return_data.bibchange=true;}}// Disabled.  See formats.js for code.
// this.state.fun.decorate.items_add( this.state.output[this.state.opt.mode].tmp, mylist );
};/*
// No longer required.
CSL.Registry.prototype.douncited = function () {
    var pos, len;
    var cited_len = this.mylist.length - this.uncited.length;
    for (pos = 0, len = cited_len; pos < len; pos += 1) {
        this.registry[this.mylist[pos]].uncited = false;
    }
    for (pos = cited_len, len = this.mylist.length; pos < len; pos += 1) {
        this.registry[this.mylist[pos]].uncited = true;
    }
};
*/CSL.Registry.prototype.rebuildlist=function(nosort){var len,pos,item,Item;//
//  5. Create "new" list of hash pointers, in the order given in the argument
//     to the update function.
//
//
// XXX Keep reflist in place.
//
if(!nosort){this.reflist_inserts=[];//
//  6. Apply citation numbers to new list,
//     saving off old sequence numbers as we go.
//
// XXX Just memo inserts -- actual insert happens below, at last "sort"
//
len=this.mylist.length;for(pos=0;pos<len;pos+=1){item=this.mylist[pos];Item=this.registry[item];if(Item.newItem){this.reflist_inserts.push(Item);}this.oldseq[item]=this.registry[item].seq;this.registry[item].seq=pos+1;}}else{this.reflist=[];len=this.mylist.length;for(pos=0;pos<len;pos+=1){item=this.mylist[pos];Item=this.registry[item];this.reflist.push(Item);this.oldseq[item]=this.registry[item].seq;this.registry[item].seq=pos+1;}}};/*
 * Okay, at this point we should have a numbered list
 * of registry tokens in the notional order requested,
 * with sequence numbers to reconstruct the ordering
 * if the list is remangled.  So far so good.
 */CSL.Registry.prototype.dorefreshes=function(){var key,regtoken,Item,akey,abase;//
//  7. Refresh items requiring update.
//
// It looks like we need to do four things on each cite for refresh:
// (1) Generate the akey for the cite.
// (2) Register it on the ambig token.
// (3) Register the akey in this.akeys
// (4) Register the item ID in this.touched
//
for(var key in this.refreshes){regtoken=this.registry[key];if(!regtoken){continue;}regtoken.sortkeys=undefined;Item=this.state.refetchItem(key);var akey=regtoken.ambig;if("undefined"===typeof akey){this.state.tmp.disambig_settings=false;akey=CSL.getAmbiguousCite.call(this.state,Item);abase=CSL.getAmbigConfig.call(this.state);this.registerAmbigToken(akey,key,abase);}for(var akkey in this.ambigresets){if(this.ambigresets[akkey]===1){var loneKey=this.ambigcites[akey][0];var Item=this.state.refetchItem(loneKey);this.registry[loneKey].disambig=new CSL.AmbigConfig();this.state.tmp.disambig_settings=false;var akey=CSL.getAmbiguousCite.call(this.state,Item);var abase=CSL.getAmbigConfig.call(this.state);this.registerAmbigToken(akey,loneKey,abase);}}this.state.tmp.taintedItemIDs[key]=true;this.ambigsTouched[akey]=true;if(!Item.legislation_id){this.akeys[akey]=true;}this.touched[key]=true;}};/*
 * Main disambiguation  += -1 can everything for disambiguation be
 * crunched into this function?
 */CSL.Registry.prototype.setdisambigs=function(){//
// Okay, more changes.  Here is where we resolve all disambiguation
// issues for cites touched by the update.  The this.ambigcites set is
// based on the complete short form of citations, and is the basis on
// which names are added and minimal adding of initials or given names
// is performed.
//
//
//  8.  Set disambiguation parameters on each inserted item token.
//
for(var akey in this.ambigsTouched){//
// Disambiguation is fully encapsulated.
// Disambiguator will run only if there are multiple
// items, and at least one disambiguation mode is
// in effect.
this.state.disambiguate.run(akey);}this.ambigsTouched={};this.akeys={};};CSL.Registry.prototype.renumber=function(){var len,pos,item;//
// 19. Reset citation numbers on list items
//
if(this.state.bibliography_sort.opt.citation_number_sort_direction===CSL.DESCENDING){this.state.bibliography_sort.tmp.citation_number_map={};}len=this.reflist.length;for(pos=0;pos<len;pos+=1){item=this.reflist[pos];// save the overhead of rerenderings if citation-number is not
// used in the style.
item.seq=pos+1;if(this.state.bibliography_sort.opt.citation_number_sort_direction===CSL.DESCENDING){this.state.bibliography_sort.tmp.citation_number_map[item.seq]=this.reflist.length-item.seq+1;}// update_mode is set to CSL.NUMERIC if citation-number is rendered
// in citations.
if(this.state.opt.update_mode===CSL.NUMERIC&&item.seq!=this.oldseq[item.id]){this.state.tmp.taintedItemIDs[item.id]=true;}if(item.seq!=this.oldseq[item.id]){this.return_data.bibchange=true;}}};CSL.Registry.prototype.setsortkeys=function(){var key;//
// 17. Set sort keys on each item token.
//
for(var i=0,ilen=this.mylist.length;i<ilen;i+=1){var key=this.mylist[i];// The last of these conditions may create some thrashing on styles that do not require sorting.
if(this.touched[key]||this.state.tmp.taintedItemIDs[key]||!this.registry[key].sortkeys){this.registry[key].sortkeys=CSL.getSortKeys.call(this.state,this.state.retrieveItem(key),"bibliography_sort");}}};CSL.Registry.prototype._insertItem=function(element,array){array.splice(this._locationOf(element,array)+1,0,element);return array;};CSL.Registry.prototype._locationOf=function(element,array,start,end){if(array.length===0){return-1;}start=start||0;end=end||array.length;var pivot=start+end>>1;// should be faster than dividing by 2
var c=this.sorter.compareKeys(element,array[pivot]);if(end-start<=1){return c==-1?pivot-1:pivot;}switch(c){case-1:return this._locationOf(element,array,start,pivot);case 0:return pivot;case 1:return this._locationOf(element,array,pivot,end);}};CSL.Registry.prototype.sorttokens=function(nosort){var len,item,Item,pos;//
// 18. Resort token list.
//
if(!nosort){this.reflist_inserts=[];len=this.mylist.length;for(pos=0;pos<len;pos+=1){item=this.mylist[pos];Item=this.registry[item];if(Item.newItem){this.reflist_inserts.push(Item);}}// There is a thin possibility that tainted items in a sorted list
// will change position due to disambiguation. We cover for that here.
for(var key in this.state.tmp.taintedItemIDs){if(this.registry[key]&&!this.registry[key].newItem){// Move tainted items from reflist to reflist_inserts
for(var i=this.reflist.length-1;i>-1;i--){if(this.reflist[i].id===key){this.reflist_inserts.push(this.reflist[i]);this.reflist=this.reflist.slice(0,i).concat(this.reflist.slice(i+1));}}}}for(var i=0,ilen=this.reflist_inserts.length;i<ilen;i++){var Item=this.reflist_inserts[i];delete Item.newItem;this.reflist=this._insertItem(Item,this.reflist);}for(pos=0;pos<len;pos+=1){item=this.mylist[pos];Item=this.registry[item];this.registry[item].seq=pos+1;}}};/**
 * Compare two sort keys
 * <p>Nested, because keys are an array.</p>
 */CSL.Registry.Comparifier=function(state,keyset){var sort_directions,len,pos,compareKeys;var sortCompare=CSL.getSortCompare.call(state,state.opt["default-locale-sort"]);sort_directions=state[keyset].opt.sort_directions;this.compareKeys=function(a,b){len=a.sortkeys?a.sortkeys.length:0;for(pos=0;pos<len;pos+=1){//
// for ascending sort 1 uses 1, -1 uses -1.
// For descending sort, the values are reversed.
//
// Need to handle undefined values.  No way around it.
// So have to screen .localeCompare (which is also
// needed) from undefined values.  Everywhere, in all
// compares.
//
var cmp=0;if(a.sortkeys[pos]===b.sortkeys[pos]){cmp=0;}else if("undefined"===typeof a.sortkeys[pos]){cmp=sort_directions[pos][1];}else if("undefined"===typeof b.sortkeys[pos]){cmp=sort_directions[pos][0];}else{// cmp = a.sortkeys[pos].localeCompare(b.sortkeys[pos]);
cmp=sortCompare(a.sortkeys[pos],b.sortkeys[pos]);}if(0<cmp){return sort_directions[pos][1];}else if(0>cmp){return sort_directions[pos][0];}}if(a.seq>b.seq){return 1;}else if(a.seq<b.seq){return-1;}return 0;};compareKeys=this.compareKeys;this.compareCompositeKeys=function(a,b){return compareKeys(a[1],b[1]);};};/**
 * Compare two disambiguation tokens by their registry sort order
 * <p>Disambiguation lists need to be sorted this way, to
 * obtain the correct year-suffix when that's used.</p>
 */CSL.Registry.prototype.compareRegistryTokens=function(a,b){if(a.seq>b.seq){return 1;}else if(a.seq<b.seq){return-1;}return 0;};CSL.Registry.prototype.registerAmbigToken=function(akey,id,ambig_config){//SNIP-START
if(!this.registry[id]){CSL.debug("Warning: unregistered item: itemID=("+id+"), akey=("+akey+")");}//SNIP-END
// Taint if number of names to be included has changed
if(this.registry[id]&&this.registry[id].disambig&&this.registry[id].disambig.names){for(var i=0,ilen=ambig_config.names.length;i<ilen;i+=1){var new_names_params=ambig_config.names[i];var old_names_params=this.registry[id].disambig.names[i];if(new_names_params!==old_names_params){this.state.tmp.taintedItemIDs[id]=true;}else if(ambig_config.givens[i]){// Compare givenses only if the number of names is aligned.
for(var j=0,jlen=ambig_config.givens[i].length;j<jlen;j+=1){var new_gnames_params=ambig_config.givens[i][j];var old_gnames_params=this.registry[id].disambig.givens[i][j];if(new_gnames_params!==old_gnames_params){this.state.tmp.taintedItemIDs[id]=true;}}}}}if(!this.ambigcites[akey]){this.ambigcites[akey]=[];}if(this.ambigcites[akey].indexOf(""+id)===-1){this.ambigcites[akey].push(""+id);}this.registry[id].ambig=akey;this.registry[id].disambig=CSL.cloneAmbigConfig(ambig_config);};/**
 * Get the sort key of an item, without decorations
 * <p>This is used internally by the Registry.</p>
 */CSL.getSortKeys=function(Item,key_type){var area,root,extension,strip_prepositions,len,pos;//SNIP-START
if(false){}//SNIP-END
area=this.tmp.area;root=this.tmp.root;extension=this.tmp.extension;strip_prepositions=CSL.Util.Sort.strip_prepositions;this.tmp.area=key_type;// Gawdawful, this.
this.tmp.root=key_type.indexOf("_")>-1?key_type.slice(0,-5):key_type;this.tmp.extension="_sort";this.tmp.disambig_override=true;this.tmp.disambig_request=false;this.tmp.suppress_decorations=true;CSL.getCite.call(this,Item);this.tmp.suppress_decorations=false;this.tmp.disambig_override=false;len=this[key_type].keys.length;for(pos=0;pos<len;pos+=1){this[key_type].keys[pos]=strip_prepositions(this[key_type].keys[pos]);}//SNIP-START
if(false){}//SNIP-END
this.tmp.area=area;this.tmp.root=root;this.tmp.extension=extension;return this[key_type].keys;};/*global CSL: true */CSL.Registry.NameReg=function(state){var pkey,ikey,skey,dagopt,gdropt,items,strip_periods,set_keys,evalname,delitems,addname,myitems;this.state=state;this.namereg={};this.nameind={};// used for restoring state following preview
this.nameindpkeys={};//
// family, initials form, fullname (with given stripped of periods)
//
// keys registered, indexed by ID
this.itemkeyreg={};strip_periods=function(str){if(!str){str="";}return str.replace(/\./g," ").replace(/\s+/g," ").replace(/\s+$/,"");};set_keys=function(state,itemid,nameobj){pkey=strip_periods(nameobj.family);skey=strip_periods(nameobj.given);// Drop lowercase suffixes (such as et al.) from given name field
// for disambiguation purposes.
var m=skey.match(/[,\!]* ([^,]+)$/);if(m&&m[1]===m[1].toLowerCase()){skey=skey.replace(/[,\!]* [^,]+$/,"");}// The %s terminator enables normal initialization behavior
// with non-Byzantine names.
ikey=CSL.Util.Names.initializeWith(state,skey,"%s");if(state.citation.opt["givenname-disambiguation-rule"]==="by-cite"){pkey=""+itemid+pkey;}};evalname=function(item_id,nameobj,namenum,request_base,form,initials){var param;// XXX THIS CAN NO LONGER HAPPEN
if(state.tmp.area.slice(0,12)==="bibliography"&&!form){if("string"===typeof initials){return 1;}else{return 2;}}var res=state.nameOutput.getName(nameobj,"locale-translit",true);nameobj=res.name;set_keys(this.state,""+item_id,nameobj);//
// possible options are:
//
// <option disambiguate-add-givenname value="true"/> (a)
// <option disambiguate-add-givenname value="all-names"/> (a)
// <option disambiguate-add-givenname value="all-names-with-initials"/> (b)
// <option disambiguate-add-givenname value="primary-name"/> (d)
// <option disambiguate-add-givenname value="primary-name-with-initials"/> (e)
// <option disambiguate-add-givenname value="by-cite"/> (g)
//
param=2;dagopt=state.opt["disambiguate-add-givenname"];gdropt=state.citation.opt["givenname-disambiguation-rule"];var gdropt_orig=gdropt;if(gdropt==="by-cite"){gdropt="all-names";}//
// set initial value
//
if("short"===form){param=0;}else if("string"===typeof initials){param=1;}//
// give literals a pass
if("undefined"===typeof this.namereg[pkey]||"undefined"===typeof this.namereg[pkey].ikey[ikey]){return param;}//
// adjust value upward if appropriate -- only if running
// a non-names-global disambiguation strategy
//
if(gdropt_orig==="by-cite"&&param<=request_base){//param = request_base;
return request_base;}if(!dagopt){return param;}if("string"===typeof gdropt&&gdropt.slice(0,12)==="primary-name"&&namenum>0){return param;}//
// the last composite condition is for backward compatibility
//
if(!gdropt||gdropt==="all-names"||gdropt==="primary-name"){if(this.namereg[pkey].count>1){param=1;}if(this.namereg[pkey].ikey&&this.namereg[pkey].ikey[ikey].count>1||this.namereg[pkey].count>1&&"string"!==typeof initials){param=2;}}else if(gdropt==="all-names-with-initials"||gdropt==="primary-name-with-initials"){if(this.namereg[pkey].count>1){param=1;}else{param=0;}}if(!state.registry.registry[item_id]){if(form=="short"){return 0;}else if("string"==typeof initials){return 1;}}else{return param;}};//
// The operation of this function does not show up in the
// standard test suite, but it has been hand-tested with
// a print trace, and seems to work okay.
//
delitems=function(ids){var pos,len,posB,id,fullkey;if("string"===typeof ids||"number"===typeof ids){ids=[""+ids];}// ret carries the IDs of other items using this name.
var ret={};len=ids.length;for(pos=0;pos<len;pos+=1){id=""+ids[pos];if(!this.nameind[id]){continue;}for(fullkey in this.nameind[id]){if(this.nameind[id].hasOwnProperty(fullkey)){var key=fullkey.split("::");pkey=key[0];ikey=key[1];skey=key[2];// Skip names that have been deleted already.
// Needed to clear integration DisambiguateAddGivenname1.txt
// and integration DisambiguateAddGivenname2.txt
if("undefined"===typeof this.namereg[pkey]){continue;}// ????
//posA = this.namereg[pkey].items.indexOf(posA);
items=this.namereg[pkey].items;// This was really, really unperceptive. They key elements
// have absolutely nothing to do with whether there was ever
// a registration at each key level.
if(skey&&this.namereg[pkey].ikey[ikey]&&this.namereg[pkey].ikey[ikey].skey[skey]){myitems=this.namereg[pkey].ikey[ikey].skey[skey].items;posB=myitems.indexOf(""+id);if(posB>-1){this.namereg[pkey].ikey[ikey].skey[skey].items=myitems.slice(0,posB).concat(myitems.slice([posB+1]));}if(this.namereg[pkey].ikey[ikey].skey[skey].items.length===0){delete this.namereg[pkey].ikey[ikey].skey[skey];this.namereg[pkey].ikey[ikey].count+=-1;if(this.namereg[pkey].ikey[ikey].count<2){for(var i=0,ilen=this.namereg[pkey].ikey[ikey].items.length;i<ilen;i+=1){state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]]=true;}}}}if(ikey&&this.namereg[pkey].ikey[ikey]){posB=this.namereg[pkey].ikey[ikey].items.indexOf(""+id);if(posB>-1){items=this.namereg[pkey].ikey[ikey].items.slice();this.namereg[pkey].ikey[ikey].items=items.slice(0,posB).concat(items.slice([posB+1]));}if(this.namereg[pkey].ikey[ikey].items.length===0){delete this.namereg[pkey].ikey[ikey];this.namereg[pkey].count+=-1;if(this.namereg[pkey].count<2){for(var i=0,ilen=this.namereg[pkey].items.length;i<ilen;i+=1){state.tmp.taintedItemIDs[this.namereg[pkey].items[i]]=true;}}}}if(pkey){posB=this.namereg[pkey].items.indexOf(""+id);if(posB>-1){items=this.namereg[pkey].items.slice();this.namereg[pkey].items=items.slice(0,posB).concat(items.slice([posB+1],items.length));}if(this.namereg[pkey].items.length<2){delete this.namereg[pkey];}}delete this.nameind[id][fullkey];}}delete this.nameind[id];delete this.nameindpkeys[id];}return ret;};//
// Run ALL
// renderings with disambiguate-add-givenname set to a value
// with the by-cite behaviour, and then set the names-based
// expanded form when the final makeCitationCluster rendering
// is output.  This could be done with a single var set on
// the state object in the execution wrappers that run the
// style.
//
addname=function(item_id,nameobj,pos){var i,ilen;var res=state.nameOutput.getName(nameobj,"locale-translit",true);nameobj=res.name;if(state.citation.opt["givenname-disambiguation-rule"]&&state.citation.opt["givenname-disambiguation-rule"].slice(0,8)==="primary-"&&pos!==0){return;}// A hack. Safe if the name object is used only here, for disambiguation purposes.
if(state.opt["demote-non-dropping-particle"]==="never"&&nameobj["non-dropping-particle"]&&nameobj["family"]){nameobj["family"]=nameobj["non-dropping-particle"]+" "+nameobj["family"];}//CSL.debug("INS");
set_keys(this.state,""+item_id,nameobj);// pkey, ikey and skey should be stored in separate cascading objects.
// there should also be a kkey, on each, which holds the item ids using
// that form of the name.
//
// (later note: well, we seem to have slipped a notch here.
// Adding lists of IDs all over the place here makes no sense;
// the lists need to include _only_ the items currently rendered
// at the given level, and the place to do that is in evalname,
// and in delnames, not here.)
if(pkey){if("undefined"===typeof this.namereg[pkey]){this.namereg[pkey]={};this.namereg[pkey].count=0;this.namereg[pkey].ikey={};this.namereg[pkey].items=[item_id];}else if(this.namereg[pkey].items.indexOf(item_id)===-1){this.namereg[pkey].items.push(item_id);}//            if (this.namereg[pkey].items.indexOf(item_id) === -1) {
//                this.namereg[pkey].items.push(item_id);
//            }
}if(pkey&&ikey){if("undefined"===typeof this.namereg[pkey].ikey[ikey]){this.namereg[pkey].ikey[ikey]={};this.namereg[pkey].ikey[ikey].count=0;this.namereg[pkey].ikey[ikey].skey={};this.namereg[pkey].ikey[ikey].items=[item_id];this.namereg[pkey].count+=1;if(this.namereg[pkey].count===2){for(var i=0,ilen=this.namereg[pkey].items.length;i<ilen;i+=1){state.tmp.taintedItemIDs[this.namereg[pkey].items[i]]=true;}}}else if(this.namereg[pkey].ikey[ikey].items.indexOf(item_id)===-1){this.namereg[pkey].ikey[ikey].items.push(item_id);}//            if (this.namereg[pkey].ikey[ikey].items.indexOf(item_id) === -1) {
//                this.namereg[pkey].ikey[ikey].items.push(item_id);
//            }
}if(pkey&&ikey&&skey){if("undefined"===typeof this.namereg[pkey].ikey[ikey].skey[skey]){this.namereg[pkey].ikey[ikey].skey[skey]={};this.namereg[pkey].ikey[ikey].skey[skey].items=[item_id];this.namereg[pkey].ikey[ikey].count+=1;if(this.namereg[pkey].ikey[ikey].count===2){for(var i=0,ilen=this.namereg[pkey].ikey[ikey].items.length;i<ilen;i+=1){state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]]=true;}}}else if(this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf(item_id)===-1){this.namereg[pkey].ikey[ikey].skey[skey].items.push(item_id);}//            if (this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf(item_id) === -1) {
//                this.namereg[pkey].ikey[ikey].skey[skey].items.push(item_id);
//            }
}if("undefined"===typeof this.nameind[item_id]){this.nameind[item_id]={};this.nameindpkeys[item_id]={};}//CSL.debug("INS-A: [" + pkey + "] [" + ikey + "] [" + skey + "]");
if(pkey){this.nameind[item_id][pkey+"::"+ikey+"::"+skey]=true;this.nameindpkeys[item_id][pkey]=this.namereg[pkey];}//CSL.debug("INS-B");
};this.addname=addname;this.delitems=delitems;this.evalname=evalname;};/*global CSL: true */CSL.Registry.CitationReg=function(){this.citationById={};this.citationByIndex=[];};/*global CSL: true */CSL.Disambiguation=function(state){this.state=state;this.sys=this.state.sys;this.registry=state.registry.registry;this.ambigcites=state.registry.ambigcites;this.configModes();this.debug=false;};CSL.Disambiguation.prototype.run=function(akey){if(!this.modes.length){return;}//SNIP-START
if(this.debug){print("[A] === RUN ===");}//SNIP-END
this.akey=akey;if(this.initVars(akey)){this.runDisambig();}};CSL.Disambiguation.prototype.runDisambig=function(){var ismax;//SNIP-START
if(this.debug){print("[C] === runDisambig() ===");}//SNIP-END
this.initGivens=true;//
// Length of list may change during processing
while(this.lists.length){this.gnameset=0;this.gname=0;this.clashes=[1,0];// each list is scanned repeatedly until all
// items either succeed or ultimately fail.
while(this.lists[0][1].length){this.listpos=0;if(!this.base){this.base=this.lists[0][0];}ismax=this.incrementDisambig();this.scanItems(this.lists[0]);this.evalScan(ismax);}this.lists=this.lists.slice(1);}};CSL.Disambiguation.prototype.scanItems=function(list){var pos,len,otherItem;//SNIP-START
if(this.debug){print("[2] === scanItems() ===");}//SNIP-END
this.Item=list[1][0];this.ItemCite=CSL.getAmbiguousCite.call(this.state,this.Item,this.base,true);this.scanlist=list[1];this.partners=[];this.partners.push(this.Item);this.nonpartners=[];var clashes=0;for(var pos=1,len=list[1].length;pos<len;pos+=1){otherItem=list[1][pos];var otherItemCite=CSL.getAmbiguousCite.call(this.state,otherItem,this.base,true);//SNIP-START
if(this.debug){if(pos>1){print("  -----------");}}//SNIP-END
if(this.ItemCite===otherItemCite){//SNIP-START
if(this.debug){print("  [CLASH]--> "+this.Item.id+": "+this.ItemCite);print("             "+otherItem.id+": "+otherItemCite);}//SNIP-END
clashes+=1;this.partners.push(otherItem);}else{//SNIP-START
if(this.debug){print("  [clear]--> "+this.Item.id+": "+this.ItemCite);print("             "+otherItem.id+": "+otherItemCite);}//SNIP-END
this.nonpartners.push(otherItem);}}this.clashes[0]=this.clashes[1];this.clashes[1]=clashes;};CSL.Disambiguation.prototype.evalScan=function(maxed){this[this.modes[this.modeindex]](maxed);if(maxed){if(this.modeindex<this.modes.length-1){this.modeindex+=1;}else{this.lists[this.listpos+1]=[this.base,[]];}}};CSL.Disambiguation.prototype.disNames=function(ismax){var i,ilen;//SNIP-START
if(this.debug){print("[3] == disNames() ==");//print("       partners: "+[this.partners[i].id for (i in this.partners)].join(", "));
//print("    nonpartners: "+[this.nonpartners[i].id for (i in this.nonpartners)].join(", "));
}//SNIP-END
// New design
// this.base is a forward-only counter. Values are never
// reduced, and the counter object is never overwritten.
// It is methodically pushed forward in single-unit increments
// in incrementDisambig() until disNames() wipes out the list.
// this.betterbase is cloned from this.base exactly once,
// at the start of a disambiguation run. Whenever an operation
// results in improvement, the just-incremented elements
// identified as this.base.names[this.gnameset] (number of
// names)and as this.base.givens[this.gnameset][this.gname]
// (level of given name) are copied from this.base.
// The this.base object is used to control disambiguation
// renderings. These will be more fully expanded than the final
// text, but the flip side of the fact that the extra data does
// not contribute anything to disambiguation is that leaving
// it in does no harm -- think of it as the Cold Dark Matter of
// disambiguation.
if(this.clashes[1]===0&&this.nonpartners.length===1){this.captureStepToBase();//SNIP-START
if(this.debug){print("  ** RESOLUTION [a]: lone partner, one nonpartner");print("  registering "+this.partners[0].id+" and "+this.nonpartners[0].id);}//SNIP-END
this.state.registry.registerAmbigToken(this.akey,""+this.nonpartners[0].id,this.betterbase);this.state.registry.registerAmbigToken(this.akey,""+this.partners[0].id,this.betterbase);this.lists[this.listpos]=[this.betterbase,[]];}else if(this.clashes[1]===0){this.captureStepToBase();//SNIP-START
if(this.debug){print("  ** RESOLUTION [b]: lone partner, unknown number of remaining nonpartners");print("  registering "+this.partners[0].id);}//SNIP-END
this.state.registry.registerAmbigToken(this.akey,""+this.partners[0].id,this.betterbase);this.lists[this.listpos]=[this.betterbase,this.nonpartners];if(this.nonpartners.length){this.initGivens=true;}}else if(this.nonpartners.length===1){this.captureStepToBase();//SNIP-START
if(this.debug){print("  ** RESOLUTION [c]: lone nonpartner, unknown number of partners remaining");print("  registering "+this.nonpartners[0].id);}//SNIP-END
this.state.registry.registerAmbigToken(this.akey,""+this.nonpartners[0].id,this.betterbase);//this.lists[this.listpos] = [this.betterbase, this.partners];
this.lists[this.listpos]=[this.betterbase,this.partners];}else if(this.clashes[1]<this.clashes[0]){this.captureStepToBase();//SNIP-START
if(this.debug){print("  ** RESOLUTION [d]: better result, but no entries safe to register");}//SNIP-END
this.lists[this.listpos]=[this.betterbase,this.partners];this.lists.push([this.betterbase,this.nonpartners]);}else{//SNIP-START
if(this.debug){print("  ** RESOLUTION [e]: no improvement, and clashes remain");}//SNIP-END
if(ismax){this.lists[this.listpos]=[this.betterbase,this.nonpartners];this.lists.push([this.betterbase,this.partners]);if(this.modeindex===this.modes.length-1){//SNIP-START
if(this.debug){print("     (registering clashing entries because we've run out of options)");}//SNIP-END
for(var i=0,ilen=this.partners.length;i<ilen;i+=1){this.state.registry.registerAmbigToken(this.akey,""+this.partners[i].id,this.betterbase);}this.lists[this.listpos]=[this.betterbase,[]];}}}};CSL.Disambiguation.prototype.disExtraText=function(){//SNIP-START
if(this.debug){print("[3] === disExtraText ==");}//SNIP-END
var done=false;if(this.clashes[1]===0&&this.nonpartners.length<2){done=true;}// If first encounter in this cycle and multiple modes are
// available, decrement mode and reset base
if(!done&&(!this.base.disambiguate||this.state.tmp.disambiguate_count!==this.state.tmp.disambiguate_maxMax)){// Rerun everything on each subcycle? This doesn't work currently.
//this.initVars(this.akey)
this.modeindex=0;this.base.disambiguate=this.state.tmp.disambiguate_count;this.betterbase.disambiguate=this.state.tmp.disambiguate_count;if(!this.base.disambiguate){// Evaluate here?
this.initGivens=true;// If disambiguate is false set to true
this.base.disambiguate=1;// There may be changes
for(var i=0,ilen=this.lists[this.listpos][1].length;i<ilen;i+=1){this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id]=true;}}else{this.disNames();}}else if(done||this.state.tmp.disambiguate_count===this.state.tmp.disambiguate_maxMax){if(done||this.modeindex===this.modes.length-1){// If this is the end, disambiguation failed.
// Discard disambiguate=true (?) and set parameters
var base=this.lists[this.listpos][0];for(var i=0,ilen=this.lists[this.listpos][1].length;i<ilen;i+=1){this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id]=true;this.state.registry.registerAmbigToken(this.akey,""+this.lists[this.listpos][1][i].id,base);}this.lists[this.listpos]=[this.betterbase,[]];}else{// If this is followed by year-suffix, keep
// parameters and set disambiguate=true since it MIGHT
// include the date, needed for year-suffix.
// This may be a bit over-aggressive for cases in which the
// disambiguate condition does not add the date
this.modeindex=this.modes.length-1;var base=this.lists[this.listpos][0];base.disambiguate=true;for(var i=0,ilen=this.lists[this.listpos][1].length;i<ilen;i+=1){// Always tainting here might be a little over-aggressive, but a taint may be required.
this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id]=true;this.state.registry.registerAmbigToken(this.akey,""+this.lists[this.listpos][1][i].id,base);}}}};CSL.Disambiguation.prototype.disYears=function(){var pos,len,tokens,token;//SNIP-START
if(this.debug){print("[3] === disYears ==");}//SNIP-END
tokens=[];var base=this.lists[this.listpos][0];if(this.clashes[1]){// That is, if the initial increment on the ambigs group returns no
// clashes, don't apply suffix. The condition is a necessary failsafe.
// In original submission order
for(var i=0,ilen=this.state.registry.mylist.length;i<ilen;i+=1){var origid=this.state.registry.mylist[i];for(var j=0,jlen=this.lists[this.listpos][1].length;j<jlen;j+=1){var token=this.lists[this.listpos][1][j];// Warning: token.id can be number. This should be fixed at a higher level in citeproc-js if poss.
if(token.id==origid){tokens.push(this.registry[token.id]);break;}}}}tokens.sort(this.state.registry.sorter.compareKeys);for(var pos=0,len=tokens.length;pos<len;pos+=1){base.year_suffix=""+pos;var oldBase=this.state.registry.registry[tokens[pos].id].disambig;this.state.registry.registerAmbigToken(this.akey,""+tokens[pos].id,base);if(CSL.ambigConfigDiff(oldBase,base)){this.state.tmp.taintedItemIDs[tokens[pos].id]=true;}}this.lists[this.listpos]=[this.betterbase,[]];};CSL.Disambiguation.prototype.incrementDisambig=function(){//SNIP-START
if(this.debug){print("\n[1] === incrementDisambig() ===");}//SNIP-END
if(this.initGivens){this.initGivens=false;return false;}var maxed=false;var increment_names=true;if("disNames"===this.modes[this.modeindex]){// this.gnameset: the index pos of the current nameset
// this.gname: the index pos of the current name w/in the current nameset
// Stages:
// - Increment givenname (optional)
// - Add a name (optional)
// - Move to next nameset
// Incrementing is done forward-only on this.base. Values
// that improve disambiguation results are copied to
// this.betterbase, which is used to set the disambig parameters
// in the processor registry.
// Increment
// Max val is always true if a level is inactive.
increment_names=false;if("number"!==typeof this.givensMax){increment_names=true;}var increment_namesets=false;if("number"!==typeof this.namesMax){increment_namesets=true;}if("number"===typeof this.givensMax){if(this.base.givens.length&&this.base.givens[this.gnameset][this.gname]<this.givensMax){this.base.givens[this.gnameset][this.gname]+=1;}else{increment_names=true;}}if("number"===typeof this.namesMax&&increment_names){if(this.state.opt["disambiguate-add-names"]){increment_namesets=false;if(this.gname<this.namesMax){this.base.names[this.gnameset]+=1;this.gname+=1;}else{increment_namesets=true;}}else{increment_namesets=true;}}if("number"===typeof this.namesetsMax&&increment_namesets){if(this.gnameset<this.namesetsMax){this.gnameset+=1;this.base.names[this.gnameset]=1;this.gname=0;}}//SNIP-START
if(this.debug){print("    ------------------");print("    incremented values");print("    ------------------");print("    | gnameset: "+this.gnameset);print("    | gname: "+this.gname);print("    | names value: "+this.base.names[this.gnameset]);if(this.base.givens.length){print("    | givens value: "+this.base.givens[this.gnameset][this.gname]);}else{print("    | givens value: nil");}print("    | namesetsMax: "+this.namesetsMax);print("    | namesMax: "+this.namesMax);print("    | givensMax: "+this.givensMax);}//SNIP-END
if(("number"!==typeof this.namesetsMax||this.namesetsMax===-1||this.gnameset===this.namesetsMax)&&(!this.state.opt["disambiguate-add-names"]||"number"!==typeof this.namesMax||this.gname===this.namesMax)&&("number"!=typeof this.givensMax||"undefined"===typeof this.base.givens[this.gnameset]||"undefined"===typeof this.base.givens[this.gnameset][this.gname]||this.base.givens[this.gnameset][this.gname]===this.givensMax)){maxed=true;//SNIP-START
if(this.debug){print("    MAXED");}//SNIP-END
}}else if("disExtraText"===this.modes[this.modeindex]){this.base.disambiguate+=1;this.betterbase.disambiguate+=1;}return maxed;};CSL.Disambiguation.prototype.initVars=function(akey){var i,ilen,myIds,myItemBundles,myItems;//SNIP-START
if(this.debug){print("[B] === initVars() ===");}//SNIP-END
this.lists=[];this.base=false;this.betterbase=false;this.akey=akey;this.maxNamesByItemId={};myItemBundles=[];myIds=this.ambigcites[akey];if(!myIds||!myIds.length){return false;}var myItem=this.state.refetchItem(""+myIds[0]);this.getCiteData(myItem);this.base=CSL.getAmbigConfig.call(this.state);if(myIds&&myIds.length>1){myItemBundles.push([this.maxNamesByItemId[myItem.id],myItem]);// Build a composite list of Items and associated
// max names. This is messy, but it's the only
// way to get the items sorted by the number of names
// to be disambiguated. If they are in descending order
// with name expansions, the processor will hang.
for(var i=1,ilen=myIds.length;i<ilen;i+=1){myItem=this.state.refetchItem(""+myIds[i]);this.getCiteData(myItem,this.base);myItemBundles.push([this.maxNamesByItemId[myItem.id],myItem]);}myItemBundles.sort(function(a,b){if(a[0]>b[0]){return 1;}else if(a[0]<b[0]){return-1;}else{if(a[1].id>b[1].id){return 1;}else if(a[1].id<b[1].id){return-1;}else{return 0;}}});myItems=[];for(var i=0,ilen=myItemBundles.length;i<ilen;i+=1){myItems.push(myItemBundles[i][1]);}this.lists.push([this.base,myItems]);this.Item=this.lists[0][1][0];}else{this.Item=this.state.refetchItem(""+myIds[0]);}this.modeindex=0;if(this.state.citation.opt["disambiguate-add-names"]||true){this.namesMax=this.maxNamesByItemId[this.Item.id][0];}else{var namesMax=this.base.names[0];for(var i=1,ilen=this.base.names.length;i<ilen;i+=1){namesMax=Math.max(namesMax,this.base.names.names[i]);}}this.padBase(this.base);this.padBase(this.betterbase);this.base.year_suffix=false;this.base.disambiguate=false;this.betterbase.year_suffix=false;this.betterbase.disambiguate=false;if(this.state.citation.opt["givenname-disambiguation-rule"]==="by-cite"&&this.state.opt["disambiguate-add-givenname"]){this.givensMax=2;}return true;};CSL.Disambiguation.prototype.padBase=function(base){for(var i=0,ilen=base.names.length;i<ilen;i+=1){if(!base.givens[i]){base.givens[i]=[];}for(var j=0,jlen=base.names[i];j<jlen;j+=1){if(!base.givens[i][j]){base.givens[i][j]=0;}}}};/**
 * Set available modes for disambiguation
 */CSL.Disambiguation.prototype.configModes=function(){var dagopt,gdropt;// Modes are function names prototyped to this instance.
this.modes=[];dagopt=this.state.opt["disambiguate-add-givenname"];gdropt=this.state.citation.opt["givenname-disambiguation-rule"];if(this.state.opt['disambiguate-add-names']||dagopt&&gdropt==="by-cite"){this.modes.push("disNames");}if(this.state.opt.development_extensions.prioritize_disambiguate_condition){if(this.state.opt.has_disambiguate){this.modes.push("disExtraText");}if(this.state.opt["disambiguate-add-year-suffix"]){this.modes.push("disYears");}}else{if(this.state.opt["disambiguate-add-year-suffix"]){this.modes.push("disYears");}if(this.state.opt.has_disambiguate){this.modes.push("disExtraText");}}};CSL.Disambiguation.prototype.getCiteData=function(Item,base){// Initialize base if first set item seen
if(!this.maxNamesByItemId[Item.id]){CSL.getAmbiguousCite.call(this.state,Item,base);base=CSL.getAmbigConfig.call(this.state);this.maxNamesByItemId[Item.id]=CSL.getMaxVals.call(this.state);this.state.registry.registry[Item.id].disambig.givens=this.state.tmp.disambig_settings.givens.slice();// Slice the nested lists as well. Without this, disambiguate_YearSuffixFiftyTwoEntriesByCite fails.
for(var i=0,ilen=this.state.registry.registry[Item.id].disambig.givens.length;i<ilen;i+=1){this.state.registry.registry[Item.id].disambig.givens[i]=this.state.tmp.disambig_settings.givens[i].slice();}this.namesetsMax=this.state.registry.registry[Item.id].disambig.names.length-1;if(!this.base){this.base=base;this.betterbase=CSL.cloneAmbigConfig(base);}if(base.names.length<this.base.names.length){// I don't know what would happen with discrepancies in the number
// of namesets rendered on items, so we use the fewer of the two
// and limit the other to that size.
this.base=base;}// Padding. Within namesets, we use the longer of the two throughout.
for(var i=0,ilen=base.names.length;i<ilen;i+=1){if(base.names[i]>this.base.names[i]){// XXX The old must have been wrong surely. The new, I'm not sure.
//this.base.givens[i] = this.base.givens[i].concat(this.base.givens[i].slice(this.base.names[i]));
this.base.givens[i]=base.givens[i].slice();this.base.names[i]=base.names[i];this.betterbase.names=this.base.names.slice();this.betterbase.givens=this.base.givens.slice();this.padBase(this.base);this.padBase(this.betterbase);}}// This shouldn't be necessary
// getAmbiguousCite() should return a valid and complete
// givens segment under all conditions, but it does not
// do so for institution authors, so we clean up after it
// here.
// Relevant test: sort_ChicagoYearSuffix2
this.betterbase.givens=this.base.givens.slice();for(var j=0,jlen=this.base.givens.length;j<jlen;j+=1){this.betterbase.givens[j]=this.base.givens[j].slice();}}};CSL.Disambiguation.prototype.captureStepToBase=function(){// Be paranoid about the presence of givens
if(this.state.citation.opt["givenname-disambiguation-rule"]==="by-cite"&&this.base.givens&&this.base.givens.length){if("undefined"!==typeof this.base.givens[this.gnameset][this.gname]){if(this.betterbase.givens.length<this.base.givens.length){this.betterbase.givens=JSON.parse(JSON.stringify(this.base.givens));}this.betterbase.givens[this.gnameset][this.gname]=this.base.givens[this.gnameset][this.gname];}}this.betterbase.names[this.gnameset]=this.base.names[this.gnameset];};CSL.Engine.prototype.getJurisdictionList=function(jurisdiction){var jurisdictionList=[];var jurisdictionElems=jurisdiction.split(":");for(var j=jurisdictionElems.length;j>0;j--){var composedID=jurisdictionElems.slice(0,j).join(":");jurisdictionList.push(composedID);if(this.opt.jurisdiction_fallbacks[composedID]){var fallback=this.opt.jurisdiction_fallbacks[composedID];jurisdictionList.push(fallback);}}if(jurisdictionList.indexOf("us")===-1){jurisdictionList.push("us");}return jurisdictionList;};CSL.Engine.prototype.loadStyleModule=function(jurisdiction,xmlSource,skipFallback){var myFallback=null;var macroCount=0;this.juris[jurisdiction]={};var myXml=CSL.setupXml(xmlSource);myXml.addMissingNameNodes(myXml.dataObj);myXml.addInstitutionNodes(myXml.dataObj);myXml.insertPublisherAndPlace(myXml.dataObj);myXml.flagDateMacros(myXml.dataObj);var myNodes=myXml.getNodesByName(myXml.dataObj,"law-module");for(var i=0,ilen=myNodes.length;i<ilen;i++){var myTypes=myXml.getAttributeValue(myNodes[i],"types");if(myTypes){this.juris[jurisdiction].types={};myTypes=myTypes.split(/\s+/);for(var j=0,jlen=myTypes.length;j<jlen;j++){this.juris[jurisdiction].types[myTypes[j]]=true;}}if(!skipFallback){myFallback=myXml.getAttributeValue(myNodes[i],"fallback");if(myFallback){if(jurisdiction!=="us"){this.opt.jurisdiction_fallbacks[jurisdiction]=myFallback;}}}}var lang=this.opt.lang?this.opt.lang:this.opt["default-locale"][0];CSL.SET_COURT_CLASSES(this,lang,myXml,myXml.dataObj);if(!this.juris[jurisdiction].types){this.juris[jurisdiction].types=CSL.MODULE_TYPES;}var myNodes=myXml.getNodesByName(myXml.dataObj,"macro");for(var i=0,ilen=myNodes.length;i<ilen;i++){var myName=myXml.getAttributeValue(myNodes[i],"name");if(!CSL.MODULE_MACROS[myName]){CSL.debug("CSL: skipping non-modular macro name \""+myName+"\" in module context");continue;}macroCount++;this.juris[jurisdiction][myName]=[];// Must use the same XML parser for style and modules.
this.buildTokenLists(myNodes[i],this.juris[jurisdiction][myName]);this.configureTokenList(this.juris[jurisdiction][myName]);}//if (macroCount < Object.keys(CSL.MODULE_MACROS).length) {
//    var missing = [];
//    throw "CSL ERROR: Incomplete jurisdiction style module for: " + jurisdiction;
//}
return myFallback;};CSL.Engine.prototype.retrieveAllStyleModules=function(jurisdictionList){var ret={};var preferences=this.locale[this.opt.lang].opts["jurisdiction-preference"];preferences=preferences?preferences:[];preferences=[""].concat(preferences);for(var i=preferences.length-1;i>-1;i--){var preference=preferences[i];for(var j=0,jlen=jurisdictionList.length;j<jlen;j++){var jurisdiction=jurisdictionList[j];// If we've "seen" it, we have it already, or we're not going to get it.
if(this.opt.jurisdictions_seen[jurisdiction]){continue;}// Try to get the module
var res=this.sys.retrieveStyleModule(jurisdiction,preference);// If we fail and we've run out of preferences, mark as "seen"
// Otherwise mark as "seen" if we get something.
if(!res&&!preference||res){this.opt.jurisdictions_seen[jurisdiction]=true;}// Don't memo unless get got style code.
if(!res){continue;}ret[jurisdiction]=res;}}// Give 'em what we got.
return ret;};CSL.ParticleList=function(){var always_dropping_1=[[[0,1],null]];var always_dropping_3=[[[0,3],null]];var always_non_dropping_1=[[null,[0,1]]];var always_non_dropping_2=[[null,[0,2]]];var always_non_dropping_3=[[null,[0,3]]];var either_1=[[null,[0,1]],[[0,1],null]];var either_2=[[null,[0,2]],[[0,2],null]];var either_1_dropping_best=[[[0,1],null],[null,[0,1]]];var either_2_dropping_best=[[[0,2],null],[null,[0,2]]];var either_3_dropping_best=[[[0,3],null],[null,[0,3]]];var non_dropping_2_alt_dropping_1_non_dropping_1=[[null,[0,2]],[[0,1],[1,2]]];var PARTICLES=[["'s",always_non_dropping_1],["'s-",always_non_dropping_1],["'t",always_non_dropping_1],["a",always_non_dropping_1],["aan 't",always_non_dropping_2],["aan de",always_non_dropping_2],["aan den",always_non_dropping_2],["aan der",always_non_dropping_2],["aan het",always_non_dropping_2],["aan t",always_non_dropping_2],["aan",always_non_dropping_1],["ad-",either_1],["adh-",either_1],["af",either_1],["al",either_1],["al-",either_1],["am de",always_non_dropping_2],["am",always_non_dropping_1],["an-",either_1],["ar-",either_1],["as-",either_1],["ash-",either_1],["at-",either_1],["ath-",either_1],["auf dem",either_2_dropping_best],["auf den",either_2_dropping_best],["auf der",either_2_dropping_best],["auf ter",always_non_dropping_2],["auf",either_1_dropping_best],["aus 'm",either_2_dropping_best],["aus dem",either_2_dropping_best],["aus den",either_2_dropping_best],["aus der",either_2_dropping_best],["aus m",either_2_dropping_best],["aus",either_1_dropping_best],["aus'm",either_2_dropping_best],["az-",either_1],["aš-",either_1],["aḍ-",either_1],["aḏ-",either_1],["aṣ-",either_1],["aṭ-",either_1],["aṯ-",either_1],["aẓ-",either_1],["ben",always_non_dropping_1],["bij 't",always_non_dropping_2],["bij de",always_non_dropping_2],["bij den",always_non_dropping_2],["bij het",always_non_dropping_2],["bij t",always_non_dropping_2],["bij",always_non_dropping_1],["bin",always_non_dropping_1],["boven d",always_non_dropping_2],["boven d'",always_non_dropping_2],["d",always_non_dropping_1],["d'",either_1],["da",either_1],["dal",always_non_dropping_1],["dal'",always_non_dropping_1],["dall'",always_non_dropping_1],["dalla",always_non_dropping_1],["das",either_1],["de die le",always_non_dropping_3],["de die",always_non_dropping_2],["de l",always_non_dropping_2],["de l'",always_non_dropping_2],["de la",non_dropping_2_alt_dropping_1_non_dropping_1],["de las",non_dropping_2_alt_dropping_1_non_dropping_1],["de le",always_non_dropping_2],["de li",either_2],["de van der",always_non_dropping_3],["de",either_1],["de'",either_1],["deca",always_non_dropping_1],["degli",either_1],["dei",either_1],["del",either_1],["dela",always_dropping_1],["dell'",either_1],["della",either_1],["delle",either_1],["dello",either_1],["den",either_1],["der",either_1],["des",either_1],["di",either_1],["die le",always_non_dropping_2],["do",always_non_dropping_1],["don",always_non_dropping_1],["dos",either_1],["du",either_1],["ed-",either_1],["edh-",either_1],["el",either_1],["el-",either_1],["en-",either_1],["er-",either_1],["es-",either_1],["esh-",either_1],["et-",either_1],["eth-",either_1],["ez-",either_1],["eš-",either_1],["eḍ-",either_1],["eḏ-",either_1],["eṣ-",either_1],["eṭ-",either_1],["eṯ-",either_1],["eẓ-",either_1],["het",always_non_dropping_1],["i",always_non_dropping_1],["il",always_dropping_1],["im",always_non_dropping_1],["in 't",always_non_dropping_2],["in de",always_non_dropping_2],["in den",always_non_dropping_2],["in der",either_2],["in het",always_non_dropping_2],["in t",always_non_dropping_2],["in",always_non_dropping_1],["l",always_non_dropping_1],["l'",always_non_dropping_1],["la",always_non_dropping_1],["las",always_non_dropping_1],["le",always_non_dropping_1],["les",either_1],["lo",either_1],["los",always_non_dropping_1],["lou",always_non_dropping_1],["of",always_non_dropping_1],["onder 't",always_non_dropping_2],["onder de",always_non_dropping_2],["onder den",always_non_dropping_2],["onder het",always_non_dropping_2],["onder t",always_non_dropping_2],["onder",always_non_dropping_1],["op 't",always_non_dropping_2],["op de",either_2],["op den",always_non_dropping_2],["op der",always_non_dropping_2],["op gen",always_non_dropping_2],["op het",always_non_dropping_2],["op t",always_non_dropping_2],["op ten",always_non_dropping_2],["op",always_non_dropping_1],["over 't",always_non_dropping_2],["over de",always_non_dropping_2],["over den",always_non_dropping_2],["over het",always_non_dropping_2],["over t",always_non_dropping_2],["over",always_non_dropping_1],["s",always_non_dropping_1],["s'",always_non_dropping_1],["sen",always_dropping_1],["t",always_non_dropping_1],["te",always_non_dropping_1],["ten",always_non_dropping_1],["ter",always_non_dropping_1],["tho",always_non_dropping_1],["thoe",always_non_dropping_1],["thor",always_non_dropping_1],["to",always_non_dropping_1],["toe",always_non_dropping_1],["tot",always_non_dropping_1],["uijt 't",always_non_dropping_2],["uijt de",always_non_dropping_2],["uijt den",always_non_dropping_2],["uijt te de",always_non_dropping_3],["uijt ten",always_non_dropping_2],["uijt",always_non_dropping_1],["uit 't",always_non_dropping_2],["uit de",always_non_dropping_2],["uit den",always_non_dropping_2],["uit het",always_non_dropping_2],["uit t",always_non_dropping_2],["uit te de",always_non_dropping_3],["uit ten",always_non_dropping_2],["uit",always_non_dropping_1],["unter",always_non_dropping_1],["v",always_non_dropping_1],["v.",always_non_dropping_1],["v.d.",always_non_dropping_1],["van 't",always_non_dropping_2],["van de l",always_non_dropping_3],["van de l'",always_non_dropping_3],["van de",always_non_dropping_2],["van de",always_non_dropping_2],["van den",always_non_dropping_2],["van der",always_non_dropping_2],["van gen",always_non_dropping_2],["van het",always_non_dropping_2],["van la",always_non_dropping_2],["van t",always_non_dropping_2],["van ter",always_non_dropping_2],["van van de",always_non_dropping_3],["van",either_1],["vander",always_non_dropping_1],["vd",always_non_dropping_1],["ver",always_non_dropping_1],["vom und zum",always_dropping_3],["vom",either_1],["von 't",always_non_dropping_2],["von dem",either_2_dropping_best],["von den",either_2_dropping_best],["von der",either_2_dropping_best],["von t",always_non_dropping_2],["von und zu",either_3_dropping_best],["von zu",either_2_dropping_best],["von",either_1_dropping_best],["voor 't",always_non_dropping_2],["voor de",always_non_dropping_2],["voor den",always_non_dropping_2],["voor in 't",always_non_dropping_3],["voor in t",always_non_dropping_3],["voor",always_non_dropping_1],["vor der",either_2_dropping_best],["vor",either_1_dropping_best],["z",always_dropping_1],["ze",always_dropping_1],["zu",either_1_dropping_best],["zum",either_1],["zur",either_1]];return PARTICLES;}();CSL.parseParticles=function(){function splitParticles(nameValue,firstNameFlag,caseOverride){// Parse particles out from name fields.
// * nameValue (string) is the field content to be parsed.
// * firstNameFlag (boolean) parse trailing particles
//	 (default is to parse leading particles)
// * caseOverride (boolean) include all but one word in particle set
//	 (default is to include only words with lowercase first char)
//   [caseOverride is not used in this application]
// Returns an array with:
// * (boolean) flag indicating whether a particle was found
// * (string) the name after removal of particles
// * (array) the list of particles found
var origNameValue=nameValue;nameValue=caseOverride?nameValue.toLowerCase():nameValue;var particleList=[];var rex;var hasParticle;if(firstNameFlag){nameValue=nameValue.split("").reverse().join("");rex=CSL.PARTICLE_GIVEN_REGEXP;}else{rex=CSL.PARTICLE_FAMILY_REGEXP;}var m=nameValue.match(rex);while(m){var m1=firstNameFlag?m[1].split("").reverse().join(""):m[1];var firstChar=m?m1:false;var firstChar=firstChar?m1.replace(/^[-\'\u02bb\u2019\s]*(.).*$/,"$1"):false;hasParticle=firstChar?firstChar.toUpperCase()!==firstChar:false;if(!hasParticle){break;}if(firstNameFlag){particleList.push(origNameValue.slice(m1.length*-1));origNameValue=origNameValue.slice(0,m1.length*-1);}else{particleList.push(origNameValue.slice(0,m1.length));origNameValue=origNameValue.slice(m1.length);}//particleList.push(m1);
nameValue=m[2];m=nameValue.match(rex);}if(firstNameFlag){nameValue=nameValue.split("").reverse().join("");particleList.reverse();for(var i=1,ilen=particleList.length;i<ilen;i++){if(particleList[i].slice(0,1)==" "){particleList[i-1]+=" ";}}for(var i=0,ilen=particleList.length;i<ilen;i++){if(particleList[i].slice(0,1)==" "){particleList[i]=particleList[i].slice(1);}}nameValue=origNameValue.slice(0,nameValue.length);}else{nameValue=origNameValue.slice(nameValue.length*-1);}return[hasParticle,nameValue,particleList];}function trimLast(str){var lastChar=str.slice(-1);str=str.trim();if(lastChar===" "&&["\'","\u2019"].indexOf(str.slice(-1))>-1){str+=" ";}return str;}function parseSuffix(nameObj){if(!nameObj.suffix&&nameObj.given){var m=nameObj.given.match(/(\s*,!*\s*)/);if(m){var idx=nameObj.given.indexOf(m[1]);var possible_suffix=nameObj.given.slice(idx+m[1].length);var possible_comma=nameObj.given.slice(idx,idx+m[1].length).replace(/\s*/g,"");if(possible_suffix.replace(/\./g,"")==='et al'&&!nameObj["dropping-particle"]){// This hack covers the case where "et al." is explicitly used in the
// authorship information of the work.
nameObj["dropping-particle"]=possible_suffix;nameObj["comma-dropping-particle"]=",";}else{if(possible_comma.length===2){nameObj["comma-suffix"]=true;}nameObj.suffix=possible_suffix;}nameObj.given=nameObj.given.slice(0,idx);}}}return function(nameObj){// Extract and set non-dropping particle(s) from family name field
var res=splitParticles(nameObj.family);var lastNameValue=res[1];var lastParticleList=res[2];nameObj.family=lastNameValue;var nonDroppingParticle=trimLast(lastParticleList.join(""));if(nonDroppingParticle){nameObj['non-dropping-particle']=nonDroppingParticle;}// Split off suffix first of all
parseSuffix(nameObj);// Extract and set dropping particle(s) from given name field
var res=splitParticles(nameObj.given,true);var firstNameValue=res[1];var firstParticleList=res[2];nameObj.given=firstNameValue;var droppingParticle=firstParticleList.join("").trim();if(droppingParticle){nameObj['dropping-particle']=droppingParticle;}};}();module.exports=CSL;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fetchFileAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return setUserAgent; });
/* harmony import */ var sync_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var sync_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sync_fetch__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);
/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
var _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__webpack_require__.t(21, 1);




const corsEnabled = typeof location !== 'undefined' && typeof document !== 'undefined';
let userAgent = `Citation.js/${_package_json__WEBPACK_IMPORTED_MODULE_3__[/* version */ "a"]} Node.js/${process.version}`;

function normaliseHeaders(headers) {
  const result = {};
  const entries = headers instanceof Headers || headers instanceof sync_fetch__WEBPACK_IMPORTED_MODULE_0___default.a.Headers ? Array.from(headers) : Object.entries(headers);

  for (const [name, header] of entries) {
    result[name.toLowerCase()] = header.toString();
  }

  return result;
}

function parseOpts(opts = {}) {
  const reqOpts = {
    headers: {
      accept: '*/*'
    },
    method: 'GET',
    checkContentType: opts.checkContentType
  };

  if (userAgent && !corsEnabled) {
    reqOpts.headers['user-agent'] = userAgent;
  }

  if (opts.body) {
    reqOpts.method = 'POST';
    const isJson = typeof opts.body !== 'string';
    reqOpts.body = isJson ? JSON.stringify(opts.body) : opts.body;
    reqOpts.headers['content-type'] = isJson ? 'application/json' : 'text/plain';
  }

  if (opts.headers) {
    Object.assign(reqOpts.headers, normaliseHeaders(opts.headers));
  }

  return reqOpts;
}

function sameType(request, response) {
  if (!request.accept || request.accept === '*/*' || !response['content-type']) {
    return true;
  }

  const [a, b] = response['content-type'].split(';')[0].trim().split('/');
  return request.accept.split(',').map(type => type.split(';')[0].trim().split('/')).some(([c, d]) => (c === a || c === '*') && (d === b || d === '*'));
}

function checkResponse(response, opts) {
  const {
    status,
    headers
  } = response;
  let error;

  if (status >= 400) {
    error = new Error(`Server responded with status code ${status}`);
  } else if (opts.checkContentType === true && !sameType(opts.headers, normaliseHeaders(headers))) {
    error = new Error(`Server responded with content-type ${headers.get('content-type')}`);
  }

  if (error) {
    error.status = status;
    error.headers = headers;
    error.body = response.body;
    throw error;
  }

  return response;
}

function fetchFile(url, opts) {
  const reqOpts = parseOpts(opts);
  _logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].http('[core]', reqOpts.method, url, reqOpts);
  const response = checkResponse(sync_fetch__WEBPACK_IMPORTED_MODULE_0___default()(url, reqOpts), reqOpts);
  return response.text();
}
async function fetchFileAsync(url, opts) {
  const reqOpts = parseOpts(opts);
  _logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].http('[core]', reqOpts.method, url, reqOpts);
  return fetch(url, reqOpts).then(response => checkResponse(response, reqOpts)).then(response => response.text());
}
function setUserAgent(newUserAgent) {
  userAgent = newUserAgent;
}
/* unused harmony default export */ var _unused_webpack_default_export = (fetchFile);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Affiliation; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _meta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _createSuper(a){var b=_isNativeReflectConstruct();return function(){var c,d=_getPrototypeOf(a);if(b){var e=_getPrototypeOf(this).constructor;c=Reflect.construct(d,arguments,e)}else c=d.apply(this,arguments);return _possibleConstructorReturn(this,c)}}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(a){return!1}}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var Affiliation=/*#__PURE__*/function(a){function b(){return _classCallCheck(this,b),c.apply(this,arguments)}_inherits(b,a);var c=_createSuper(b);return _createClass(b,null,[{key:"fields",value:function fields(){return{id:this.attr(null),db_id:this.attr(null),agent_id:this.attr(null),other_agent_id:this.attr(null),affiliation_type:this.attr(null),description:this.attr(null),start_date:this.attr(null),end_date:this.attr(null),package_id:this.attr(null),agent:this.belongsTo(_agent__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],"agent_id"),other_agent:this.belongsTo(_agent__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],"other_agent_id"),meta:this.morphOne(_meta__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],"item_id","item_type")}}}]),b}(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);_defineProperty(Affiliation,"entity","affiliations");

/***/ }),
/* 21 */
/***/ (function(module) {

module.exports = JSON.parse("{\"a\":\"0.5.0\"}");

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _models_main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _vuex_orm_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].use(vuex__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);var database=new _vuex_orm_core__WEBPACK_IMPORTED_MODULE_4__[/* default */ "c"].Database;database.register(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"]),database.register(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Affiliation */ "b"]),database.register(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Activity */ "a"]),database.register(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Meta */ "e"]),database.register(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Citation */ "d"]);var store=new vuex__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Store({plugins:[_vuex_orm_core__WEBPACK_IMPORTED_MODULE_4__[/* default */ "c"].install(database)],state:{packageId:null,packageDetail:{},canEdit:!1,controlledLists:{agentTypes:{},activityTypes:{},activityLevels:[],agentIdSchemes:{}}},getters:{agentTypeIcon:function agentTypeIcon(a){return function(b){var c=a.controlledLists.agentTypes[b];return c?c.fa_icon:"fas fa-asterisk"}},agentIdIcon:function agentIdIcon(a){return function(b){var c=a.controlledLists.agentIdSchemes[b];return c?c.fa_icon:"fas fa-link"}},serialisedContent:function serialisedContent(){var a=function(a){return a.query()["with"]("meta").all().map(function(a){return a.$toJson()})};return JSON.stringify({agents:a(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"]),activities:a(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Activity */ "a"]),affiliations:a(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Affiliation */ "b"]),citations:a(_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Citation */ "d"])})}},mutations:{setPackageId:function setPackageId(a,b){vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].set(a,"packageId",b)},setEditPermission:function setEditPermission(a,b){vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].set(a,"canEdit",b)}},actions:{initialise:function initialise(a){return a.dispatch("initLists").then(function(){return a.dispatch("getContributions")})},getContributions:function getContributions(b){return b.state.packageId&&""!==b.state.packageId?Object(_api__WEBPACK_IMPORTED_MODULE_2__[/* get */ "b"])("package_contributions_show?id=".concat(b.state.packageId)).then(function(a){if(void 0!==a){var c=a.map(function(a){return a.agent.id});// there seems to be some kind of bug in .create() where it will sometimes
// create everything and then delete it - manually clearing first then
// using .insert() instead avoids that
b.dispatch("entities/deleteAll").then(function(){_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].insert({data:a.map(function(a){var d=a.agent;return d.affiliations=a.affiliations.map(function(b){return b.db_id=b.id,b.id=null,c.includes(b.other_agent.id)||(b.other_agent.meta={is_hidden:!0}),b}),d._activities=a.activities.filter(function(b){return"[citation]"!==b.activity}).map(function(c){return c.package_id||(c.package_id=b.state.packageId),c}),d._citation=a.activities.filter(function(b){return"[citation]"===b.activity}).map(function(c){return c.package_id||(c.package_id=b.state.packageId),c}).slice(-1)[0],d})})})}}):void 0},getPackage:function getPackage(a,b){return a.commit("setPackageId",b),a.state.packageId&&""!==a.state.packageId?Object(_api__WEBPACK_IMPORTED_MODULE_2__[/* get */ "b"])("package_show?id=".concat(b)).then(function(b){a.state.packageDetail=b}):void 0},initLists:function initLists(a){return Object(_api__WEBPACK_IMPORTED_MODULE_2__[/* get */ "b"])("attribution_controlled_lists").then(function(b){vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].set(a.state.controlledLists,"agentTypes",b.agent_types),vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].set(a.state.controlledLists,"activityTypes",b.contribution_activity_types),vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].set(a.state.controlledLists,"activityLevels",b.contribution_activity_levels),vue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].set(a.state.controlledLists,"agentIdSchemes",b.agent_external_id_schemes)})},removeContributor:function removeContributor(a,b){// mark for deletion rather than deleting instantly
_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].updateMeta(b,{is_hidden:!0,to_delete:!0}),_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].query()["with"]("_activities").find(b).activities.forEach(function(b){_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Activity */ "a"].updateMeta(b.id,{to_delete:!0})})},syncAgent:function syncAgent(a,b){return _models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].updateMeta(b,{syncing:!0}),Object(_api__WEBPACK_IMPORTED_MODULE_2__[/* get */ "b"])("agent_external_read?id=".concat(b,"&diff=True")).then(function(a){_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].update({where:b,data:a}),_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].updateMeta(b,{is_dirty:!0})})["finally"](function(){return _models_main__WEBPACK_IMPORTED_MODULE_3__[/* Agent */ "c"].updateMeta(b,{syncing:!1})})},toggleActivity:function toggleActivity(a,b){var c=_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Activity */ "a"].query()["with"]("meta").find(b);_models_main__WEBPACK_IMPORTED_MODULE_3__[/* Activity */ "a"].updateMeta(b,{to_delete:!c.meta.to_delete})}}});/* harmony default export */ __webpack_exports__["a"] = (store);

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _input.default;
  }
});
Object.defineProperty(exports, "format", {
  enumerable: true,
  get: function get() {
    return _output.default;
  }
});

var _input = _interopRequireDefault(__webpack_require__(63));

var _output = _interopRequireDefault(__webpack_require__(64));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env browser */
const {
  Buffer
} = __webpack_require__(65);

function syncFetch(...args) {
  const [url, opts] = parseArgs(...args);
  const xhr = new XMLHttpRequest();
  xhr.withCredentials = opts.credentials === 'include';
  xhr.timeout = opts.timeout; // Request

  xhr.open(opts.method || 'GET', url, false);

  try {
    xhr.responseType = 'arraybuffer';
  } catch (e) {// not in Worker scope
    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType#Synchronous_XHR_restrictions
  }

  for (const header of opts.headers) {
    xhr.setRequestHeader(...header);
  }

  xhr.send(opts.body || null); // Response

  let headers = xhr.getAllResponseHeaders();
  headers = headers && headers.split('\r\n').filter(Boolean).map(header => header.split(': ', 2));
  return new syncFetch.Response(xhr.response, {
    url: xhr.responseURL,
    status: xhr.status,
    statusText: xhr.statusText,
    headers,
    redirected: xhr.responseURL !== url
  });
}

function parseArgs(resource, init) {
  const request = [];

  if (resource instanceof syncFetch.Request) {
    request.push(resource.url);
    request.push({
      method: resource.method,
      headers: resource.headers,
      body: resource.body
    });
  } else {
    request.push(resource, {});
  }

  Object.assign(request[1], init);
  request[1].headers = new syncFetch.Headers(request[1].headers || {});
  return request;
}

const INTERNALS = Symbol('SyncFetch Internals');

class SyncRequest extends Request {
  constructor(resource, init = {}, body = init.body) {
    super(resource, init);
    this[INTERNALS] = {
      body: body ? Buffer.from(body) : null
    };
  }

  clone() {
    checkBody(this);
    return new SyncRequest(this.url, this);
  }

}

class SyncResponse extends Response {
  constructor(body, init = {}) {
    body = body ? Buffer.from(body) : null;
    super(createStream(body), init);
    this[INTERNALS] = {
      url: init.url,
      redirected: init.redirected,
      body
    };
  }

  get url() {
    return this[INTERNALS].url;
  }

  get redirected() {
    return this[INTERNALS].redirected;
  }

  clone() {
    checkBody(this);
    return new SyncResponse(this[INTERNALS].body, {
      url: this.url,
      headers: this.headers,
      status: this.status,
      statusText: this.statusText,
      redirected: this.redirected
    });
  }

}

class Body {
  constructor(body) {
    this[INTERNALS] = {
      body: Buffer.from(body)
    };
  }

  static mixin(prototype) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (name === 'constructor') {
        continue;
      }

      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
      Object.defineProperty(prototype, name, { ...desc,
        enumerable: true
      });
    }
  }

  arrayBuffer() {
    checkBody(this);
    const buffer = consumeBody(this);
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }

  blob() {
    checkBody(this);
    const type = this.headers && this.headers.get('content-type');
    return new Blob([consumeBody(this)], type && {
      type
    });
  }

  text() {
    checkBody(this);
    return consumeBody(this).toString();
  }

  json() {
    checkBody(this);

    try {
      return JSON.parse(consumeBody(this).toString());
    } catch (err) {
      throw new TypeError(`invalid json response body at ${this.url} reason: ${err.message}`, 'invalid-json');
    }
  }

  buffer() {
    checkBody(this);
    return consumeBody(this).clone();
  }

}

function checkBody(body) {
  if (body.bodyUsed) {
    throw new TypeError(`body used already for: ${body.url}`);
  }
}

function consumeBody(body) {
  _super(body, 'arrayBuffer')();

  return body[INTERNALS].body || Buffer.alloc(0);
}

function _super(self, method) {
  return Object.getPrototypeOf(Object.getPrototypeOf(self))[method].bind(self);
}

function createStream(body) {
  return new ReadableStream({
    start(controller) {
      controller.enqueue(body);
      controller.close();
    }

  });
}

Body.mixin(SyncRequest.prototype);
Body.mixin(SyncResponse.prototype);
syncFetch.Headers = self.Headers;
syncFetch.Request = SyncRequest;
syncFetch.Response = SyncResponse;
module.exports = syncFetch;

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Common.vue?vue&type=template&id=3298e29b&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div")
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./src/components/Common.vue?vue&type=template&id=3298e29b&

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm.js
var vue_esm = __webpack_require__(2);

// EXTERNAL MODULE: ./src/store/main.js
var main = __webpack_require__(22);

// CONCATENATED MODULE: ./src/eventbus.js
var events={saveActivity:"save-activity",closeActivity:"close-activity",removeContributor:"remove-contributor"},eventBus=new vue_esm["a" /* default */];eventBus.$on(events.removeContributor,function(a){main["a" /* default */].dispatch("removeContributor",a)});
// EXTERNAL MODULE: ./src/models/agent.js
var agent = __webpack_require__(8);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Common.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ var Commonvue_type_script_lang_js_ = ({name:"Common",props:["contributorId"],data:function data(){return{eventBus:eventBus,events:events}},computed:{contributor:function contributor(){return agent["a" /* default */].query()["with"]("meta")["with"]("citation").find(this.contributorId)}}});
// CONCATENATED MODULE: ./src/components/Common.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Commonvue_type_script_lang_js_ = (Commonvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1);

// CONCATENATED MODULE: ./src/components/Common.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_Commonvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Common.vue"
/* harmony default export */ var Common = __webpack_exports__["a"] = (component.exports);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(5);

var normalizeHeaderName = __webpack_require__(47);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(30);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(30);
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

var settle = __webpack_require__(48);

var cookies = __webpack_require__(50);

var buildURL = __webpack_require__(27);

var buildFullPath = __webpack_require__(51);

var parseHeaders = __webpack_require__(54);

var isURLSameOrigin = __webpack_require__(55);

var createError = __webpack_require__(31);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(49);
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ nanoid; });

// UNUSED EXPORTS: customAlphabet, customRandom, urlAlphabet, random

// CONCATENATED MODULE: ./node_modules/nanoid/url-alphabet/index.js
// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
// optimize the gzip compression for this alphabet.
let urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';

// CONCATENATED MODULE: ./node_modules/nanoid/index.browser.js
// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.


if (false) {}

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes));

let customRandom = (alphabet, size, getRandom) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  // `Math.clz32` is not used, because it is not available in browsers.
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1; // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.
  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.
  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).
  // `-~f => Math.ceil(f)` if f is a float
  // `-~i => i + 1` if i is an integer

  let step = -~(1.6 * mask * size / alphabet.length);
  return () => {
    let id = '';

    while (true) {
      let bytes = getRandom(step); // A compact alternative for `for (var i = 0; i < step; i++)`.

      let j = step;

      while (j--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[j] & mask] || '';
        if (id.length === size) return id;
      }
    }
  };
};

let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);

let nanoid = (size = 21) => {
  let id = '';
  let bytes = crypto.getRandomValues(new Uint8Array(size)); // A compact alternative for `for (var i = 0; i < step; i++)`.

  while (size--) {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    let byte = bytes[size] & 63;

    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36);
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id += '_';
    } else {
      id += '-';
    }
  }

  return id;
};



/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

!function (e, t) {
   true ? module.exports = t(__webpack_require__(14)) : undefined;
}(this, function (e) {
  return function (e) {
    function t(u) {
      if (n[u]) return n[u].exports;
      var s = n[u] = {
        exports: {},
        id: u,
        loaded: !1
      };
      return e[u].call(s.exports, s, s.exports, t), s.loaded = !0, s.exports;
    }

    var n = {};
    return t.m = e, t.c = n, t.p = "", t(0);
  }([function (e, t, n) {
    "use strict";

    function u(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }

    function s(e, t) {
      var n = {
        debug: !1
      },
          u = (0, c.default)({}, n, t),
          s = new i.default(u);
      e.interceptors.request.use(function (e) {
        var t = e.requestId;

        if (t) {
          var n = o.CancelToken.source();
          e.cancelToken = n.token, s.addRequest(t, n.cancel);
        }

        return e;
      }), e.interceptors.response.use(function (e) {
        var t = e.config.requestId;
        return t && s.removeRequest(t), e;
      }), e.cancel = function (e, t) {
        e && s.cancelRequest(e, t);
      }, e.cancelAll = function (e) {
        s.cancelAllRequests(e);
      };
    }

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = s;
    var o = n(3),
        r = n(1),
        i = u(r),
        a = n(2),
        c = u(a);
  }, function (e, t) {
    "use strict";

    function n(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }

    Object.defineProperty(t, "__esModule", {
      value: !0
    });

    var u = function () {
      function e(e, t) {
        for (var n = 0; n < t.length; n++) {
          var u = t[n];
          u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(e, u.key, u);
        }
      }

      return function (t, n, u) {
        return n && e(t.prototype, n), u && e(t, u), t;
      };
    }(),
        s = function () {
      function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        n(this, e), this.options = t, this.pendingRequests = {};
      }

      return u(e, [{
        key: "addRequest",
        value: function (e, t) {
          this.log("adding request `" + e + "`"), this.has(e) ? (this.cancelRequest(e, "`cancelRequest(" + e + ")` from `RequestManager.addRequest`.\n      Found duplicate pending request."), this.pendingRequests[e] = t) : this.pendingRequests[e] = t;
        }
      }, {
        key: "removeRequest",
        value: function (e) {
          this.log("removing request `" + e + "`"), delete this.pendingRequests[e];
        }
      }, {
        key: "cancelRequest",
        value: function (e) {
          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "`cancelRequest(" + e + ")` from `RequestManager.cancelRequest`";
          this.log("cancelling request `" + e + "`"), this.has(e) && "function" == typeof this.pendingRequests[e] && (this.pendingRequests[e](t), this.removeRequest(e), this.log("request `" + e + "` cancelled"));
        }
      }, {
        key: "cancelAllRequests",
        value: function (e) {
          for (var t in this.pendingRequests) {
            var n = e || "`cancelRequest(" + t + ")` from `RequestManager.cancelAllRequests`";
            this.cancelRequest(t, n);
          }
        }
      }, {
        key: "has",
        value: function (e) {
          return !!this.pendingRequests[e];
        }
      }, {
        key: "log",
        value: function (e) {
          this.options.debug === !0 && console.log(e);
        }
      }]), e;
    }();

    t.default = s;
  }, function (e, t) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = function () {
      var e = {};

      for (var t in arguments) {
        var n = arguments[t];

        for (var u in n) Object.prototype.hasOwnProperty.call(n, u) && (e[u] = n[u]);
      }

      return e;
    };
  }, function (t, n) {
    t.exports = e;
  }]);
});

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */

var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */

var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */

function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */


function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */


function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */


function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */


function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */


function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */


function getValue(object, key) {
  return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */


function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;

  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }

  return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */


function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */


function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */


function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}
/** Used for built-in method references. */


var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */


var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */


function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */


function listCacheClear() {
  this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function stackDelete(key) {
  return this.__data__['delete'](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function stackGet(key) {
  return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function stackHas(key) {
  return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */


function stackSet(key, value) {
  var cache = this.__data__;

  if (cache instanceof ListCache) {
    var pairs = cache.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }

    cache = this.__data__ = new MapCache(pairs);
  }

  cache.set(key, value);
  return this;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */


function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      if (isHostObject(value)) {
        return object ? value : {};
      }

      result = initCloneObject(isFunc ? {} : value);

      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }

  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */


function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */


function baseGetTag(value) {
  return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */


function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */


function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */


function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */


function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor());
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */


function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */


function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor());
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */


function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */


function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }

  return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */


var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */


function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */


function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */


function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */


function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */


function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */


function cloneDeep(value) {
  return baseClone(value, true, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */


function eq(value, other) {
  return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */


function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */


var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */


var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */


function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */


function stubArray() {
  return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */


function stubFalse() {
  return false;
}

module.exports = cloneDeep;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11), __webpack_require__(59)(module)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory(__webpack_require__(62));else {}
})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE_a352__) {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
          return value[key];
        }.bind(null, key));
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = "fb15");
      /******/
    }(
    /************************************************************************/

    /******/
    {
      /***/
      "01f9":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var LIBRARY = __webpack_require__("2d00");

        var $export = __webpack_require__("5ca1");

        var redefine = __webpack_require__("2aba");

        var hide = __webpack_require__("32e9");

        var Iterators = __webpack_require__("84f2");

        var $iterCreate = __webpack_require__("41a0");

        var setToStringTag = __webpack_require__("7f20");

        var getPrototypeOf = __webpack_require__("38fd");

        var ITERATOR = __webpack_require__("2b4c")('iterator');

        var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

        var FF_ITERATOR = '@@iterator';
        var KEYS = 'keys';
        var VALUES = 'values';

        var returnThis = function () {
          return this;
        };

        module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);

          var getMethod = function (kind) {
            if (!BUGGY && kind in proto) return proto[kind];

            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };

              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }

            return function entries() {
              return new Constructor(this, kind);
            };
          };

          var TAG = NAME + ' Iterator';
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
          var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype; // Fix native

          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              // Set @@toStringTag to native iterators
              setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
            }
          } // fix Array#{values, @@iterator}.name in V8 / FF


          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;

            $default = function values() {
              return $native.call(this);
            };
          } // Define iterator


          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
            hide(proto, ITERATOR, $default);
          } // Plug for library


          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;

          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED) for (key in methods) {
              if (!(key in proto)) redefine(proto, key, methods[key]);
            } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
          }

          return methods;
        };
        /***/

      },

      /***/
      "02f4":
      /***/
      function (module, exports, __webpack_require__) {
        var toInteger = __webpack_require__("4588");

        var defined = __webpack_require__("be13"); // true  -> String#at
        // false -> String#codePointAt


        module.exports = function (TO_STRING) {
          return function (that, pos) {
            var s = String(defined(that));
            var i = toInteger(pos);
            var l = s.length;
            var a, b;
            if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
            a = s.charCodeAt(i);
            return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
          };
        };
        /***/

      },

      /***/
      "0390":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var at = __webpack_require__("02f4")(true); // `AdvanceStringIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-advancestringindex


        module.exports = function (S, index, unicode) {
          return index + (unicode ? at(S, index).length : 1);
        };
        /***/

      },

      /***/
      "0bfb":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 21.2.5.3 get RegExp.prototype.flags

        var anObject = __webpack_require__("cb7c");

        module.exports = function () {
          var that = anObject(this);
          var result = '';
          if (that.global) result += 'g';
          if (that.ignoreCase) result += 'i';
          if (that.multiline) result += 'm';
          if (that.unicode) result += 'u';
          if (that.sticky) result += 'y';
          return result;
        };
        /***/

      },

      /***/
      "0d58":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __webpack_require__("ce10");

        var enumBugKeys = __webpack_require__("e11e");

        module.exports = Object.keys || function keys(O) {
          return $keys(O, enumBugKeys);
        };
        /***/

      },

      /***/
      "1495":
      /***/
      function (module, exports, __webpack_require__) {
        var dP = __webpack_require__("86cc");

        var anObject = __webpack_require__("cb7c");

        var getKeys = __webpack_require__("0d58");

        module.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = getKeys(Properties);
          var length = keys.length;
          var i = 0;
          var P;

          while (length > i) dP.f(O, P = keys[i++], Properties[P]);

          return O;
        };
        /***/
      },

      /***/
      "214f":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        __webpack_require__("b0c5");

        var redefine = __webpack_require__("2aba");

        var hide = __webpack_require__("32e9");

        var fails = __webpack_require__("79e5");

        var defined = __webpack_require__("be13");

        var wks = __webpack_require__("2b4c");

        var regexpExec = __webpack_require__("520a");

        var SPECIES = wks('species');
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          var re = /./;

          re.exec = function () {
            var result = [];
            result.groups = {
              a: '7'
            };
            return result;
          };

          return ''.replace(re, '$<a>') !== '7';
        });

        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
          // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
          var re = /(?:)/;
          var originalExec = re.exec;

          re.exec = function () {
            return originalExec.apply(this, arguments);
          };

          var result = 'ab'.split(re);
          return result.length === 2 && result[0] === 'a' && result[1] === 'b';
        }();

        module.exports = function (KEY, length, exec) {
          var SYMBOL = wks(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};

            O[SYMBOL] = function () {
              return 7;
            };

            return ''[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
            // Symbol-named RegExp methods call .exec
            var execCalled = false;
            var re = /a/;

            re.exec = function () {
              execCalled = true;
              return null;
            };

            if (KEY === 'split') {
              // RegExp[@@split] doesn't call the regex's exec method, but first creates
              // a new one. We need to return the patched regex when creating the new one.
              re.constructor = {};

              re.constructor[SPECIES] = function () {
                return re;
              };
            }

            re[SYMBOL]('');
            return !execCalled;
          }) : undefined;

          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./[SYMBOL];
            var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  // The native String method already delegates to @@method (this
                  // polyfilled function), leasing to infinite recursion.
                  // We avoid it by directly calling the native @@method method.
                  return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, str, arg2)
                  };
                }

                return {
                  done: true,
                  value: nativeMethod.call(str, regexp, arg2)
                };
              }

              return {
                done: false
              };
            });
            var strfn = fns[0];
            var rxfn = fns[1];
            redefine(String.prototype, KEY, strfn);
            hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
            // 21.2.5.11 RegExp.prototype[@@split](string, limit)
            ? function (string, arg) {
              return rxfn.call(string, this, arg);
            } // 21.2.5.6 RegExp.prototype[@@match](string)
            // 21.2.5.9 RegExp.prototype[@@search](string)
            : function (string) {
              return rxfn.call(string, this);
            });
          }
        };
        /***/

      },

      /***/
      "230e":
      /***/
      function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");

        var document = __webpack_require__("7726").document; // typeof document.createElement is 'object' in old IE


        var is = isObject(document) && isObject(document.createElement);

        module.exports = function (it) {
          return is ? document.createElement(it) : {};
        };
        /***/

      },

      /***/
      "23c6":
      /***/
      function (module, exports, __webpack_require__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __webpack_require__("2d95");

        var TAG = __webpack_require__("2b4c")('toStringTag'); // ES3 wrong here


        var ARG = cof(function () {
          return arguments;
        }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

        var tryGet = function (it, key) {
          try {
            return it[key];
          } catch (e) {
            /* empty */
          }
        };

        module.exports = function (it) {
          var O, T, B;
          return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
          : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
          : ARG ? cof(O) // ES3 arguments fallback
          : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
        };
        /***/

      },

      /***/
      "2621":
      /***/
      function (module, exports) {
        exports.f = Object.getOwnPropertySymbols;
        /***/
      },

      /***/
      "2aba":
      /***/
      function (module, exports, __webpack_require__) {
        var global = __webpack_require__("7726");

        var hide = __webpack_require__("32e9");

        var has = __webpack_require__("69a8");

        var SRC = __webpack_require__("ca5a")('src');

        var $toString = __webpack_require__("fa5b");

        var TO_STRING = 'toString';
        var TPL = ('' + $toString).split(TO_STRING);

        __webpack_require__("8378").inspectSource = function (it) {
          return $toString.call(it);
        };

        (module.exports = function (O, key, val, safe) {
          var isFunction = typeof val == 'function';
          if (isFunction) has(val, 'name') || hide(val, 'name', key);
          if (O[key] === val) return;
          if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

          if (O === global) {
            O[key] = val;
          } else if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else if (O[key]) {
            O[key] = val;
          } else {
            hide(O, key, val);
          } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

        })(Function.prototype, TO_STRING, function toString() {
          return typeof this == 'function' && this[SRC] || $toString.call(this);
        });
        /***/
      },

      /***/
      "2aeb":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __webpack_require__("cb7c");

        var dPs = __webpack_require__("1495");

        var enumBugKeys = __webpack_require__("e11e");

        var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

        var Empty = function () {
          /* empty */
        };

        var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

        var createDict = function () {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = __webpack_require__("230e")('iframe');

          var i = enumBugKeys.length;
          var lt = '<';
          var gt = '>';
          var iframeDocument;
          iframe.style.display = 'none';

          __webpack_require__("fab2").appendChild(iframe);

          iframe.src = 'javascript:'; // eslint-disable-line no-script-url
          // createDict = iframe.contentWindow.Object;
          // html.removeChild(iframe);

          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
          iframeDocument.close();
          createDict = iframeDocument.F;

          while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

          return createDict();
        };

        module.exports = Object.create || function create(O, Properties) {
          var result;

          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

            result[IE_PROTO] = O;
          } else result = createDict();

          return Properties === undefined ? result : dPs(result, Properties);
        };
        /***/

      },

      /***/
      "2b4c":
      /***/
      function (module, exports, __webpack_require__) {
        var store = __webpack_require__("5537")('wks');

        var uid = __webpack_require__("ca5a");

        var Symbol = __webpack_require__("7726").Symbol;

        var USE_SYMBOL = typeof Symbol == 'function';

        var $exports = module.exports = function (name) {
          return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
        };

        $exports.store = store;
        /***/
      },

      /***/
      "2d00":
      /***/
      function (module, exports) {
        module.exports = false;
        /***/
      },

      /***/
      "2d95":
      /***/
      function (module, exports) {
        var toString = {}.toString;

        module.exports = function (it) {
          return toString.call(it).slice(8, -1);
        };
        /***/

      },

      /***/
      "2fdb":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 21.1.3.7 String.prototype.includes(searchString, position = 0)

        var $export = __webpack_require__("5ca1");

        var context = __webpack_require__("d2c8");

        var INCLUDES = 'includes';
        $export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
          includes: function includes(searchString
          /* , position = 0 */
          ) {
            return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
          }
        });
        /***/
      },

      /***/
      "32e9":
      /***/
      function (module, exports, __webpack_require__) {
        var dP = __webpack_require__("86cc");

        var createDesc = __webpack_require__("4630");

        module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
          return dP.f(object, key, createDesc(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };
        /***/
      },

      /***/
      "38fd":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __webpack_require__("69a8");

        var toObject = __webpack_require__("4bf8");

        var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

        var ObjectProto = Object.prototype;

        module.exports = Object.getPrototypeOf || function (O) {
          O = toObject(O);
          if (has(O, IE_PROTO)) return O[IE_PROTO];

          if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
          }

          return O instanceof Object ? ObjectProto : null;
        };
        /***/

      },

      /***/
      "41a0":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var create = __webpack_require__("2aeb");

        var descriptor = __webpack_require__("4630");

        var setToStringTag = __webpack_require__("7f20");

        var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

        __webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")('iterator'), function () {
          return this;
        });

        module.exports = function (Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, {
            next: descriptor(1, next)
          });
          setToStringTag(Constructor, NAME + ' Iterator');
        };
        /***/

      },

      /***/
      "456d":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __webpack_require__("4bf8");

        var $keys = __webpack_require__("0d58");

        __webpack_require__("5eda")('keys', function () {
          return function keys(it) {
            return $keys(toObject(it));
          };
        });
        /***/

      },

      /***/
      "4588":
      /***/
      function (module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;

        module.exports = function (it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
        /***/

      },

      /***/
      "4630":
      /***/
      function (module, exports) {
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };
        /***/

      },

      /***/
      "4bf8":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.1.13 ToObject(argument)
        var defined = __webpack_require__("be13");

        module.exports = function (it) {
          return Object(defined(it));
        };
        /***/

      },

      /***/
      "5147":
      /***/
      function (module, exports, __webpack_require__) {
        var MATCH = __webpack_require__("2b4c")('match');

        module.exports = function (KEY) {
          var re = /./;

          try {
            '/./'[KEY](re);
          } catch (e) {
            try {
              re[MATCH] = false;
              return !'/./'[KEY](re);
            } catch (f) {
              /* empty */
            }
          }

          return true;
        };
        /***/

      },

      /***/
      "520a":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var regexpFlags = __webpack_require__("0bfb");

        var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.

        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var LAST_INDEX = 'lastIndex';

        var UPDATES_LAST_INDEX_WRONG = function () {
          var re1 = /a/,
              re2 = /b*/g;
          nativeExec.call(re1, 'a');
          nativeExec.call(re2, 'a');
          return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
        }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


        var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

        if (PATCH) {
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;

            if (NPCG_INCLUDED) {
              reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
            }

            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
            match = nativeExec.call(re, str);

            if (UPDATES_LAST_INDEX_WRONG && match) {
              re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
            }

            if (NPCG_INCLUDED && match && match.length > 1) {
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              // eslint-disable-next-line no-loop-func
              nativeReplace.call(match[0], reCopy, function () {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undefined) match[i] = undefined;
                }
              });
            }

            return match;
          };
        }

        module.exports = patchedExec;
        /***/
      },

      /***/
      "52a7":
      /***/
      function (module, exports) {
        exports.f = {}.propertyIsEnumerable;
        /***/
      },

      /***/
      "5537":
      /***/
      function (module, exports, __webpack_require__) {
        var core = __webpack_require__("8378");

        var global = __webpack_require__("7726");

        var SHARED = '__core-js_shared__';
        var store = global[SHARED] || (global[SHARED] = {});
        (module.exports = function (key, value) {
          return store[key] || (store[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: core.version,
          mode: __webpack_require__("2d00") ? 'pure' : 'global',
          copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
        });
        /***/
      },

      /***/
      "5ca1":
      /***/
      function (module, exports, __webpack_require__) {
        var global = __webpack_require__("7726");

        var core = __webpack_require__("8378");

        var hide = __webpack_require__("32e9");

        var redefine = __webpack_require__("2aba");

        var ctx = __webpack_require__("9b43");

        var PROTOTYPE = 'prototype';

        var $export = function (type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
          var key, own, out, exp;
          if (IS_GLOBAL) source = name;

          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

            out = (own ? target : source)[key]; // bind timers to global for call from export context

            exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

            if (target) redefine(target, key, out, type & $export.U); // export

            if (exports[key] != out) hide(exports, key, exp);
            if (IS_PROTO && expProto[key] != out) expProto[key] = out;
          }
        };

        global.core = core; // type bitmap

        $export.F = 1; // forced

        $export.G = 2; // global

        $export.S = 4; // static

        $export.P = 8; // proto

        $export.B = 16; // bind

        $export.W = 32; // wrap

        $export.U = 64; // safe

        $export.R = 128; // real proto method for `library`

        module.exports = $export;
        /***/
      },

      /***/
      "5eda":
      /***/
      function (module, exports, __webpack_require__) {
        // most Object methods by ES6 should accept primitives
        var $export = __webpack_require__("5ca1");

        var core = __webpack_require__("8378");

        var fails = __webpack_require__("79e5");

        module.exports = function (KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export($export.S + $export.F * fails(function () {
            fn(1);
          }), 'Object', exp);
        };
        /***/

      },

      /***/
      "5f1b":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var classof = __webpack_require__("23c6");

        var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
        // https://tc39.github.io/ecma262/#sec-regexpexec

        module.exports = function (R, S) {
          var exec = R.exec;

          if (typeof exec === 'function') {
            var result = exec.call(R, S);

            if (typeof result !== 'object') {
              throw new TypeError('RegExp exec method returned something other than an Object or null');
            }

            return result;
          }

          if (classof(R) !== 'RegExp') {
            throw new TypeError('RegExp#exec called on incompatible receiver');
          }

          return builtinExec.call(R, S);
        };
        /***/

      },

      /***/
      "613b":
      /***/
      function (module, exports, __webpack_require__) {
        var shared = __webpack_require__("5537")('keys');

        var uid = __webpack_require__("ca5a");

        module.exports = function (key) {
          return shared[key] || (shared[key] = uid(key));
        };
        /***/

      },

      /***/
      "626a":
      /***/
      function (module, exports, __webpack_require__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __webpack_require__("2d95"); // eslint-disable-next-line no-prototype-builtins


        module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
          return cof(it) == 'String' ? it.split('') : Object(it);
        };
        /***/
      },

      /***/
      "6762":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // https://github.com/tc39/Array.prototype.includes

        var $export = __webpack_require__("5ca1");

        var $includes = __webpack_require__("c366")(true);

        $export($export.P, 'Array', {
          includes: function includes(el
          /* , fromIndex = 0 */
          ) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
          }
        });

        __webpack_require__("9c6c")('includes');
        /***/

      },

      /***/
      "6821":
      /***/
      function (module, exports, __webpack_require__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __webpack_require__("626a");

        var defined = __webpack_require__("be13");

        module.exports = function (it) {
          return IObject(defined(it));
        };
        /***/

      },

      /***/
      "69a8":
      /***/
      function (module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;

        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };
        /***/

      },

      /***/
      "6a99":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __webpack_require__("d3f4"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string


        module.exports = function (it, S) {
          if (!isObject(it)) return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
          if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          throw TypeError("Can't convert object to primitive value");
        };
        /***/

      },

      /***/
      "7333":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 19.1.2.1 Object.assign(target, source, ...)

        var getKeys = __webpack_require__("0d58");

        var gOPS = __webpack_require__("2621");

        var pIE = __webpack_require__("52a7");

        var toObject = __webpack_require__("4bf8");

        var IObject = __webpack_require__("626a");

        var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

        module.exports = !$assign || __webpack_require__("79e5")(function () {
          var A = {};
          var B = {}; // eslint-disable-next-line no-undef

          var S = Symbol();
          var K = 'abcdefghijklmnopqrst';
          A[S] = 7;
          K.split('').forEach(function (k) {
            B[k] = k;
          });
          return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
        }) ? function assign(target, source) {
          // eslint-disable-line no-unused-vars
          var T = toObject(target);
          var aLen = arguments.length;
          var index = 1;
          var getSymbols = gOPS.f;
          var isEnum = pIE.f;

          while (aLen > index) {
            var S = IObject(arguments[index++]);
            var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
            var length = keys.length;
            var j = 0;
            var key;

            while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
          }

          return T;
        } : $assign;
        /***/
      },

      /***/
      "7726":
      /***/
      function (module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
        : Function('return this')();
        if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

        /***/
      },

      /***/
      "77f1":
      /***/
      function (module, exports, __webpack_require__) {
        var toInteger = __webpack_require__("4588");

        var max = Math.max;
        var min = Math.min;

        module.exports = function (index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };
        /***/

      },

      /***/
      "79e5":
      /***/
      function (module, exports) {
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
        /***/

      },

      /***/
      "7f20":
      /***/
      function (module, exports, __webpack_require__) {
        var def = __webpack_require__("86cc").f;

        var has = __webpack_require__("69a8");

        var TAG = __webpack_require__("2b4c")('toStringTag');

        module.exports = function (it, tag, stat) {
          if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
            configurable: true,
            value: tag
          });
        };
        /***/

      },

      /***/
      "8378":
      /***/
      function (module, exports) {
        var core = module.exports = {
          version: '2.6.5'
        };
        if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

        /***/
      },

      /***/
      "84f2":
      /***/
      function (module, exports) {
        module.exports = {};
        /***/
      },

      /***/
      "86cc":
      /***/
      function (module, exports, __webpack_require__) {
        var anObject = __webpack_require__("cb7c");

        var IE8_DOM_DEFINE = __webpack_require__("c69a");

        var toPrimitive = __webpack_require__("6a99");

        var dP = Object.defineProperty;
        exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE) try {
            return dP(O, P, Attributes);
          } catch (e) {
            /* empty */
          }
          if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
          if ('value' in Attributes) O[P] = Attributes.value;
          return O;
        };
        /***/
      },

      /***/
      "9b43":
      /***/
      function (module, exports, __webpack_require__) {
        // optional / simple context binding
        var aFunction = __webpack_require__("d8e8");

        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;

          switch (length) {
            case 1:
              return function (a) {
                return fn.call(that, a);
              };

            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };

            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }

          return function ()
          /* ...args */
          {
            return fn.apply(that, arguments);
          };
        };
        /***/

      },

      /***/
      "9c6c":
      /***/
      function (module, exports, __webpack_require__) {
        // 22.1.3.31 Array.prototype[@@unscopables]
        var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');

        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});

        module.exports = function (key) {
          ArrayProto[UNSCOPABLES][key] = true;
        };
        /***/

      },

      /***/
      "9def":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.1.15 ToLength
        var toInteger = __webpack_require__("4588");

        var min = Math.min;

        module.exports = function (it) {
          return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };
        /***/

      },

      /***/
      "9e1e":
      /***/
      function (module, exports, __webpack_require__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__webpack_require__("79e5")(function () {
          return Object.defineProperty({}, 'a', {
            get: function () {
              return 7;
            }
          }).a != 7;
        });
        /***/
      },

      /***/
      "a352":
      /***/
      function (module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
        /***/
      },

      /***/
      "a481":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var anObject = __webpack_require__("cb7c");

        var toObject = __webpack_require__("4bf8");

        var toLength = __webpack_require__("9def");

        var toInteger = __webpack_require__("4588");

        var advanceStringIndex = __webpack_require__("0390");

        var regExpExec = __webpack_require__("5f1b");

        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

        var maybeToString = function (it) {
          return it === undefined ? it : String(it);
        }; // @@replace logic


        __webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
          return [// `String.prototype.replace` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O = defined(this);
            var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
            return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
          }, // `RegExp.prototype[@@replace]` method
          // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
          function (regexp, replaceValue) {
            var res = maybeCallNative($replace, regexp, this, replaceValue);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var functionalReplace = typeof replaceValue === 'function';
            if (!functionalReplace) replaceValue = String(replaceValue);
            var global = rx.global;

            if (global) {
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }

            var results = [];

            while (true) {
              var result = regExpExec(rx, S);
              if (result === null) break;
              results.push(result);
              if (!global) break;
              var matchStr = String(result[0]);
              if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }

            var accumulatedResult = '';
            var nextSourcePosition = 0;

            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = String(result[0]);
              var position = max(min(toInteger(result.index), S.length), 0);
              var captures = []; // NOTE: This is equivalent to
              //   captures = result.slice(1).map(maybeToString)
              // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
              // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
              // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

              for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

              var namedCaptures = result.groups;

              if (functionalReplace) {
                var replacerArgs = [matched].concat(captures, position, S);
                if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                var replacement = String(replaceValue.apply(undefined, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }

              if (position >= nextSourcePosition) {
                accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }

            return accumulatedResult + S.slice(nextSourcePosition);
          }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

          function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

            if (namedCaptures !== undefined) {
              namedCaptures = toObject(namedCaptures);
              symbols = SUBSTITUTION_SYMBOLS;
            }

            return $replace.call(replacement, symbols, function (match, ch) {
              var capture;

              switch (ch.charAt(0)) {
                case '$':
                  return '$';

                case '&':
                  return matched;

                case '`':
                  return str.slice(0, position);

                case "'":
                  return str.slice(tailPos);

                case '<':
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;

                default:
                  // \d\d?
                  var n = +ch;
                  if (n === 0) return match;

                  if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match;
                  }

                  capture = captures[n - 1];
              }

              return capture === undefined ? '' : capture;
            });
          }
        });
        /***/

      },

      /***/
      "aae3":
      /***/
      function (module, exports, __webpack_require__) {
        // 7.2.8 IsRegExp(argument)
        var isObject = __webpack_require__("d3f4");

        var cof = __webpack_require__("2d95");

        var MATCH = __webpack_require__("2b4c")('match');

        module.exports = function (it) {
          var isRegExp;
          return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
        };
        /***/

      },

      /***/
      "ac6a":
      /***/
      function (module, exports, __webpack_require__) {
        var $iterators = __webpack_require__("cadf");

        var getKeys = __webpack_require__("0d58");

        var redefine = __webpack_require__("2aba");

        var global = __webpack_require__("7726");

        var hide = __webpack_require__("32e9");

        var Iterators = __webpack_require__("84f2");

        var wks = __webpack_require__("2b4c");

        var ITERATOR = wks('iterator');
        var TO_STRING_TAG = wks('toStringTag');
        var ArrayValues = Iterators.Array;
        var DOMIterables = {
          CSSRuleList: true,
          // TODO: Not spec compliant, should be false.
          CSSStyleDeclaration: false,
          CSSValueList: false,
          ClientRectList: false,
          DOMRectList: false,
          DOMStringList: false,
          DOMTokenList: true,
          DataTransferItemList: false,
          FileList: false,
          HTMLAllCollection: false,
          HTMLCollection: false,
          HTMLFormElement: false,
          HTMLSelectElement: false,
          MediaList: true,
          // TODO: Not spec compliant, should be false.
          MimeTypeArray: false,
          NamedNodeMap: false,
          NodeList: true,
          PaintRequestList: false,
          Plugin: false,
          PluginArray: false,
          SVGLengthList: false,
          SVGNumberList: false,
          SVGPathSegList: false,
          SVGPointList: false,
          SVGStringList: false,
          SVGTransformList: false,
          SourceBufferList: false,
          StyleSheetList: true,
          // TODO: Not spec compliant, should be false.
          TextTrackCueList: false,
          TextTrackList: false,
          TouchList: false
        };

        for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
          var NAME = collections[i];
          var explicit = DOMIterables[NAME];
          var Collection = global[NAME];
          var proto = Collection && Collection.prototype;
          var key;

          if (proto) {
            if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
            if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
            Iterators[NAME] = ArrayValues;
            if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
          }
        }
        /***/

      },

      /***/
      "b0c5":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var regexpExec = __webpack_require__("520a");

        __webpack_require__("5ca1")({
          target: 'RegExp',
          proto: true,
          forced: regexpExec !== /./.exec
        }, {
          exec: regexpExec
        });
        /***/

      },

      /***/
      "be13":
      /***/
      function (module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function (it) {
          if (it == undefined) throw TypeError("Can't call method on  " + it);
          return it;
        };
        /***/

      },

      /***/
      "c366":
      /***/
      function (module, exports, __webpack_require__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __webpack_require__("6821");

        var toLength = __webpack_require__("9def");

        var toAbsoluteIndex = __webpack_require__("77f1");

        module.exports = function (IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value; // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare

            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++]; // eslint-disable-next-line no-self-compare

              if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
            return !IS_INCLUDES && -1;
          };
        };
        /***/

      },

      /***/
      "c649":
      /***/
      function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */

        (function (global) {
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, "c", function () {
            return insertNodeAt;
          });
          /* harmony export (binding) */


          __webpack_require__.d(__webpack_exports__, "a", function () {
            return camelize;
          });
          /* harmony export (binding) */


          __webpack_require__.d(__webpack_exports__, "b", function () {
            return console;
          });
          /* harmony export (binding) */


          __webpack_require__.d(__webpack_exports__, "d", function () {
            return removeNode;
          });
          /* harmony import */


          var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a481");
          /* harmony import */


          var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);

          function getConsole() {
            if (typeof window !== "undefined") {
              return window.console;
            }

            return global.console;
          }

          var console = getConsole();

          function cached(fn) {
            var cache = Object.create(null);
            return function cachedFn(str) {
              var hit = cache[str];
              return hit || (cache[str] = fn(str));
            };
          }

          var regex = /-(\w)/g;
          var camelize = cached(function (str) {
            return str.replace(regex, function (_, c) {
              return c ? c.toUpperCase() : "";
            });
          });

          function removeNode(node) {
            if (node.parentElement !== null) {
              node.parentElement.removeChild(node);
            }
          }

          function insertNodeAt(fatherNode, node, position) {
            var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
            fatherNode.insertBefore(node, refNode);
          }
          /* WEBPACK VAR INJECTION */

        }).call(this, __webpack_require__("c8ba"));
        /***/
      },

      /***/
      "c69a":
      /***/
      function (module, exports, __webpack_require__) {
        module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
          return Object.defineProperty(__webpack_require__("230e")('div'), 'a', {
            get: function () {
              return 7;
            }
          }).a != 7;
        });
        /***/
      },

      /***/
      "c8ba":
      /***/
      function (module, exports) {
        var g; // This works in non-strict mode

        g = function () {
          return this;
        }();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === "object") g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}


        module.exports = g;
        /***/
      },

      /***/
      "ca5a":
      /***/
      function (module, exports) {
        var id = 0;
        var px = Math.random();

        module.exports = function (key) {
          return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
        };
        /***/

      },

      /***/
      "cadf":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict";

        var addToUnscopables = __webpack_require__("9c6c");

        var step = __webpack_require__("d53b");

        var Iterators = __webpack_require__("84f2");

        var toIObject = __webpack_require__("6821"); // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()


        module.exports = __webpack_require__("01f9")(Array, 'Array', function (iterated, kind) {
          this._t = toIObject(iterated); // target

          this._i = 0; // next index

          this._k = kind; // kind
          // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var kind = this._k;
          var index = this._i++;

          if (!O || index >= O.length) {
            this._t = undefined;
            return step(1);
          }

          if (kind == 'keys') return step(0, index);
          if (kind == 'values') return step(0, O[index]);
          return step(0, [index, O[index]]);
        }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

        Iterators.Arguments = Iterators.Array;
        addToUnscopables('keys');
        addToUnscopables('values');
        addToUnscopables('entries');
        /***/
      },

      /***/
      "cb7c":
      /***/
      function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");

        module.exports = function (it) {
          if (!isObject(it)) throw TypeError(it + ' is not an object!');
          return it;
        };
        /***/

      },

      /***/
      "ce10":
      /***/
      function (module, exports, __webpack_require__) {
        var has = __webpack_require__("69a8");

        var toIObject = __webpack_require__("6821");

        var arrayIndexOf = __webpack_require__("c366")(false);

        var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

        module.exports = function (object, names) {
          var O = toIObject(object);
          var i = 0;
          var result = [];
          var key;

          for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


          while (names.length > i) if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }

          return result;
        };
        /***/

      },

      /***/
      "d2c8":
      /***/
      function (module, exports, __webpack_require__) {
        // helper for String#{startsWith, endsWith, includes}
        var isRegExp = __webpack_require__("aae3");

        var defined = __webpack_require__("be13");

        module.exports = function (that, searchString, NAME) {
          if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
          return String(defined(that));
        };
        /***/

      },

      /***/
      "d3f4":
      /***/
      function (module, exports) {
        module.exports = function (it) {
          return typeof it === 'object' ? it !== null : typeof it === 'function';
        };
        /***/

      },

      /***/
      "d53b":
      /***/
      function (module, exports) {
        module.exports = function (done, value) {
          return {
            value: value,
            done: !!done
          };
        };
        /***/

      },

      /***/
      "d8e8":
      /***/
      function (module, exports) {
        module.exports = function (it) {
          if (typeof it != 'function') throw TypeError(it + ' is not a function!');
          return it;
        };
        /***/

      },

      /***/
      "e11e":
      /***/
      function (module, exports) {
        // IE 8- don't enum bug keys
        module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
        /***/
      },

      /***/
      "f559":
      /***/
      function (module, exports, __webpack_require__) {
        "use strict"; // 21.1.3.18 String.prototype.startsWith(searchString [, position ])

        var $export = __webpack_require__("5ca1");

        var toLength = __webpack_require__("9def");

        var context = __webpack_require__("d2c8");

        var STARTS_WITH = 'startsWith';
        var $startsWith = ''[STARTS_WITH];
        $export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
          startsWith: function startsWith(searchString
          /* , position = 0 */
          ) {
            var that = context(this, searchString, STARTS_WITH);
            var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
            var search = String(searchString);
            return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
          }
        });
        /***/
      },

      /***/
      "f6fd":
      /***/
      function (module, exports) {
        // document.currentScript polyfill by Adam Miller
        // MIT license
        (function (document) {
          var currentScript = "currentScript",
              scripts = document.getElementsByTagName('script'); // Live NodeList collection
          // If browser needs currentScript polyfill, add get currentScript() to the document object

          if (!(currentScript in document)) {
            Object.defineProperty(document, currentScript, {
              get: function () {
                // IE 6-10 supports script readyState
                // IE 10+ support stack trace
                try {
                  throw new Error();
                } catch (err) {
                  // Find the second match for the "at" string to get file src url from stack.
                  // Specifically works with the format of stack traces in IE.
                  var i,
                      res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1]; // For all scripts on the page, if src matches or if ready state is interactive, return the script tag

                  for (i in scripts) {
                    if (scripts[i].src == res || scripts[i].readyState == "interactive") {
                      return scripts[i];
                    }
                  } // If no match, return null


                  return null;
                }
              }
            });
          }
        })(document);
        /***/

      },

      /***/
      "f751":
      /***/
      function (module, exports, __webpack_require__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __webpack_require__("5ca1");

        $export($export.S + $export.F, 'Object', {
          assign: __webpack_require__("7333")
        });
        /***/
      },

      /***/
      "fa5b":
      /***/
      function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);
        /***/
      },

      /***/
      "fab2":
      /***/
      function (module, exports, __webpack_require__) {
        var document = __webpack_require__("7726").document;

        module.exports = document && document.documentElement;
        /***/
      },

      /***/
      "fb15":
      /***/
      function (module, __webpack_exports__, __webpack_require__) {
        "use strict"; // ESM COMPAT FLAG

        __webpack_require__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
        // This file is imported into lib/wc client bundles.


        if (typeof window !== 'undefined') {
          if (true) {
            __webpack_require__("f6fd");
          }

          var setPublicPath_i;

          if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
            __webpack_require__.p = setPublicPath_i[1]; // eslint-disable-line
          }
        } // Indicate to webpack that this file can be concatenated

        /* harmony default export */


        var setPublicPath = null; // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js

        var es6_object_assign = __webpack_require__("f751"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js


        var es6_string_starts_with = __webpack_require__("f559"); // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js


        var web_dom_iterable = __webpack_require__("ac6a"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js


        var es6_array_iterator = __webpack_require__("cadf"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js


        var es6_object_keys = __webpack_require__("456d"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js


        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js


        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js


        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js


        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js


        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js


        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        } // EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js


        var es7_array_includes = __webpack_require__("6762"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js


        var es6_string_includes = __webpack_require__("2fdb"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js


        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js


        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js


        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js


        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        } // EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}


        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");

        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_); // EXTERNAL MODULE: ./src/util/helper.js


        var helper = __webpack_require__("c649"); // CONCATENATED MODULE: ./src/vuedraggable.js


        function buildAttribute(object, propName, value) {
          if (value === undefined) {
            return object;
          }

          object = object || {};
          object[propName] = value;
          return object;
        }

        function computeVmIndex(vnodes, element) {
          return vnodes.map(function (elt) {
            return elt.elm;
          }).indexOf(element);
        }

        function _computeIndexes(slots, children, isTransition, footerOffset) {
          if (!slots) {
            return [];
          }

          var elmFromNodes = slots.map(function (elt) {
            return elt.elm;
          });
          var footerIndex = children.length - footerOffset;

          var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
            return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
          });

          return isTransition ? rawIndexes.filter(function (ind) {
            return ind !== -1;
          }) : rawIndexes;
        }

        function emit(evtName, evtData) {
          var _this = this;

          this.$nextTick(function () {
            return _this.$emit(evtName.toLowerCase(), evtData);
          });
        }

        function delegateAndEmit(evtName) {
          var _this2 = this;

          return function (evtData) {
            if (_this2.realList !== null) {
              _this2["onDrag" + evtName](evtData);
            }

            emit.call(_this2, evtName, evtData);
          };
        }

        function isTransitionName(name) {
          return ["transition-group", "TransitionGroup"].includes(name);
        }

        function vuedraggable_isTransition(slots) {
          if (!slots || slots.length !== 1) {
            return false;
          }

          var _slots = _slicedToArray(slots, 1),
              componentOptions = _slots[0].componentOptions;

          if (!componentOptions) {
            return false;
          }

          return isTransitionName(componentOptions.tag);
        }

        function getSlot(slot, scopedSlot, key) {
          return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);
        }

        function computeChildrenAndOffsets(children, slot, scopedSlot) {
          var headerOffset = 0;
          var footerOffset = 0;
          var header = getSlot(slot, scopedSlot, "header");

          if (header) {
            headerOffset = header.length;
            children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
          }

          var footer = getSlot(slot, scopedSlot, "footer");

          if (footer) {
            footerOffset = footer.length;
            children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
          }

          return {
            children: children,
            headerOffset: headerOffset,
            footerOffset: footerOffset
          };
        }

        function getComponentAttributes($attrs, componentData) {
          var attributes = null;

          var update = function update(name, value) {
            attributes = buildAttribute(attributes, name, value);
          };

          var attrs = Object.keys($attrs).filter(function (key) {
            return key === "id" || key.startsWith("data-");
          }).reduce(function (res, key) {
            res[key] = $attrs[key];
            return res;
          }, {});
          update("attrs", attrs);

          if (!componentData) {
            return attributes;
          }

          var on = componentData.on,
              props = componentData.props,
              componentDataAttrs = componentData.attrs;
          update("on", on);
          update("props", props);
          Object.assign(attributes.attrs, componentDataAttrs);
          return attributes;
        }

        var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
        var eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
        var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
          return "on" + evt;
        });
        var draggingElement = null;
        var props = {
          options: Object,
          list: {
            type: Array,
            required: false,
            default: null
          },
          value: {
            type: Array,
            required: false,
            default: null
          },
          noTransitionOnDrag: {
            type: Boolean,
            default: false
          },
          clone: {
            type: Function,
            default: function _default(original) {
              return original;
            }
          },
          element: {
            type: String,
            default: "div"
          },
          tag: {
            type: String,
            default: null
          },
          move: {
            type: Function,
            default: null
          },
          componentData: {
            type: Object,
            required: false,
            default: null
          }
        };
        var draggableComponent = {
          name: "draggable",
          inheritAttrs: false,
          props: props,
          data: function data() {
            return {
              transitionMode: false,
              noneFunctionalComponentMode: false
            };
          },
          render: function render(h) {
            var slots = this.$slots.default;
            this.transitionMode = vuedraggable_isTransition(slots);

            var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),
                children = _computeChildrenAndOf.children,
                headerOffset = _computeChildrenAndOf.headerOffset,
                footerOffset = _computeChildrenAndOf.footerOffset;

            this.headerOffset = headerOffset;
            this.footerOffset = footerOffset;
            var attributes = getComponentAttributes(this.$attrs, this.componentData);
            return h(this.getTag(), attributes, children);
          },
          created: function created() {
            if (this.list !== null && this.value !== null) {
              helper["b"
              /* console */
              ].error("Value and list props are mutually exclusive! Please set one or another.");
            }

            if (this.element !== "div") {
              helper["b"
              /* console */
              ].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
            }

            if (this.options !== undefined) {
              helper["b"
              /* console */
              ].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
            }
          },
          mounted: function mounted() {
            var _this3 = this;

            this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();

            if (this.noneFunctionalComponentMode && this.transitionMode) {
              throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
            }

            var optionsAdded = {};
            eventsListened.forEach(function (elt) {
              optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
            });
            eventsToEmit.forEach(function (elt) {
              optionsAdded["on" + elt] = emit.bind(_this3, elt);
            });
            var attributes = Object.keys(this.$attrs).reduce(function (res, key) {
              res[Object(helper["a"
              /* camelize */
              ])(key)] = _this3.$attrs[key];
              return res;
            }, {});
            var options = Object.assign({}, this.options, attributes, optionsAdded, {
              onMove: function onMove(evt, originalEvent) {
                return _this3.onDragMove(evt, originalEvent);
              }
            });
            !("draggable" in options) && (options.draggable = ">*");
            this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
            this.computeIndexes();
          },
          beforeDestroy: function beforeDestroy() {
            if (this._sortable !== undefined) this._sortable.destroy();
          },
          computed: {
            rootContainer: function rootContainer() {
              return this.transitionMode ? this.$el.children[0] : this.$el;
            },
            realList: function realList() {
              return this.list ? this.list : this.value;
            }
          },
          watch: {
            options: {
              handler: function handler(newOptionValue) {
                this.updateOptions(newOptionValue);
              },
              deep: true
            },
            $attrs: {
              handler: function handler(newOptionValue) {
                this.updateOptions(newOptionValue);
              },
              deep: true
            },
            realList: function realList() {
              this.computeIndexes();
            }
          },
          methods: {
            getIsFunctional: function getIsFunctional() {
              var fnOptions = this._vnode.fnOptions;
              return fnOptions && fnOptions.functional;
            },
            getTag: function getTag() {
              return this.tag || this.element;
            },
            updateOptions: function updateOptions(newOptionValue) {
              for (var property in newOptionValue) {
                var value = Object(helper["a"
                /* camelize */
                ])(property);

                if (readonlyProperties.indexOf(value) === -1) {
                  this._sortable.option(value, newOptionValue[property]);
                }
              }
            },
            getChildrenNodes: function getChildrenNodes() {
              if (this.noneFunctionalComponentMode) {
                return this.$children[0].$slots.default;
              }

              var rawNodes = this.$slots.default;
              return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;
            },
            computeIndexes: function computeIndexes() {
              var _this4 = this;

              this.$nextTick(function () {
                _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
              });
            },
            getUnderlyingVm: function getUnderlyingVm(htmlElt) {
              var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

              if (index === -1) {
                //Edge case during move callback: related element might be
                //an element different from collection
                return null;
              }

              var element = this.realList[index];
              return {
                index: index,
                element: element
              };
            },
            getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {
              var vue = _ref.__vue__;

              if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {
                if (!("realList" in vue) && vue.$children.length === 1 && "realList" in vue.$children[0]) return vue.$children[0];
                return vue;
              }

              return vue.$parent;
            },
            emitChanges: function emitChanges(evt) {
              var _this5 = this;

              this.$nextTick(function () {
                _this5.$emit("change", evt);
              });
            },
            alterList: function alterList(onList) {
              if (this.list) {
                onList(this.list);
                return;
              }

              var newList = _toConsumableArray(this.value);

              onList(newList);
              this.$emit("input", newList);
            },
            spliceList: function spliceList() {
              var _arguments = arguments;

              var spliceList = function spliceList(list) {
                return list.splice.apply(list, _toConsumableArray(_arguments));
              };

              this.alterList(spliceList);
            },
            updatePosition: function updatePosition(oldIndex, newIndex) {
              var updatePosition = function updatePosition(list) {
                return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
              };

              this.alterList(updatePosition);
            },
            getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {
              var to = _ref2.to,
                  related = _ref2.related;
              var component = this.getUnderlyingPotencialDraggableComponent(to);

              if (!component) {
                return {
                  component: component
                };
              }

              var list = component.realList;
              var context = {
                list: list,
                component: component
              };

              if (to !== related && list && component.getUnderlyingVm) {
                var destination = component.getUnderlyingVm(related);

                if (destination) {
                  return Object.assign(destination, context);
                }
              }

              return context;
            },
            getVmIndex: function getVmIndex(domIndex) {
              var indexes = this.visibleIndexes;
              var numberIndexes = indexes.length;
              return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
            },
            getComponent: function getComponent() {
              return this.$slots.default[0].componentInstance;
            },
            resetTransitionData: function resetTransitionData(index) {
              if (!this.noTransitionOnDrag || !this.transitionMode) {
                return;
              }

              var nodes = this.getChildrenNodes();
              nodes[index].data = null;
              var transitionContainer = this.getComponent();
              transitionContainer.children = [];
              transitionContainer.kept = undefined;
            },
            onDragStart: function onDragStart(evt) {
              this.context = this.getUnderlyingVm(evt.item);
              evt.item._underlying_vm_ = this.clone(this.context.element);
              draggingElement = evt.item;
            },
            onDragAdd: function onDragAdd(evt) {
              var element = evt.item._underlying_vm_;

              if (element === undefined) {
                return;
              }

              Object(helper["d"
              /* removeNode */
              ])(evt.item);
              var newIndex = this.getVmIndex(evt.newIndex);
              this.spliceList(newIndex, 0, element);
              this.computeIndexes();
              var added = {
                element: element,
                newIndex: newIndex
              };
              this.emitChanges({
                added: added
              });
            },
            onDragRemove: function onDragRemove(evt) {
              Object(helper["c"
              /* insertNodeAt */
              ])(this.rootContainer, evt.item, evt.oldIndex);

              if (evt.pullMode === "clone") {
                Object(helper["d"
                /* removeNode */
                ])(evt.clone);
                return;
              }

              var oldIndex = this.context.index;
              this.spliceList(oldIndex, 1);
              var removed = {
                element: this.context.element,
                oldIndex: oldIndex
              };
              this.resetTransitionData(oldIndex);
              this.emitChanges({
                removed: removed
              });
            },
            onDragUpdate: function onDragUpdate(evt) {
              Object(helper["d"
              /* removeNode */
              ])(evt.item);
              Object(helper["c"
              /* insertNodeAt */
              ])(evt.from, evt.item, evt.oldIndex);
              var oldIndex = this.context.index;
              var newIndex = this.getVmIndex(evt.newIndex);
              this.updatePosition(oldIndex, newIndex);
              var moved = {
                element: this.context.element,
                oldIndex: oldIndex,
                newIndex: newIndex
              };
              this.emitChanges({
                moved: moved
              });
            },
            updateProperty: function updateProperty(evt, propertyName) {
              evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
            },
            computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
              if (!relatedContext.element) {
                return 0;
              }

              var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
                return el.style["display"] !== "none";
              });

              var currentDOMIndex = domChildren.indexOf(evt.related);
              var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
              var draggedInList = domChildren.indexOf(draggingElement) !== -1;
              return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
            },
            onDragMove: function onDragMove(evt, originalEvent) {
              var onMove = this.move;

              if (!onMove || !this.realList) {
                return true;
              }

              var relatedContext = this.getRelatedContextFromMoveEvent(evt);
              var draggedContext = this.context;
              var futureIndex = this.computeFutureIndex(relatedContext, evt);
              Object.assign(draggedContext, {
                futureIndex: futureIndex
              });
              var sendEvt = Object.assign({}, evt, {
                relatedContext: relatedContext,
                draggedContext: draggedContext
              });
              return onMove(sendEvt, originalEvent);
            },
            onDragEnd: function onDragEnd() {
              this.computeIndexes();
              draggingElement = null;
            }
          }
        };

        if (typeof window !== "undefined" && "Vue" in window) {
          window.Vue.component("draggable", draggableComponent);
        }
        /* harmony default export */


        var vuedraggable = draggableComponent; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

        /* harmony default export */

        var entry_lib = __webpack_exports__["default"] = vuedraggable;
        /***/
      }
      /******/

    })["default"]
  );
});

/***/ }),
/* 38 */
/***/ (function(module) {

module.exports = JSON.parse("{\"en-US\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><locale xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" version=\\\"1.0\\\" xml:lang=\\\"en-US\\\"><info><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights><updated>2015-10-10T23:31:02+00:00</updated></info><style-options punctuation-in-quote=\\\"true\\\"/><date form=\\\"text\\\"><date-part name=\\\"month\\\" suffix=\\\" \\\"/><date-part name=\\\"day\\\" suffix=\\\", \\\"/><date-part name=\\\"year\\\"/></date><date form=\\\"numeric\\\"><date-part name=\\\"month\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\"/\\\"/><date-part name=\\\"day\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\"/\\\"/><date-part name=\\\"year\\\"/></date><terms><term name=\\\"accessed\\\">accessed</term><term name=\\\"and\\\">and</term><term name=\\\"and others\\\">and others</term><term name=\\\"anonymous\\\">anonymous</term><term name=\\\"anonymous\\\" form=\\\"short\\\">anon.</term><term name=\\\"at\\\">at</term><term name=\\\"available at\\\">available at</term><term name=\\\"by\\\">by</term><term name=\\\"circa\\\">circa</term><term name=\\\"circa\\\" form=\\\"short\\\">c.</term><term name=\\\"cited\\\">cited</term><term name=\\\"edition\\\"><single>edition</single><multiple>editions</multiple></term><term name=\\\"edition\\\" form=\\\"short\\\">ed.</term><term name=\\\"et-al\\\">et al.</term><term name=\\\"forthcoming\\\">forthcoming</term><term name=\\\"from\\\">from</term><term name=\\\"ibid\\\">ibid.</term><term name=\\\"in\\\">in</term><term name=\\\"in press\\\">in press</term><term name=\\\"internet\\\">internet</term><term name=\\\"interview\\\">interview</term><term name=\\\"letter\\\">letter</term><term name=\\\"no date\\\">no date</term><term name=\\\"no date\\\" form=\\\"short\\\">n.d.</term><term name=\\\"online\\\">online</term><term name=\\\"presented at\\\">presented at the</term><term name=\\\"reference\\\"><single>reference</single><multiple>references</multiple></term><term name=\\\"reference\\\" form=\\\"short\\\"><single>ref.</single><multiple>refs.</multiple></term><term name=\\\"retrieved\\\">retrieved</term><term name=\\\"scale\\\">scale</term><term name=\\\"version\\\">version</term><term name=\\\"ad\\\">AD</term><term name=\\\"bc\\\">BC</term><term name=\\\"open-quote\\\">“</term><term name=\\\"close-quote\\\">”</term><term name=\\\"open-inner-quote\\\">‘</term><term name=\\\"close-inner-quote\\\">’</term><term name=\\\"page-range-delimiter\\\">–</term><term name=\\\"ordinal\\\">th</term><term name=\\\"ordinal-01\\\">st</term><term name=\\\"ordinal-02\\\">nd</term><term name=\\\"ordinal-03\\\">rd</term><term name=\\\"ordinal-11\\\">th</term><term name=\\\"ordinal-12\\\">th</term><term name=\\\"ordinal-13\\\">th</term><term name=\\\"long-ordinal-01\\\">first</term><term name=\\\"long-ordinal-02\\\">second</term><term name=\\\"long-ordinal-03\\\">third</term><term name=\\\"long-ordinal-04\\\">fourth</term><term name=\\\"long-ordinal-05\\\">fifth</term><term name=\\\"long-ordinal-06\\\">sixth</term><term name=\\\"long-ordinal-07\\\">seventh</term><term name=\\\"long-ordinal-08\\\">eighth</term><term name=\\\"long-ordinal-09\\\">ninth</term><term name=\\\"long-ordinal-10\\\">tenth</term><term name=\\\"book\\\"><single>book</single><multiple>books</multiple></term><term name=\\\"chapter\\\"><single>chapter</single><multiple>chapters</multiple></term><term name=\\\"column\\\"><single>column</single><multiple>columns</multiple></term><term name=\\\"figure\\\"><single>figure</single><multiple>figures</multiple></term><term name=\\\"folio\\\"><single>folio</single><multiple>folios</multiple></term><term name=\\\"issue\\\"><single>number</single><multiple>numbers</multiple></term><term name=\\\"line\\\"><single>line</single><multiple>lines</multiple></term><term name=\\\"note\\\"><single>note</single><multiple>notes</multiple></term><term name=\\\"opus\\\"><single>opus</single><multiple>opera</multiple></term><term name=\\\"page\\\"><single>page</single><multiple>pages</multiple></term><term name=\\\"number-of-pages\\\"><single>page</single><multiple>pages</multiple></term><term name=\\\"paragraph\\\"><single>paragraph</single><multiple>paragraphs</multiple></term><term name=\\\"part\\\"><single>part</single><multiple>parts</multiple></term><term name=\\\"section\\\"><single>section</single><multiple>sections</multiple></term><term name=\\\"sub verbo\\\"><single>sub verbo</single><multiple>sub verbis</multiple></term><term name=\\\"verse\\\"><single>verse</single><multiple>verses</multiple>\\n</term><term name=\\\"volume\\\"><single>volume</single><multiple>volumes</multiple></term><term name=\\\"book\\\" form=\\\"short\\\"><single>bk.</single><multiple>bks.</multiple></term><term name=\\\"chapter\\\" form=\\\"short\\\"><single>chap.</single><multiple>chaps.</multiple></term><term name=\\\"column\\\" form=\\\"short\\\"><single>col.</single><multiple>cols.</multiple></term><term name=\\\"figure\\\" form=\\\"short\\\"><single>fig.</single><multiple>figs.</multiple></term><term name=\\\"folio\\\" form=\\\"short\\\"><single>fol.</single><multiple>fols.</multiple></term><term name=\\\"issue\\\" form=\\\"short\\\"><single>no.</single><multiple>nos.</multiple></term><term name=\\\"line\\\" form=\\\"short\\\"><single>l.</single><multiple>ll.</multiple></term><term name=\\\"note\\\" form=\\\"short\\\"><single>n.</single><multiple>nn.</multiple></term><term name=\\\"opus\\\" form=\\\"short\\\"><single>op.</single><multiple>opp.</multiple></term><term name=\\\"page\\\" form=\\\"short\\\"><single>p.</single><multiple>pp.</multiple></term><term name=\\\"number-of-pages\\\" form=\\\"short\\\"><single>p.</single><multiple>pp.</multiple></term><term name=\\\"paragraph\\\" form=\\\"short\\\"><single>para.</single><multiple>paras.</multiple></term><term name=\\\"part\\\" form=\\\"short\\\"><single>pt.</single><multiple>pts.</multiple></term><term name=\\\"section\\\" form=\\\"short\\\"><single>sec.</single><multiple>secs.</multiple></term><term name=\\\"sub verbo\\\" form=\\\"short\\\"><single>s.v.</single><multiple>s.vv.</multiple></term><term name=\\\"verse\\\" form=\\\"short\\\"><single>v.</single><multiple>vv.</multiple></term><term name=\\\"volume\\\" form=\\\"short\\\"><single>vol.</single><multiple>vols.</multiple></term><term name=\\\"paragraph\\\" form=\\\"symbol\\\"><single>¶</single><multiple>¶¶</multiple></term><term name=\\\"section\\\" form=\\\"symbol\\\"><single>§</single><multiple>§§</multiple></term><term name=\\\"director\\\"><single>director</single><multiple>directors</multiple></term><term name=\\\"editor\\\"><single>editor</single><multiple>editors</multiple></term><term name=\\\"editorial-director\\\"><single>editor</single><multiple>editors</multiple></term><term name=\\\"illustrator\\\"><single>illustrator</single><multiple>illustrators</multiple></term><term name=\\\"translator\\\"><single>translator</single><multiple>translators</multiple></term><term name=\\\"editortranslator\\\"><single>editor &amp; translator</single><multiple>editors &amp; translators</multiple></term><term name=\\\"director\\\" form=\\\"short\\\"><single>dir.</single><multiple>dirs.</multiple></term><term name=\\\"editor\\\" form=\\\"short\\\"><single>ed.</single><multiple>eds.</multiple></term><term name=\\\"editorial-director\\\" form=\\\"short\\\"><single>ed.</single><multiple>eds.</multiple></term><term name=\\\"illustrator\\\" form=\\\"short\\\"><single>ill.</single><multiple>ills.</multiple></term><term name=\\\"translator\\\" form=\\\"short\\\"><single>tran.</single><multiple>trans.</multiple></term><term name=\\\"editortranslator\\\" form=\\\"short\\\"><single>ed. &amp; tran.</single><multiple>eds. &amp; trans.</multiple></term><term name=\\\"container-author\\\" form=\\\"verb\\\">by</term><term name=\\\"director\\\" form=\\\"verb\\\">directed by</term><term name=\\\"editor\\\" form=\\\"verb\\\">edited by</term><term name=\\\"editorial-director\\\" form=\\\"verb\\\">edited by</term><term name=\\\"illustrator\\\" form=\\\"verb\\\">illustrated by</term><term name=\\\"interviewer\\\" form=\\\"verb\\\">interview by</term><term name=\\\"recipient\\\" form=\\\"verb\\\">to</term><term name=\\\"reviewed-author\\\" form=\\\"verb\\\">by</term><term name=\\\"translator\\\" form=\\\"verb\\\">translated by</term><term name=\\\"editortranslator\\\" form=\\\"verb\\\">edited &amp; translated by</term><term name=\\\"director\\\" form=\\\"verb-short\\\">dir. by</term><term name=\\\"editor\\\" form=\\\"verb-short\\\">ed. by</term><term name=\\\"editorial-director\\\" form=\\\"verb-short\\\">ed. by</term><term name=\\\"illustrator\\\" form=\\\"verb-short\\\">illus. by</term><term name=\\\"translator\\\" form=\\\"verb-short\\\">trans. by</term><term name=\\\"editortranslator\\\" form=\\\"verb-short\\\">ed. &amp; trans. by</term><term name=\\\"month-01\\\">January</term><term name=\\\"month-02\\\">February</term><term name=\\\"month-03\\\">March</term><term name=\\\"month-04\\\">April</term><term name=\\\"month-05\\\">May</term><term name=\\\"month-06\\\">June</term><term name=\\\"month-07\\\">July</term><term name=\\\"month-08\\\">August</term><term name=\\\"month-09\\\">September</term>\\n<term name=\\\"month-10\\\">October</term><term name=\\\"month-11\\\">November</term><term name=\\\"month-12\\\">December</term><term name=\\\"month-01\\\" form=\\\"short\\\">Jan.</term><term name=\\\"month-02\\\" form=\\\"short\\\">Feb.</term><term name=\\\"month-03\\\" form=\\\"short\\\">Mar.</term><term name=\\\"month-04\\\" form=\\\"short\\\">Apr.</term><term name=\\\"month-05\\\" form=\\\"short\\\">May</term><term name=\\\"month-06\\\" form=\\\"short\\\">Jun.</term><term name=\\\"month-07\\\" form=\\\"short\\\">Jul.</term><term name=\\\"month-08\\\" form=\\\"short\\\">Aug.</term><term name=\\\"month-09\\\" form=\\\"short\\\">Sep.</term><term name=\\\"month-10\\\" form=\\\"short\\\">Oct.</term><term name=\\\"month-11\\\" form=\\\"short\\\">Nov.</term><term name=\\\"month-12\\\" form=\\\"short\\\">Dec.</term><term name=\\\"season-01\\\">Spring</term><term name=\\\"season-02\\\">Summer</term><term name=\\\"season-03\\\">Autumn</term><term name=\\\"season-04\\\">Winter</term></terms></locale>\",\"nl-NL\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><locale xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" version=\\\"1.0\\\" xml:lang=\\\"nl-NL\\\"><info><translator><name>Rintze Zelle</name><uri>http://twitter.com/rintzezelle</uri></translator><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights><updated>2012-07-04T23:31:02+00:00</updated></info><style-options punctuation-in-quote=\\\"false\\\"/><date form=\\\"text\\\"><date-part name=\\\"day\\\" suffix=\\\" \\\"/><date-part name=\\\"month\\\" suffix=\\\" \\\"/><date-part name=\\\"year\\\"/></date><date form=\\\"numeric\\\"><date-part name=\\\"day\\\" suffix=\\\"-\\\" range-delimiter=\\\"/\\\"/><date-part name=\\\"month\\\" form=\\\"numeric\\\" suffix=\\\"-\\\" range-delimiter=\\\"/\\\"/><date-part name=\\\"year\\\"/></date><terms><term name=\\\"accessed\\\">geraadpleegd</term><term name=\\\"and\\\">en</term><term name=\\\"and others\\\">en anderen</term><term name=\\\"anonymous\\\">anoniem</term><term name=\\\"anonymous\\\" form=\\\"short\\\">anon.</term><term name=\\\"at\\\">bij</term><term name=\\\"available at\\\">beschikbaar op</term><term name=\\\"by\\\">door</term><term name=\\\"circa\\\">circa</term><term name=\\\"circa\\\" form=\\\"short\\\">c.</term><term name=\\\"cited\\\">geciteerd</term><term name=\\\"edition\\\"><single>editie</single><multiple>edities</multiple></term><term name=\\\"edition\\\" form=\\\"short\\\">ed.</term><term name=\\\"et-al\\\">e.a.</term><term name=\\\"forthcoming\\\">in voorbereiding</term><term name=\\\"from\\\">van</term><term name=\\\"ibid\\\">ibid.</term><term name=\\\"in\\\">in</term><term name=\\\"in press\\\">in druk</term><term name=\\\"internet\\\">internet</term><term name=\\\"interview\\\">interview</term><term name=\\\"letter\\\">brief</term><term name=\\\"no date\\\">zonder datum</term><term name=\\\"no date\\\" form=\\\"short\\\">z.d.</term><term name=\\\"online\\\">online</term><term name=\\\"presented at\\\">gepresenteerd bij</term><term name=\\\"reference\\\"><single>referentie</single><multiple>referenties</multiple></term><term name=\\\"reference\\\" form=\\\"short\\\"><single>ref.</single><multiple>refs.</multiple></term><term name=\\\"retrieved\\\">geraadpleegd</term><term name=\\\"scale\\\">schaal</term><term name=\\\"version\\\">versie</term><term name=\\\"ad\\\">AD</term><term name=\\\"bc\\\">BC</term><term name=\\\"open-quote\\\">“</term><term name=\\\"close-quote\\\">”</term><term name=\\\"open-inner-quote\\\">‘</term><term name=\\\"close-inner-quote\\\">’</term><term name=\\\"page-range-delimiter\\\">–</term><term name=\\\"ordinal\\\">ste</term><term name=\\\"ordinal-00\\\" match=\\\"whole-number\\\">de</term><term name=\\\"ordinal-02\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-03\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-04\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-05\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-06\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-07\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-09\\\" match=\\\"last-two-digits\\\">de</term><term name=\\\"ordinal-10\\\">de</term><term name=\\\"ordinal-11\\\">de</term><term name=\\\"ordinal-12\\\">de</term><term name=\\\"ordinal-13\\\">de</term><term name=\\\"ordinal-14\\\">de</term><term name=\\\"ordinal-15\\\">de</term><term name=\\\"ordinal-16\\\">de</term><term name=\\\"ordinal-17\\\">de</term><term name=\\\"ordinal-18\\\">de</term><term name=\\\"ordinal-19\\\">de</term><term name=\\\"long-ordinal-01\\\">eerste</term><term name=\\\"long-ordinal-02\\\">tweede</term><term name=\\\"long-ordinal-03\\\">derde</term><term name=\\\"long-ordinal-04\\\">vierde</term><term name=\\\"long-ordinal-05\\\">vijfde</term><term name=\\\"long-ordinal-06\\\">zesde</term><term name=\\\"long-ordinal-07\\\">zevende</term><term name=\\\"long-ordinal-08\\\">achtste</term><term name=\\\"long-ordinal-09\\\">negende</term><term name=\\\"long-ordinal-10\\\">tiende</term><term name=\\\"book\\\"><single>boek</single><multiple>boeken</multiple></term><term name=\\\"chapter\\\"><single>hoofdstuk</single><multiple>hoofdstukken</multiple></term><term name=\\\"column\\\"><single>column</single><multiple>columns</multiple></term><term name=\\\"figure\\\"><single>figuur</single><multiple>figuren</multiple></term><term name=\\\"folio\\\"><single>folio</single><multiple>folio's</multiple></term><term name=\\\"issue\\\"><single>nummer</single><multiple>nummers</multiple></term><term name=\\\"line\\\"><single>regel</single><multiple>regels</multiple>\\n</term><term name=\\\"note\\\"><single>aantekening</single><multiple>aantekeningen</multiple></term><term name=\\\"opus\\\"><single>opus</single><multiple>opera</multiple></term><term name=\\\"page\\\"><single>pagina</single><multiple>pagina's</multiple></term><term name=\\\"number-of-pages\\\"><single>pagina</single><multiple>pagina's</multiple></term><term name=\\\"paragraph\\\"><single>paragraaf</single><multiple>paragrafen</multiple></term><term name=\\\"part\\\"><single>deel</single><multiple>delen</multiple></term><term name=\\\"section\\\"><single>sectie</single><multiple>secties</multiple></term><term name=\\\"sub verbo\\\"><single>sub verbo</single><multiple>sub verbis</multiple></term><term name=\\\"verse\\\"><single>vers</single><multiple>versen</multiple></term><term name=\\\"volume\\\"><single>volume</single><multiple>volumes</multiple></term><term name=\\\"book\\\" form=\\\"short\\\">bk.</term><term name=\\\"chapter\\\" form=\\\"short\\\">hfdst.</term><term name=\\\"column\\\" form=\\\"short\\\">col.</term><term name=\\\"figure\\\" form=\\\"short\\\">fig.</term><term name=\\\"folio\\\" form=\\\"short\\\">f.</term><term name=\\\"issue\\\" form=\\\"short\\\">nr.</term><term name=\\\"line\\\" form=\\\"short\\\">l.</term><term name=\\\"note\\\" form=\\\"short\\\">n.</term><term name=\\\"opus\\\" form=\\\"short\\\">op.</term><term name=\\\"page\\\" form=\\\"short\\\"><single>p.</single><multiple>pp.</multiple></term><term name=\\\"number-of-pages\\\" form=\\\"short\\\"><single>p.</single><multiple>pp.</multiple></term><term name=\\\"paragraph\\\" form=\\\"short\\\">par.</term><term name=\\\"part\\\" form=\\\"short\\\">deel</term><term name=\\\"section\\\" form=\\\"short\\\">sec.</term><term name=\\\"sub verbo\\\" form=\\\"short\\\"><single>s.v.</single><multiple>s.vv.</multiple></term><term name=\\\"verse\\\" form=\\\"short\\\"><single>v.</single><multiple>vv.</multiple></term><term name=\\\"volume\\\" form=\\\"short\\\"><single>vol.</single><multiple>vols.</multiple></term><term name=\\\"paragraph\\\" form=\\\"symbol\\\"><single>¶</single><multiple>¶¶</multiple></term><term name=\\\"section\\\" form=\\\"symbol\\\"><single>§</single><multiple>§§</multiple></term><term name=\\\"director\\\"><single>regisseur</single><multiple>regisseurs</multiple></term><term name=\\\"editor\\\"><single>redacteur</single><multiple>redacteuren</multiple></term><term name=\\\"editorial-director\\\"><single>redacteur</single><multiple>redacteuren</multiple></term><term name=\\\"illustrator\\\"><single>illustrator</single><multiple>illustrators</multiple></term><term name=\\\"translator\\\"><single>vertaler</single><multiple>vertalers</multiple></term><term name=\\\"editortranslator\\\"><single>redacteur &amp; vertaler</single><multiple>redacteuren &amp; vertalers</multiple></term><term name=\\\"director\\\" form=\\\"short\\\"><single>reg.</single><multiple>reg.</multiple></term><term name=\\\"editor\\\" form=\\\"short\\\"><single>red.</single><multiple>red.</multiple></term><term name=\\\"editorial-director\\\" form=\\\"short\\\"><single>red.</single><multiple>red.</multiple></term><term name=\\\"illustrator\\\" form=\\\"short\\\"><single>ill.</single><multiple>ill.</multiple></term><term name=\\\"translator\\\" form=\\\"short\\\"><single>vert.</single><multiple>vert.</multiple></term><term name=\\\"editortranslator\\\" form=\\\"short\\\"><single>red. &amp; vert.</single><multiple>red. &amp; vert.</multiple></term><term name=\\\"container-author\\\" form=\\\"verb\\\">door</term><term name=\\\"director\\\" form=\\\"verb\\\">geregisseerd door</term><term name=\\\"editor\\\" form=\\\"verb\\\">bewerkt door</term><term name=\\\"editorial-director\\\" form=\\\"verb\\\">bewerkt door</term><term name=\\\"illustrator\\\" form=\\\"verb\\\">geïllustreerd door</term><term name=\\\"interviewer\\\" form=\\\"verb\\\">geïnterviewd door</term><term name=\\\"recipient\\\" form=\\\"verb\\\">ontvangen door</term><term name=\\\"reviewed-author\\\" form=\\\"verb\\\">door</term><term name=\\\"translator\\\" form=\\\"verb\\\">vertaald door</term><term name=\\\"editortranslator\\\" form=\\\"verb\\\">bewerkt &amp; vertaald door</term><term name=\\\"director\\\" form=\\\"verb-short\\\">geregisseerd door</term><term name=\\\"editor\\\" form=\\\"verb-short\\\">bewerkt door</term><term name=\\\"editorial-director\\\" form=\\\"verb-short\\\">bewerkt door</term><term name=\\\"illustrator\\\" form=\\\"verb-short\\\">geïllustreerd door</term><term name=\\\"translator\\\" form=\\\"verb-short\\\">vertaald door</term><term name=\\\"editortranslator\\\" form=\\\"verb-short\\\">bewerkt &amp; vertaald door</term>\\n<term name=\\\"month-01\\\">januari</term><term name=\\\"month-02\\\">februari</term><term name=\\\"month-03\\\">maart</term><term name=\\\"month-04\\\">april</term><term name=\\\"month-05\\\">mei</term><term name=\\\"month-06\\\">juni</term><term name=\\\"month-07\\\">juli</term><term name=\\\"month-08\\\">augustus</term><term name=\\\"month-09\\\">september</term><term name=\\\"month-10\\\">oktober</term><term name=\\\"month-11\\\">november</term><term name=\\\"month-12\\\">december</term><term name=\\\"month-01\\\" form=\\\"short\\\">jan.</term><term name=\\\"month-02\\\" form=\\\"short\\\">feb.</term><term name=\\\"month-03\\\" form=\\\"short\\\">mrt.</term><term name=\\\"month-04\\\" form=\\\"short\\\">apr.</term><term name=\\\"month-05\\\" form=\\\"short\\\">mei</term><term name=\\\"month-06\\\" form=\\\"short\\\">jun.</term><term name=\\\"month-07\\\" form=\\\"short\\\">jul.</term><term name=\\\"month-08\\\" form=\\\"short\\\">aug.</term><term name=\\\"month-09\\\" form=\\\"short\\\">sep.</term><term name=\\\"month-10\\\" form=\\\"short\\\">okt.</term><term name=\\\"month-11\\\" form=\\\"short\\\">nov.</term><term name=\\\"month-12\\\" form=\\\"short\\\">dec.</term><term name=\\\"season-01\\\">lente</term><term name=\\\"season-02\\\">zomer</term><term name=\\\"season-03\\\">herst</term><term name=\\\"season-04\\\">winter</term></terms></locale>\",\"fr-FR\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><locale xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" version=\\\"1.0\\\" xml:lang=\\\"fr-FR\\\"><info><translator><name>Grégoire Colly</name></translator><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights><updated>2012-07-04T23:31:02+00:00</updated></info><style-options punctuation-in-quote=\\\"false\\\" limit-day-ordinals-to-day-1=\\\"true\\\"/><date form=\\\"text\\\"><date-part name=\\\"day\\\" suffix=\\\" \\\"/><date-part name=\\\"month\\\" suffix=\\\" \\\"/><date-part name=\\\"year\\\"/></date><date form=\\\"numeric\\\"><date-part name=\\\"day\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\"/\\\"/><date-part name=\\\"month\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\"/\\\"/><date-part name=\\\"year\\\"/></date><terms><term name=\\\"accessed\\\">consulté le</term><term name=\\\"and\\\">et</term><term name=\\\"and others\\\">et autres</term><term name=\\\"anonymous\\\">anonyme</term><term name=\\\"anonymous\\\" form=\\\"short\\\">anon.</term><term name=\\\"at\\\">sur</term><term name=\\\"available at\\\">disponible sur</term><term name=\\\"by\\\">par</term><term name=\\\"circa\\\">vers</term><term name=\\\"circa\\\" form=\\\"short\\\">v.</term><term name=\\\"cited\\\">cité</term><term name=\\\"edition\\\" gender=\\\"feminine\\\"><single>édition</single><multiple>éditions</multiple></term><term name=\\\"edition\\\" form=\\\"short\\\">éd.</term><term name=\\\"et-al\\\">et al.</term><term name=\\\"forthcoming\\\">à paraître</term><term name=\\\"from\\\">à l'adresse</term><term name=\\\"ibid\\\">ibid.</term><term name=\\\"in\\\">in</term><term name=\\\"in press\\\">sous presse</term><term name=\\\"internet\\\">Internet</term><term name=\\\"interview\\\">entretien</term><term name=\\\"letter\\\">lettre</term><term name=\\\"no date\\\">sans date</term><term name=\\\"no date\\\" form=\\\"short\\\">s.&#160;d.</term><term name=\\\"online\\\">en ligne</term><term name=\\\"presented at\\\">présenté à</term><term name=\\\"reference\\\"><single>référence</single><multiple>références</multiple></term><term name=\\\"reference\\\" form=\\\"short\\\"><single>réf.</single><multiple>réf.</multiple></term><term name=\\\"retrieved\\\">consulté</term><term name=\\\"scale\\\">échelle</term><term name=\\\"version\\\">version</term><term name=\\\"ad\\\">apr. J.-C.</term><term name=\\\"bc\\\">av. J.-C.</term><term name=\\\"open-quote\\\">«&#160;</term><term name=\\\"close-quote\\\">&#160;»</term><term name=\\\"open-inner-quote\\\">“</term><term name=\\\"close-inner-quote\\\">”</term><term name=\\\"page-range-delimiter\\\">&#8209;</term><term name=\\\"ordinal\\\">ᵉ</term><term name=\\\"ordinal-01\\\" gender-form=\\\"feminine\\\" match=\\\"whole-number\\\">ʳᵉ</term><term name=\\\"ordinal-01\\\" gender-form=\\\"masculine\\\" match=\\\"whole-number\\\">ᵉʳ</term><term name=\\\"long-ordinal-01\\\">premier</term><term name=\\\"long-ordinal-02\\\">deuxième</term><term name=\\\"long-ordinal-03\\\">troisième</term><term name=\\\"long-ordinal-04\\\">quatrième</term><term name=\\\"long-ordinal-05\\\">cinquième</term><term name=\\\"long-ordinal-06\\\">sixième</term><term name=\\\"long-ordinal-07\\\">septième</term><term name=\\\"long-ordinal-08\\\">huitième</term><term name=\\\"long-ordinal-09\\\">neuvième</term><term name=\\\"long-ordinal-10\\\">dixième</term><term name=\\\"book\\\"><single>livre</single><multiple>livres</multiple></term><term name=\\\"chapter\\\"><single>chapitre</single><multiple>chapitres</multiple></term><term name=\\\"column\\\"><single>colonne</single><multiple>colonnes</multiple></term><term name=\\\"figure\\\"><single>figure</single><multiple>figures</multiple></term><term name=\\\"folio\\\"><single>folio</single><multiple>folios</multiple></term><term name=\\\"issue\\\" gender=\\\"masculine\\\"><single>numéro</single><multiple>numéros</multiple></term><term name=\\\"line\\\"><single>ligne</single><multiple>lignes</multiple></term><term name=\\\"note\\\"><single>note</single><multiple>notes</multiple></term><term name=\\\"opus\\\"><single>opus</single><multiple>opus</multiple></term><term name=\\\"page\\\"><single>page</single><multiple>pages</multiple></term><term name=\\\"number-of-pages\\\"><single>page</single><multiple>pages</multiple></term><term name=\\\"paragraph\\\"><single>paragraphe</single><multiple>paragraphes</multiple></term><term name=\\\"part\\\"><single>partie</single><multiple>parties</multiple></term><term name=\\\"section\\\"><single>section</single><multiple>sections</multiple>\\n</term><term name=\\\"sub verbo\\\"><single>sub verbo</single><multiple>sub verbis</multiple></term><term name=\\\"verse\\\"><single>verset</single><multiple>versets</multiple></term><term name=\\\"volume\\\" gender=\\\"masculine\\\"><single>volume</single><multiple>volumes</multiple></term><term name=\\\"book\\\" form=\\\"short\\\">liv.</term><term name=\\\"chapter\\\" form=\\\"short\\\">chap.</term><term name=\\\"column\\\" form=\\\"short\\\">col.</term><term name=\\\"figure\\\" form=\\\"short\\\">fig.</term><term name=\\\"folio\\\" form=\\\"short\\\"><single>fᵒ</single><multiple>fᵒˢ</multiple></term><term name=\\\"issue\\\" form=\\\"short\\\"><single>nᵒ</single><multiple>nᵒˢ</multiple></term><term name=\\\"line\\\" form=\\\"short\\\">l.</term><term name=\\\"note\\\" form=\\\"short\\\">n.</term><term name=\\\"opus\\\" form=\\\"short\\\">op.</term><term name=\\\"page\\\" form=\\\"short\\\"><single>p.</single><multiple>p.</multiple></term><term name=\\\"number-of-pages\\\" form=\\\"short\\\"><single>p.</single><multiple>p.</multiple></term><term name=\\\"paragraph\\\" form=\\\"short\\\">paragr.</term><term name=\\\"part\\\" form=\\\"short\\\">part.</term><term name=\\\"section\\\" form=\\\"short\\\">sect.</term><term name=\\\"sub verbo\\\" form=\\\"short\\\"><single>s.&#160;v.</single><multiple>s.&#160;vv.</multiple></term><term name=\\\"verse\\\" form=\\\"short\\\"><single>v.</single><multiple>v.</multiple></term><term name=\\\"volume\\\" form=\\\"short\\\"><single>vol.</single><multiple>vol.</multiple></term><term name=\\\"paragraph\\\" form=\\\"symbol\\\"><single>§</single><multiple>§</multiple></term><term name=\\\"section\\\" form=\\\"symbol\\\"><single>§</single><multiple>§</multiple></term><term name=\\\"director\\\"><single>réalisateur</single><multiple>réalisateurs</multiple></term><term name=\\\"editor\\\"><single>éditeur</single><multiple>éditeurs</multiple></term><term name=\\\"editorial-director\\\"><single>directeur</single><multiple>directeurs</multiple></term><term name=\\\"illustrator\\\"><single>illustrateur</single><multiple>illustrateurs</multiple></term><term name=\\\"translator\\\"><single>traducteur</single><multiple>traducteurs</multiple></term><term name=\\\"editortranslator\\\"><single>éditeur et traducteur</single><multiple>éditeurs et traducteurs</multiple></term><term name=\\\"director\\\" form=\\\"short\\\"><single>réal.</single><multiple>réal.</multiple></term><term name=\\\"editor\\\" form=\\\"short\\\"><single>éd.</single><multiple>éd.</multiple></term><term name=\\\"editorial-director\\\" form=\\\"short\\\"><single>dir.</single><multiple>dir.</multiple></term><term name=\\\"illustrator\\\" form=\\\"short\\\"><single>ill.</single><multiple>ill.</multiple></term><term name=\\\"translator\\\" form=\\\"short\\\"><single>trad.</single><multiple>trad.</multiple></term><term name=\\\"editortranslator\\\" form=\\\"short\\\"><single>éd. et trad.</single><multiple>éd. et trad.</multiple></term><term name=\\\"container-author\\\" form=\\\"verb\\\">par</term><term name=\\\"director\\\" form=\\\"verb\\\">réalisé par</term><term name=\\\"editor\\\" form=\\\"verb\\\">édité par</term><term name=\\\"editorial-director\\\" form=\\\"verb\\\">sous la direction de</term><term name=\\\"illustrator\\\" form=\\\"verb\\\">illustré par</term><term name=\\\"interviewer\\\" form=\\\"verb\\\">entretien réalisé par</term><term name=\\\"recipient\\\" form=\\\"verb\\\">à</term><term name=\\\"reviewed-author\\\" form=\\\"verb\\\">par</term><term name=\\\"translator\\\" form=\\\"verb\\\">traduit par</term><term name=\\\"editortranslator\\\" form=\\\"verb\\\">édité et traduit par</term><term name=\\\"director\\\" form=\\\"verb-short\\\">réal. par</term><term name=\\\"editor\\\" form=\\\"verb-short\\\">éd. par</term><term name=\\\"editorial-director\\\" form=\\\"verb-short\\\">ss la dir. de</term><term name=\\\"illustrator\\\" form=\\\"verb-short\\\">ill. par</term><term name=\\\"translator\\\" form=\\\"verb-short\\\">trad. par</term><term name=\\\"editortranslator\\\" form=\\\"verb-short\\\">éd. et trad. par</term><term name=\\\"month-01\\\" gender=\\\"masculine\\\">janvier</term><term name=\\\"month-02\\\" gender=\\\"masculine\\\">février</term><term name=\\\"month-03\\\" gender=\\\"masculine\\\">mars</term><term name=\\\"month-04\\\" gender=\\\"masculine\\\">avril</term><term name=\\\"month-05\\\" gender=\\\"masculine\\\">mai</term><term name=\\\"month-06\\\" gender=\\\"masculine\\\">juin</term><term name=\\\"month-07\\\" gender=\\\"masculine\\\">juillet</term><term name=\\\"month-08\\\" gender=\\\"masculine\\\">août</term><term name=\\\"month-09\\\" gender=\\\"masculine\\\">septembre</term><term name=\\\"month-10\\\" gender=\\\"masculine\\\">\\noctobre</term><term name=\\\"month-11\\\" gender=\\\"masculine\\\">novembre</term><term name=\\\"month-12\\\" gender=\\\"masculine\\\">décembre</term><term name=\\\"month-01\\\" form=\\\"short\\\">janv.</term><term name=\\\"month-02\\\" form=\\\"short\\\">févr.</term><term name=\\\"month-03\\\" form=\\\"short\\\">mars</term><term name=\\\"month-04\\\" form=\\\"short\\\">avr.</term><term name=\\\"month-05\\\" form=\\\"short\\\">mai</term><term name=\\\"month-06\\\" form=\\\"short\\\">juin</term><term name=\\\"month-07\\\" form=\\\"short\\\">juill.</term><term name=\\\"month-08\\\" form=\\\"short\\\">août</term><term name=\\\"month-09\\\" form=\\\"short\\\">sept.</term><term name=\\\"month-10\\\" form=\\\"short\\\">oct.</term><term name=\\\"month-11\\\" form=\\\"short\\\">nov.</term><term name=\\\"month-12\\\" form=\\\"short\\\">déc.</term><term name=\\\"season-01\\\">printemps</term><term name=\\\"season-02\\\">été</term><term name=\\\"season-03\\\">automne</term><term name=\\\"season-04\\\">hiver</term></terms></locale>\",\"de-DE\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><locale xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" version=\\\"1.0\\\" xml:lang=\\\"de-DE\\\"><info><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights><updated>2012-07-04T23:31:02+00:00</updated></info><style-options punctuation-in-quote=\\\"false\\\"/><date form=\\\"text\\\"><date-part name=\\\"day\\\" form=\\\"ordinal\\\" suffix=\\\" \\\"/><date-part name=\\\"month\\\" suffix=\\\" \\\"/><date-part name=\\\"year\\\"/></date><date form=\\\"numeric\\\"><date-part name=\\\"day\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\".\\\"/><date-part name=\\\"month\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\".\\\"/><date-part name=\\\"year\\\"/></date><terms><term name=\\\"accessed\\\">zugegriffen</term><term name=\\\"and\\\">und</term><term name=\\\"and others\\\">und andere</term><term name=\\\"anonymous\\\">ohne Autor</term><term name=\\\"anonymous\\\" form=\\\"short\\\">o.&#160;A.</term><term name=\\\"at\\\">auf</term><term name=\\\"available at\\\">verfügbar unter</term><term name=\\\"by\\\">von</term><term name=\\\"circa\\\">circa</term><term name=\\\"circa\\\" form=\\\"short\\\">ca.</term><term name=\\\"cited\\\">zitiert</term><term name=\\\"edition\\\"><single>Auflage</single><multiple>Auflagen</multiple></term><term name=\\\"edition\\\" form=\\\"short\\\">Aufl.</term><term name=\\\"et-al\\\">u.&#160;a.</term><term name=\\\"forthcoming\\\">i.&#160;E.</term><term name=\\\"from\\\">von</term><term name=\\\"ibid\\\">ebd.</term><term name=\\\"in\\\">in</term><term name=\\\"in press\\\">im Druck</term><term name=\\\"internet\\\">Internet</term><term name=\\\"interview\\\">Interview</term><term name=\\\"letter\\\">Brief</term><term name=\\\"no date\\\">ohne Datum</term><term name=\\\"no date\\\" form=\\\"short\\\">o.&#160;J.</term><term name=\\\"online\\\">online</term><term name=\\\"presented at\\\">gehalten auf der</term><term name=\\\"reference\\\"><single>Referenz</single><multiple>Referenzen</multiple></term><term name=\\\"reference\\\" form=\\\"short\\\"><single>Ref.</single><multiple>Ref.</multiple></term><term name=\\\"retrieved\\\">abgerufen</term><term name=\\\"scale\\\">Maßstab</term><term name=\\\"version\\\">Version</term><term name=\\\"ad\\\">n.&#160;Chr.</term><term name=\\\"bc\\\">v.&#160;Chr.</term><term name=\\\"open-quote\\\">„</term><term name=\\\"close-quote\\\">“</term><term name=\\\"open-inner-quote\\\">‚</term><term name=\\\"close-inner-quote\\\">‘</term><term name=\\\"page-range-delimiter\\\">–</term><term name=\\\"ordinal\\\">.</term><term name=\\\"long-ordinal-01\\\">erster</term><term name=\\\"long-ordinal-02\\\">zweiter</term><term name=\\\"long-ordinal-03\\\">dritter</term><term name=\\\"long-ordinal-04\\\">vierter</term><term name=\\\"long-ordinal-05\\\">fünfter</term><term name=\\\"long-ordinal-06\\\">sechster</term><term name=\\\"long-ordinal-07\\\">siebter</term><term name=\\\"long-ordinal-08\\\">achter</term><term name=\\\"long-ordinal-09\\\">neunter</term><term name=\\\"long-ordinal-10\\\">zehnter</term><term name=\\\"book\\\"><single>Buch</single><multiple>Bücher</multiple></term><term name=\\\"chapter\\\"><single>Kapitel</single><multiple>Kapitel</multiple></term><term name=\\\"column\\\"><single>Spalte</single><multiple>Spalten</multiple></term><term name=\\\"figure\\\"><single>Abbildung</single><multiple>Abbildungen</multiple></term><term name=\\\"folio\\\"><single>Blatt</single><multiple>Blätter</multiple></term><term name=\\\"issue\\\"><single>Nummer</single><multiple>Nummern</multiple></term><term name=\\\"line\\\"><single>Zeile</single><multiple>Zeilen</multiple></term><term name=\\\"note\\\"><single>Note</single><multiple>Noten</multiple></term><term name=\\\"opus\\\"><single>Opus</single><multiple>Opera</multiple></term><term name=\\\"page\\\"><single>Seite</single><multiple>Seiten</multiple></term><term name=\\\"number-of-pages\\\"><single>Seite</single><multiple>Seiten</multiple></term><term name=\\\"paragraph\\\"><single>Absatz</single><multiple>Absätze</multiple></term><term name=\\\"part\\\"><single>Teil</single><multiple>Teile</multiple></term><term name=\\\"section\\\"><single>Abschnitt</single><multiple>Abschnitte</multiple></term><term name=\\\"sub verbo\\\"><single>sub verbo</single><multiple>sub verbis</multiple></term><term name=\\\"verse\\\"><single>Vers</single><multiple>Verse</multiple></term><term name=\\\"volume\\\"><single>Band</single><multiple>Bände</multiple></term><term name=\\\"book\\\" form=\\\"short\\\">B.</term>\\n<term name=\\\"chapter\\\" form=\\\"short\\\">Kap.</term><term name=\\\"column\\\" form=\\\"short\\\">Sp.</term><term name=\\\"figure\\\" form=\\\"short\\\">Abb.</term><term name=\\\"folio\\\" form=\\\"short\\\">Fol.</term><term name=\\\"issue\\\" form=\\\"short\\\">Nr.</term><term name=\\\"line\\\" form=\\\"short\\\">Z.</term><term name=\\\"note\\\" form=\\\"short\\\">N.</term><term name=\\\"opus\\\" form=\\\"short\\\">op.</term><term name=\\\"page\\\" form=\\\"short\\\"><single>S.</single><multiple>S.</multiple></term><term name=\\\"number-of-pages\\\" form=\\\"short\\\"><single>S.</single><multiple>S.</multiple></term><term name=\\\"paragraph\\\" form=\\\"short\\\">Abs.</term><term name=\\\"part\\\" form=\\\"short\\\">Teil</term><term name=\\\"section\\\" form=\\\"short\\\">Abschn.</term><term name=\\\"sub verbo\\\" form=\\\"short\\\"><single>s.&#160;v.</single><multiple>s.&#160;vv.</multiple></term><term name=\\\"verse\\\" form=\\\"short\\\"><single>V.</single><multiple>V.</multiple></term><term name=\\\"volume\\\" form=\\\"short\\\"><single>Bd.</single><multiple>Bde.</multiple></term><term name=\\\"paragraph\\\" form=\\\"symbol\\\"><single>¶</single><multiple>¶¶</multiple></term><term name=\\\"section\\\" form=\\\"symbol\\\"><single>§</single><multiple>§§</multiple></term><term name=\\\"director\\\"><single>Regisseur</single><multiple>Regisseure</multiple></term><term name=\\\"editor\\\"><single>Herausgeber</single><multiple>Herausgeber</multiple></term><term name=\\\"collection-editor\\\"><single>Reihenherausgeber</single><multiple>Reihenherausgeber</multiple></term><term name=\\\"editorial-director\\\"><single>Herausgeber</single><multiple>Herausgeber</multiple></term><term name=\\\"illustrator\\\"><single>Illustrator</single><multiple>Illustratoren</multiple></term><term name=\\\"translator\\\"><single>Übersetzer</single><multiple>Übersetzer</multiple></term><term name=\\\"editortranslator\\\"><single>Herausgeber&#160;&amp; Übersetzer</single><multiple>Herausgeber&#160;&amp; Übersetzer</multiple></term><term name=\\\"director\\\" form=\\\"short\\\"><single>Reg.</single><multiple>Reg.</multiple></term><term name=\\\"editor\\\" form=\\\"short\\\"><single>Hrsg.</single><multiple>Hrsg.</multiple></term><term name=\\\"collection-editor\\\" form=\\\"short\\\"><single>Hrsg.</single><multiple>Hrsg.</multiple></term><term name=\\\"editorial-director\\\" form=\\\"short\\\"><single>Hrsg.</single><multiple>Hrsg.</multiple></term><term name=\\\"illustrator\\\" form=\\\"short\\\"><single>Ill.</single><multiple>Ill.</multiple></term><term name=\\\"translator\\\" form=\\\"short\\\"><single>Übers.</single><multiple>Übers.</multiple></term><term name=\\\"editortranslator\\\" form=\\\"short\\\"><single>Hrsg.&#160;&amp; Übers.</single><multiple>Hrsg.&#160;&amp; Übers</multiple></term><term name=\\\"container-author\\\" form=\\\"verb\\\">von</term><term name=\\\"director\\\" form=\\\"verb\\\">Regie von</term><term name=\\\"editor\\\" form=\\\"verb\\\">herausgegeben von</term><term name=\\\"collection-editor\\\" form=\\\"verb\\\">herausgegeben von</term><term name=\\\"editorial-director\\\" form=\\\"verb\\\">herausgegeben von</term><term name=\\\"illustrator\\\" form=\\\"verb\\\">illustriert von</term><term name=\\\"interviewer\\\" form=\\\"verb\\\">interviewt von</term><term name=\\\"recipient\\\" form=\\\"verb\\\">an</term><term name=\\\"reviewed-author\\\" form=\\\"verb\\\">von</term><term name=\\\"translator\\\" form=\\\"verb\\\">übersetzt von</term><term name=\\\"editortranslator\\\" form=\\\"verb\\\">herausgegeben und übersetzt von</term><term name=\\\"director\\\" form=\\\"verb-short\\\">Reg.</term><term name=\\\"editor\\\" form=\\\"verb-short\\\">hg. von</term><term name=\\\"collection-editor\\\" form=\\\"verb-short\\\">hg. von</term><term name=\\\"editorial-director\\\" form=\\\"verb-short\\\">hg. von</term><term name=\\\"illustrator\\\" form=\\\"verb-short\\\">illus. von</term><term name=\\\"translator\\\" form=\\\"verb-short\\\">übers. von</term><term name=\\\"editortranslator\\\" form=\\\"verb-short\\\">hg.&#160;&amp; übers. von</term><term name=\\\"month-01\\\">Januar</term><term name=\\\"month-02\\\">Februar</term><term name=\\\"month-03\\\">März</term><term name=\\\"month-04\\\">April</term><term name=\\\"month-05\\\">Mai</term><term name=\\\"month-06\\\">Juni</term><term name=\\\"month-07\\\">Juli</term><term name=\\\"month-08\\\">August</term><term name=\\\"month-09\\\">September</term><term name=\\\"month-10\\\">Oktober</term><term name=\\\"month-11\\\">November</term><term name=\\\"month-12\\\">Dezember</term><term name=\\\"month-01\\\" form=\\\"short\\\">Jan.</term><term name=\\\"month-02\\\" form=\\\"short\\\">Feb.</term>\\n<term name=\\\"month-03\\\" form=\\\"short\\\">März</term><term name=\\\"month-04\\\" form=\\\"short\\\">Apr.</term><term name=\\\"month-05\\\" form=\\\"short\\\">Mai</term><term name=\\\"month-06\\\" form=\\\"short\\\">Juni</term><term name=\\\"month-07\\\" form=\\\"short\\\">Juli</term><term name=\\\"month-08\\\" form=\\\"short\\\">Aug.</term><term name=\\\"month-09\\\" form=\\\"short\\\">Sep.</term><term name=\\\"month-10\\\" form=\\\"short\\\">Okt.</term><term name=\\\"month-11\\\" form=\\\"short\\\">Nov.</term><term name=\\\"month-12\\\" form=\\\"short\\\">Dez.</term><term name=\\\"season-01\\\">Frühjahr</term><term name=\\\"season-02\\\">Sommer</term><term name=\\\"season-03\\\">Herbst</term><term name=\\\"season-04\\\">Winter</term></terms></locale>\",\"es-ES\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><locale xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" version=\\\"1.0\\\" xml:lang=\\\"es-ES\\\"><info><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights><updated>2012-07-04T23:31:02+00:00</updated></info><style-options punctuation-in-quote=\\\"false\\\"/><date form=\\\"text\\\"><date-part name=\\\"day\\\" suffix=\\\" de \\\"/><date-part name=\\\"month\\\" suffix=\\\" de \\\"/><date-part name=\\\"year\\\"/></date><date form=\\\"numeric\\\"><date-part name=\\\"day\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\"/\\\"/><date-part name=\\\"month\\\" form=\\\"numeric-leading-zeros\\\" suffix=\\\"/\\\"/><date-part name=\\\"year\\\"/></date><terms><term name=\\\"accessed\\\">accedido</term><term name=\\\"and\\\">y</term><term name=\\\"and others\\\">y otros</term><term name=\\\"anonymous\\\">anónimo</term><term name=\\\"anonymous\\\" form=\\\"short\\\">anón.</term><term name=\\\"at\\\">en</term><term name=\\\"available at\\\">disponible en</term><term name=\\\"by\\\">de</term><term name=\\\"circa\\\">circa</term><term name=\\\"circa\\\" form=\\\"short\\\">c.</term><term name=\\\"cited\\\">citado</term><term name=\\\"edition\\\"><single>edición</single><multiple>ediciones</multiple></term><term name=\\\"edition\\\" form=\\\"short\\\">ed.</term><term name=\\\"et-al\\\">et&#160;al.</term><term name=\\\"forthcoming\\\">previsto</term><term name=\\\"from\\\">a partir de</term><term name=\\\"ibid\\\">ibid.</term><term name=\\\"in\\\">en</term><term name=\\\"in press\\\">en imprenta</term><term name=\\\"internet\\\">internet</term><term name=\\\"interview\\\">entrevista</term><term name=\\\"letter\\\">carta</term><term name=\\\"no date\\\">sin fecha</term><term name=\\\"no date\\\" form=\\\"short\\\">s.&#160;f.</term><term name=\\\"online\\\">en línea</term><term name=\\\"presented at\\\">presentado en</term><term name=\\\"reference\\\"><single>referencia</single><multiple>referencias</multiple></term><term name=\\\"reference\\\" form=\\\"short\\\"><single>ref.</single><multiple>refs.</multiple></term><term name=\\\"retrieved\\\">recuperado</term><term name=\\\"scale\\\">escala</term><term name=\\\"version\\\">versión</term><term name=\\\"ad\\\">d.&#160;C.</term><term name=\\\"bc\\\">a.&#160;C.</term><term name=\\\"open-quote\\\">«</term><term name=\\\"close-quote\\\">»</term><term name=\\\"open-inner-quote\\\">“</term><term name=\\\"close-inner-quote\\\">”</term><term name=\\\"page-range-delimiter\\\">-</term><term name=\\\"ordinal\\\">.ª</term><term name=\\\"long-ordinal-01\\\">primera</term><term name=\\\"long-ordinal-02\\\">segunda</term><term name=\\\"long-ordinal-03\\\">tercera</term><term name=\\\"long-ordinal-04\\\">cuarta</term><term name=\\\"long-ordinal-05\\\">quinta</term><term name=\\\"long-ordinal-06\\\">sexta</term><term name=\\\"long-ordinal-07\\\">séptima</term><term name=\\\"long-ordinal-08\\\">octava</term><term name=\\\"long-ordinal-09\\\">novena</term><term name=\\\"long-ordinal-10\\\">décima</term><term name=\\\"book\\\"><single>libro</single><multiple>libros</multiple></term><term name=\\\"chapter\\\"><single>capítulo</single><multiple>capítulos</multiple></term><term name=\\\"column\\\"><single>columna</single><multiple>columnas</multiple></term><term name=\\\"figure\\\"><single>figura</single><multiple>figuras</multiple></term><term name=\\\"folio\\\"><single>folio</single><multiple>folios</multiple></term><term name=\\\"issue\\\"><single>número</single><multiple>números</multiple></term><term name=\\\"line\\\"><single>línea</single><multiple>líneas</multiple></term><term name=\\\"note\\\"><single>nota</single><multiple>notas</multiple></term><term name=\\\"opus\\\"><single>opus</single><multiple>opera</multiple></term><term name=\\\"page\\\"><single>página</single><multiple>páginas</multiple></term><term name=\\\"number-of-pages\\\"><single>página</single><multiple>páginas</multiple></term><term name=\\\"paragraph\\\"><single>párrafo</single><multiple>párrafos</multiple></term><term name=\\\"part\\\"><single>parte</single><multiple>partes</multiple></term><term name=\\\"section\\\"><single>sección</single><multiple>secciones</multiple></term><term name=\\\"sub verbo\\\"><single>sub voce</single><multiple>sub vocibus</multiple></term><term name=\\\"verse\\\"><single>verso</single><multiple>versos</multiple></term><term name=\\\"volume\\\"><single>volumen</single><multiple>volúmenes</multiple></term><term name=\\\"book\\\" form=\\\"short\\\">lib.</term>\\n<term name=\\\"chapter\\\" form=\\\"short\\\">cap.</term><term name=\\\"column\\\" form=\\\"short\\\">col.</term><term name=\\\"figure\\\" form=\\\"short\\\">fig.</term><term name=\\\"folio\\\" form=\\\"short\\\">f.</term><term name=\\\"issue\\\" form=\\\"short\\\">n.º</term><term name=\\\"line\\\" form=\\\"short\\\">l.</term><term name=\\\"note\\\" form=\\\"short\\\">n.</term><term name=\\\"opus\\\" form=\\\"short\\\">op.</term><term name=\\\"page\\\" form=\\\"short\\\"><single>p.</single><multiple>pp.</multiple></term><term name=\\\"number-of-pages\\\" form=\\\"short\\\"><single>p.</single><multiple>pp.</multiple></term><term name=\\\"paragraph\\\" form=\\\"short\\\">párr.</term><term name=\\\"part\\\" form=\\\"short\\\">pt.</term><term name=\\\"section\\\" form=\\\"short\\\">sec.</term><term name=\\\"sub verbo\\\" form=\\\"short\\\"><single>s.&#160;v.</single><multiple>s.&#160;vv.</multiple></term><term name=\\\"verse\\\" form=\\\"short\\\"><single>v.</single><multiple>vv.</multiple></term><term name=\\\"volume\\\" form=\\\"short\\\"><single>vol.</single><multiple>vols.</multiple></term><term name=\\\"paragraph\\\" form=\\\"symbol\\\"><single>§</single><multiple>§</multiple></term><term name=\\\"section\\\" form=\\\"symbol\\\"><single>§</single><multiple>§</multiple></term><term name=\\\"director\\\"><single>director</single><multiple>directores</multiple></term><term name=\\\"editor\\\"><single>editor</single><multiple>editores</multiple></term><term name=\\\"editorial-director\\\"><single>editor</single><multiple>editores</multiple></term><term name=\\\"illustrator\\\"><single>ilustrador</single><multiple>ilustradores</multiple></term><term name=\\\"translator\\\"><single>traductor</single><multiple>traductores</multiple></term><term name=\\\"editortranslator\\\"><single>editor y traductor</single><multiple>editores y traductores</multiple></term><term name=\\\"director\\\" form=\\\"short\\\"><single>dir.</single><multiple>dirs.</multiple></term><term name=\\\"editor\\\" form=\\\"short\\\"><single>ed.</single><multiple>eds.</multiple></term><term name=\\\"editorial-director\\\" form=\\\"short\\\"><single>ed.</single><multiple>eds.</multiple></term><term name=\\\"illustrator\\\" form=\\\"short\\\"><single>ilust.</single><multiple>ilusts.</multiple></term><term name=\\\"translator\\\" form=\\\"short\\\"><single>trad.</single><multiple>trads.</multiple></term><term name=\\\"editortranslator\\\" form=\\\"short\\\"><single>ed. y trad.</single><multiple>eds. y trads.</multiple></term><term name=\\\"container-author\\\" form=\\\"verb\\\">de</term><term name=\\\"director\\\" form=\\\"verb\\\">dirigido por</term><term name=\\\"editor\\\" form=\\\"verb\\\">editado por</term><term name=\\\"editorial-director\\\" form=\\\"verb\\\">editado por</term><term name=\\\"illustrator\\\" form=\\\"verb\\\">ilustrado por</term><term name=\\\"interviewer\\\" form=\\\"verb\\\">entrevistado por</term><term name=\\\"recipient\\\" form=\\\"verb\\\">a</term><term name=\\\"reviewed-author\\\" form=\\\"verb\\\">por</term><term name=\\\"translator\\\" form=\\\"verb\\\">traducido por</term><term name=\\\"editortranslator\\\" form=\\\"verb\\\">editado y traducido por</term><term name=\\\"director\\\" form=\\\"verb-short\\\">dir.</term><term name=\\\"editor\\\" form=\\\"verb-short\\\">ed.</term><term name=\\\"editorial-director\\\" form=\\\"verb-short\\\">ed.</term><term name=\\\"illustrator\\\" form=\\\"verb-short\\\">ilust.</term><term name=\\\"translator\\\" form=\\\"verb-short\\\">trad.</term><term name=\\\"editortranslator\\\" form=\\\"verb-short\\\">ed. y trad.</term><term name=\\\"month-01\\\">enero</term><term name=\\\"month-02\\\">febrero</term><term name=\\\"month-03\\\">marzo</term><term name=\\\"month-04\\\">abril</term><term name=\\\"month-05\\\">mayo</term><term name=\\\"month-06\\\">junio</term><term name=\\\"month-07\\\">julio</term><term name=\\\"month-08\\\">agosto</term><term name=\\\"month-09\\\">septiembre</term><term name=\\\"month-10\\\">octubre</term><term name=\\\"month-11\\\">noviembre</term><term name=\\\"month-12\\\">diciembre</term><term name=\\\"month-01\\\" form=\\\"short\\\">ene.</term><term name=\\\"month-02\\\" form=\\\"short\\\">feb.</term><term name=\\\"month-03\\\" form=\\\"short\\\">mar.</term><term name=\\\"month-04\\\" form=\\\"short\\\">abr.</term><term name=\\\"month-05\\\" form=\\\"short\\\">may</term><term name=\\\"month-06\\\" form=\\\"short\\\">jun.</term><term name=\\\"month-07\\\" form=\\\"short\\\">jul.</term><term name=\\\"month-08\\\" form=\\\"short\\\">ago.</term><term name=\\\"month-09\\\" form=\\\"short\\\">sep.</term><term name=\\\"month-10\\\" form=\\\"short\\\">oct.</term><term name=\\\"month-11\\\" form=\\\"short\\\">nov.</term><term name=\\\"month-12\\\" form=\\\"short\\\">\\ndic.</term><term name=\\\"season-01\\\">primavera</term><term name=\\\"season-02\\\">verano</term><term name=\\\"season-03\\\">otoño</term><term name=\\\"season-04\\\">invierno</term></terms></locale>\"}");

/***/ }),
/* 39 */
/***/ (function(module) {

module.exports = JSON.parse("{\"apa\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><style xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" class=\\\"in-text\\\" version=\\\"1.0\\\" demote-non-dropping-particle=\\\"never\\\" page-range-format=\\\"expanded\\\"><info><title>American Psychological Association 7th edition</title><title-short>APA</title-short><id>http://www.zotero.org/styles/apa</id><link href=\\\"http://www.zotero.org/styles/apa\\\" rel=\\\"self\\\"/><link href=\\\"http://www.zotero.org/styles/apa-6th-edition\\\" rel=\\\"template\\\"/><link href=\\\"https://apastyle.apa.org/style-grammar-guidelines/references/examples\\\" rel=\\\"documentation\\\"/><author><name>Brenton M. Wiernik</name><email>zotero@wiernik.org</email></author><category citation-format=\\\"author-date\\\"/><category field=\\\"psychology\\\"/><category field=\\\"generic-base\\\"/><updated>2019-12-04T13:09:49+00:00</updated><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><locale xml:lang=\\\"en\\\"><terms><term name=\\\"editortranslator\\\" form=\\\"short\\\"><single>ed. &amp; trans.</single><multiple>eds. &amp; trans.</multiple></term><term name=\\\"translator\\\" form=\\\"short\\\">trans.</term><term name=\\\"interviewer\\\" form=\\\"short\\\"><single>interviewer</single><multiple>interviewers</multiple></term><term name=\\\"collection-editor\\\" form=\\\"short\\\"><single>ed.</single><multiple>eds.</multiple></term><term name=\\\"circa\\\" form=\\\"short\\\">ca.</term><term name=\\\"bc\\\"> B.C.E.</term><term name=\\\"ad\\\"> C.E.</term><term name=\\\"letter\\\">personal communication</term><term name=\\\"letter\\\" form=\\\"short\\\">letter</term><term name=\\\"issue\\\" form=\\\"long\\\"><single>issue</single><multiple>issues</multiple></term></terms></locale><locale xml:lang=\\\"af\\\"><terms><term name=\\\"letter\\\">persoonlike kommunikasie</term><term name=\\\"letter\\\" form=\\\"short\\\">brief</term></terms></locale><locale xml:lang=\\\"ar\\\"><terms><term name=\\\"letter\\\">اتصال شخصي</term><term name=\\\"letter\\\" form=\\\"short\\\">خطاب</term></terms></locale><locale xml:lang=\\\"da\\\"><terms><term name=\\\"et-al\\\">et al.</term><term name=\\\"letter\\\">personlig kommunikation</term><term name=\\\"letter\\\" form=\\\"short\\\">brev</term></terms></locale><locale xml:lang=\\\"de\\\"><terms><term name=\\\"et-al\\\">et al.</term><term name=\\\"letter\\\">persönliche Kommunikation</term><term name=\\\"letter\\\" form=\\\"short\\\">Brief</term></terms></locale><locale xml:lang=\\\"es\\\"><terms><term name=\\\"from\\\">de</term><term name=\\\"letter\\\">comunicación personal</term><term name=\\\"letter\\\" form=\\\"short\\\">carta</term></terms></locale><locale xml:lang=\\\"fr\\\"><terms><term name=\\\"letter\\\">communication personnelle</term><term name=\\\"letter\\\" form=\\\"short\\\">lettre</term><term name=\\\"editor\\\" form=\\\"short\\\"><single>éd.</single><multiple>éds.</multiple></term></terms></locale><locale xml:lang=\\\"nb\\\"><terms><term name=\\\"et-al\\\">et al.</term><term name=\\\"letter\\\">personlig kommunikasjon</term><term name=\\\"letter\\\" form=\\\"short\\\">brev</term></terms></locale><locale xml:lang=\\\"nl\\\"><terms><term name=\\\"et-al\\\">et al.</term><term name=\\\"letter\\\">persoonlijke communicatie</term><term name=\\\"letter\\\" form=\\\"short\\\">brief</term></terms></locale><locale xml:lang=\\\"nn\\\"><terms><term name=\\\"et-al\\\">et al.</term><term name=\\\"letter\\\">personlig kommunikasjon</term><term name=\\\"letter\\\" form=\\\"short\\\">brev</term></terms></locale><locale xml:lang=\\\"ru\\\"><terms><term name=\\\"letter\\\">личная переписка</term><term name=\\\"letter\\\" form=\\\"short\\\">письмо</term></terms></locale><locale xml:lang=\\\"tr\\\"><terms><term name=\\\"letter\\\">kişisel iletişim</term><term name=\\\"letter\\\" form=\\\"short\\\">mektup</term></terms></locale><macro name=\\\"author-bib\\\"><names variable=\\\"composer\\\" delimiter=\\\", \\\"><name name-as-sort-order=\\\"all\\\" and=\\\"symbol\\\" sort-separator=\\\", \\\" initialize-with=\\\". \\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><substitute><names variable=\\\"author\\\"/><names variable=\\\"illustrator\\\"/><names variable=\\\"director\\\"><name name-as-sort-order=\\\"all\\\" and=\\\"symbol\\\" sort-separator=\\\", \\\" initialize-with=\\\". \\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"long\\\" prefix=\\\" (\\\" suffix=\\\")\\\" text-case=\\\"title\\\"/></names><choose><if variable=\\\"container-title\\\"><choose><if type=\\\"book entry entry-dictionary entry-encyclopedia\\\" match=\\\"any\\\"><choose><if variable=\\\"title\\\"><group delimiter=\\\" \\\"><text macro=\\\"title\\\"/><text macro=\\\"parenthetical\\\"/></group></if><else><text macro=\\\"title-and-descriptions\\\"/></else></choose></if></choose></if></choose><names variable=\\\"editor\\\" delimiter=\\\", \\\"><name name-as-sort-order=\\\"all\\\" and=\\\"symbol\\\" sort-separator=\\\", \\\" initialize-with=\\\". \\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"short\\\" prefix=\\\" (\\\" suffix=\\\")\\\" text-case=\\\"title\\\"/></names><names variable=\\\"editorial-director\\\"><name name-as-sort-order=\\\"all\\\" and=\\\"symbol\\\" sort-separator=\\\", \\\" initialize-with=\\\". \\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"short\\\" prefix=\\\" (\\\" suffix=\\\")\\\" text-case=\\\"title\\\"/></names><names variable=\\\"collection-editor\\\"><name name-as-sort-order=\\\"all\\\" and=\\\"symbol\\\" sort-separator=\\\", \\\" initialize-with=\\\". \\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"short\\\" prefix=\\\" (\\\" suffix=\\\")\\\" text-case=\\\"title\\\"/></names><choose><if variable=\\\"title\\\"><group delimiter=\\\" \\\"><text macro=\\\"title\\\"/><text macro=\\\"parenthetical\\\"/></group></if><else><text macro=\\\"title-and-descriptions\\\"/></else></choose></substitute></names></macro><macro name=\\\"author-intext\\\"><choose><if type=\\\"bill legal_case legislation treaty\\\" match=\\\"any\\\"><text macro=\\\"title-intext\\\"/></if><else-if type=\\\"interview personal_communication\\\"><choose><if variable=\\\"archive container-title DOI publisher URL\\\" match=\\\"none\\\"><group delimiter=\\\", \\\"><names variable=\\\"author\\\"><name and=\\\"symbol\\\" delimiter=\\\", \\\" initialize-with=\\\". \\\"/><substitute><text macro=\\\"title-intext\\\"/></substitute></names><text term=\\\"letter\\\"/></group></if><else><names variable=\\\"author\\\" delimiter=\\\", \\\"><name form=\\\"short\\\" and=\\\"symbol\\\" delimiter=\\\", \\\" initialize-with=\\\". \\\"/><substitute><text macro=\\\"title-intext\\\"/></substitute></names></else></choose></else-if><else><names variable=\\\"composer\\\" delimiter=\\\", \\\"><name form=\\\"short\\\" and=\\\"symbol\\\" delimiter=\\\", \\\" initialize-with=\\\". \\\"/><substitute><names variable=\\\"author\\\"/><names variable=\\\"illustrator\\\"/><names variable=\\\"director\\\"/><choose><if variable=\\\"container-title\\\"><choose><if type=\\\"book entry entry-dictionary entry-encyclopedia\\\" match=\\\"any\\\"><text macro=\\\"title-intext\\\"/></if></choose></if></choose><names variable=\\\"editor\\\"/><names variable=\\\"editorial-director\\\"/><text macro=\\\"title-intext\\\"/></substitute></names></else></choose></macro><macro name=\\\"date-bib\\\"><group delimiter=\\\" \\\" prefix=\\\"(\\\" suffix=\\\")\\\"><choose><if is-uncertain-date=\\\"issued\\\"><text term=\\\"circa\\\" form=\\\"short\\\"/></if></choose><group><choose><if variable=\\\"issued\\\"><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date><text variable=\\\"year-suffix\\\"/><choose><if type=\\\"article-magazine article-newspaper broadcast interview motion_picture pamphlet personal_communication post post-weblog song speech webpage\\\" match=\\\"any\\\"><date variable=\\\"issued\\\"><date-part prefix=\\\", \\\" name=\\\"month\\\"/><date-part prefix=\\\" \\\" name=\\\"day\\\"/></date></if><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"collection-editor editor editorial-director issue page volume\\\" match=\\\"none\\\"><date variable=\\\"issued\\\"><date-part prefix=\\\", \\\" name=\\\"month\\\"/><date-part prefix=\\\" \\\" name=\\\"day\\\"/></date></if></choose></else-if></choose></if><else-if variable=\\\"status\\\"><group><text variable=\\\"status\\\" text-case=\\\"lowercase\\\"/><text variable=\\\"year-suffix\\\" prefix=\\\"-\\\"/></group></else-if><else><group><text term=\\\"no date\\\" form=\\\"short\\\"/><text variable=\\\"year-suffix\\\" prefix=\\\"-\\\"/></group></else></choose></group></group></macro><macro name=\\\"date-sort-group\\\"><choose><if variable=\\\"issued\\\"><text value=\\\"1\\\"/></if><else-if variable=\\\"status\\\"><text value=\\\"2\\\"/></else-if><else><text value=\\\"0\\\"/></else></choose></macro><macro name=\\\"date-sort-date\\\"><choose><if type=\\\"article-magazine article-newspaper broadcast interview pamphlet personal_communication post post-weblog speech treaty webpage\\\" match=\\\"any\\\"><date variable=\\\"issued\\\" form=\\\"numeric\\\"/></if><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"collection-editor editor editorial-director issue page volume\\\" match=\\\"none\\\"><date variable=\\\"issued\\\" form=\\\"numeric\\\"/></if></choose></else-if><else><date variable=\\\"issued\\\" form=\\\"numeric\\\"/></else></choose></macro><macro name=\\\"date-intext\\\"><choose><if variable=\\\"issued\\\"><group delimiter=\\\"/\\\"><group delimiter=\\\" \\\"><choose><if is-uncertain-date=\\\"original-date\\\"><text term=\\\"circa\\\" form=\\\"short\\\"/></if></choose><date variable=\\\"original-date\\\"><date-part name=\\\"year\\\"/></date></group><group delimiter=\\\" \\\"><choose><if is-uncertain-date=\\\"issued\\\"><text term=\\\"circa\\\" form=\\\"short\\\"/></if></choose><group><choose><if type=\\\"interview personal_communication\\\"><choose><if variable=\\\"archive container-title DOI publisher URL\\\" match=\\\"none\\\"><date variable=\\\"issued\\\" form=\\\"text\\\"/></if><else><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date></else></choose></if><else><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date></else></choose><text variable=\\\"year-suffix\\\"/></group></group></group></if><else-if variable=\\\"status\\\"><text variable=\\\"status\\\" text-case=\\\"lowercase\\\"/><text variable=\\\"year-suffix\\\" prefix=\\\"-\\\"/></else-if><else><text term=\\\"no date\\\" form=\\\"short\\\"/><text variable=\\\"year-suffix\\\" prefix=\\\"-\\\"/></else></choose></macro><macro name=\\\"title-and-descriptions\\\"><choose><if variable=\\\"title\\\"><group delimiter=\\\" \\\"><text macro=\\\"title\\\"/><text macro=\\\"parenthetical\\\"/><text macro=\\\"bracketed\\\"/></group></if><else><group delimiter=\\\" \\\"><text macro=\\\"bracketed\\\"/><text macro=\\\"parenthetical\\\"/></group></else></choose></macro><macro name=\\\"title\\\"><choose><if type=\\\"post webpage\\\" match=\\\"any\\\"><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></if><else-if variable=\\\"container-title\\\" match=\\\"any\\\"><text variable=\\\"title\\\"/></else-if><else><choose><if type=\\\"article-journal article-magazine article-newspaper post-weblog review review-book\\\"><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></if><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"collection-editor editor editorial-director\\\" match=\\\"any\\\"><group delimiter=\\\": \\\" font-style=\\\"italic\\\"><text variable=\\\"title\\\"/><choose><if is-numeric=\\\"volume\\\" match=\\\"none\\\"><group delimiter=\\\" \\\"><label variable=\\\"volume\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"volume\\\"/></group></if></choose></group></if><else><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></else></choose></else-if><else><group delimiter=\\\": \\\" font-style=\\\"italic\\\"><text variable=\\\"title\\\"/><choose><if is-numeric=\\\"volume\\\" match=\\\"none\\\"><group delimiter=\\\" \\\"><label variable=\\\"volume\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"volume\\\"/></group></if></choose></group></else></choose></else></choose></macro><macro name=\\\"title-intext\\\"><choose><if variable=\\\"title\\\" match=\\\"none\\\"><text macro=\\\"bracketed-intext\\\" prefix=\\\"[\\\" suffix=\\\"]\\\"/></if><else-if type=\\\"bill\\\"><choose><if variable=\\\"number container-title\\\" match=\\\"none\\\"><text variable=\\\"title\\\" form=\\\"short\\\" font-style=\\\"italic\\\" text-case=\\\"title\\\"/></if><else-if variable=\\\"title\\\"><text variable=\\\"title\\\" form=\\\"short\\\" text-case=\\\"title\\\"/></else-if><else><group delimiter=\\\" \\\"><text variable=\\\"genre\\\"/><group delimiter=\\\" \\\"><choose><if variable=\\\"chapter-number container-title\\\" match=\\\"none\\\"><text term=\\\"issue\\\" form=\\\"short\\\"/></if></choose><text variable=\\\"number\\\"/></group></group></else></choose></else-if><else-if type=\\\"legal_case\\\" match=\\\"any\\\"><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></else-if><else-if type=\\\"legislation treaty\\\" match=\\\"any\\\"><text variable=\\\"title\\\" form=\\\"short\\\" text-case=\\\"title\\\"/></else-if><else-if type=\\\"post webpage\\\" match=\\\"any\\\"><text variable=\\\"title\\\" form=\\\"short\\\" font-style=\\\"italic\\\" text-case=\\\"title\\\"/></else-if><else-if variable=\\\"container-title\\\" match=\\\"any\\\"><text variable=\\\"title\\\" form=\\\"short\\\" quotes=\\\"true\\\" text-case=\\\"title\\\"/></else-if><else><text variable=\\\"title\\\" form=\\\"short\\\" font-style=\\\"italic\\\" text-case=\\\"title\\\"/></else></choose></macro><macro name=\\\"parenthetical\\\"><group prefix=\\\"(\\\" suffix=\\\")\\\"><choose><if type=\\\"patent\\\"><group delimiter=\\\" \\\"><text variable=\\\"authority\\\" form=\\\"short\\\"/><choose><if variable=\\\"genre\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/></if><else><text value=\\\"patent\\\" text-case=\\\"capitalize-first\\\"/></else></choose><group delimiter=\\\" \\\"><text term=\\\"issue\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"number\\\"/></group></group></if><else-if type=\\\"post webpage\\\"><group delimiter=\\\"; \\\"><text macro=\\\"secondary-contributors\\\"/><text macro=\\\"database-location\\\"/><text macro=\\\"number\\\"/><text macro=\\\"locators-booklike\\\"/></group></else-if><else-if variable=\\\"container-title\\\"><group delimiter=\\\"; \\\"><text macro=\\\"secondary-contributors\\\"/><choose><if type=\\\"broadcast graphic map motion_picture song\\\" match=\\\"any\\\"><text macro=\\\"number\\\"/></if></choose></group></else-if><else><group delimiter=\\\"; \\\"><text macro=\\\"secondary-contributors\\\"/><text macro=\\\"database-location\\\"/><text macro=\\\"number\\\"/><text macro=\\\"locators-booklike\\\"/></group></else></choose></group></macro><macro name=\\\"parenthetical-container\\\"><choose><if variable=\\\"container-title\\\" match=\\\"any\\\"><group prefix=\\\"(\\\" suffix=\\\")\\\"><group delimiter=\\\"; \\\"><text macro=\\\"database-location\\\"/><choose><if type=\\\"broadcast graphic map motion_picture song\\\" match=\\\"none\\\"><text macro=\\\"number\\\"/></if></choose><text macro=\\\"locators-booklike\\\"/></group></group></if></choose></macro><macro name=\\\"bracketed\\\"><group prefix=\\\"[\\\" suffix=\\\"]\\\"><choose><if variable=\\\"reviewed-author reviewed-title\\\" type=\\\"review review-book\\\" match=\\\"any\\\"><group delimiter=\\\"; \\\"><group delimiter=\\\", \\\"><group delimiter=\\\" \\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><choose><if variable=\\\"genre\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/></if><else-if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></else-if><else><text value=\\\"Review of\\\"/></else></choose></if><else><choose><if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></if><else><text value=\\\"Review of\\\"/></else></choose></else></choose><text macro=\\\"reviewed-title\\\"/></group><names variable=\\\"reviewed-author\\\"><label form=\\\"verb-short\\\" suffix=\\\" \\\"/><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></group><choose><if variable=\\\"genre\\\" match=\\\"any\\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></if></choose></if></choose></group></if><else-if type=\\\"thesis\\\"><group delimiter=\\\"; \\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><group delimiter=\\\", \\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/><choose><if variable=\\\"archive DOI URL\\\" match=\\\"any\\\"><text variable=\\\"publisher\\\"/></if></choose></group></if></choose><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></group></else-if><else-if variable=\\\"interviewer\\\" type=\\\"interview\\\" match=\\\"any\\\"><choose><if variable=\\\"title\\\"><text macro=\\\"format\\\"/></if><else-if variable=\\\"genre\\\"><group delimiter=\\\"; \\\"><group delimiter=\\\" \\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/><group delimiter=\\\" \\\"><text term=\\\"author\\\" form=\\\"verb\\\"/><names variable=\\\"interviewer\\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></group></group></group></else-if><else-if variable=\\\"interviewer\\\"><group delimiter=\\\"; \\\"><names variable=\\\"interviewer\\\"><label form=\\\"verb\\\" suffix=\\\" \\\" text-case=\\\"capitalize-first\\\"/><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></group></else-if><else><text macro=\\\"format\\\"/></else></choose></else-if><else-if type=\\\"personal_communication\\\"><choose><if variable=\\\"recipient\\\"><group delimiter=\\\"; \\\"><group delimiter=\\\" \\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><choose><if variable=\\\"genre\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/></if><else-if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></else-if><else><text term=\\\"letter\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/></else></choose></if><else><choose><if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></if><else><text term=\\\"letter\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/></else></choose></else></choose><names variable=\\\"recipient\\\" delimiter=\\\", \\\"><label form=\\\"verb\\\" suffix=\\\" \\\"/><name and=\\\"symbol\\\" delimiter=\\\", \\\"/></names></group><choose><if variable=\\\"genre\\\" match=\\\"any\\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></if></choose></if></choose></group></if><else><text macro=\\\"format\\\"/></else></choose></else-if><else-if variable=\\\"composer\\\" type=\\\"song\\\" match=\\\"all\\\"><group delimiter=\\\"; \\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><group delimiter=\\\" \\\"><choose><if variable=\\\"genre\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/><names variable=\\\"author\\\" prefix=\\\"recorded by \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></if><else-if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/><names variable=\\\"author\\\" prefix=\\\"recorded by \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></else-if><else><names variable=\\\"author\\\" prefix=\\\"Recorded by \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></else></choose></group></if><else><group delimiter=\\\" \\\"><choose><if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/><names variable=\\\"author\\\" prefix=\\\"recorded by \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></if><else><names variable=\\\"author\\\" prefix=\\\"Recorded by \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names></else></choose></group></else></choose><choose><if variable=\\\"genre\\\" match=\\\"any\\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></if></choose></if></choose></group></else-if><else-if variable=\\\"container-title\\\" match=\\\"none\\\"><text macro=\\\"format\\\"/></else-if><else><choose><if type=\\\"paper-conference speech\\\" match=\\\"any\\\"><choose><if variable=\\\"collection-editor editor editorial-director issue page volume\\\" match=\\\"any\\\"><text macro=\\\"format\\\"/></if></choose></if><else-if type=\\\"book\\\"><choose><if variable=\\\"version\\\" match=\\\"none\\\"><text macro=\\\"format\\\"/></if></choose></else-if><else-if type=\\\"report\\\" match=\\\"none\\\"><text macro=\\\"format\\\"/></else-if></choose></else></choose></group></macro><macro name=\\\"bracketed-intext\\\"><group prefix=\\\"[\\\" suffix=\\\"]\\\"><choose><if variable=\\\"reviewed-author reviewed-title\\\" type=\\\"review review-book\\\" match=\\\"any\\\"><text macro=\\\"reviewed-title-intext\\\" prefix=\\\"Review of \\\"/></if><else-if variable=\\\"interviewer\\\" type=\\\"interview\\\" match=\\\"any\\\"><names variable=\\\"interviewer\\\"><label form=\\\"verb\\\" suffix=\\\" \\\" text-case=\\\"capitalize-first\\\"/><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><substitute><text macro=\\\"format-intext\\\"/></substitute></names></else-if><else-if type=\\\"personal_communication\\\"><choose><if variable=\\\"recipient\\\"><group delimiter=\\\" \\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/></if><else><text term=\\\"letter\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/></else></choose><names variable=\\\"recipient\\\" delimiter=\\\", \\\"><label form=\\\"verb\\\" suffix=\\\" \\\"/><name and=\\\"symbol\\\" delimiter=\\\", \\\"/></names></group></if><else><text macro=\\\"format-intext\\\"/></else></choose></else-if><else><text macro=\\\"format-intext\\\"/></else></choose></group></macro><macro name=\\\"bracketed-container\\\"><group prefix=\\\"[\\\" suffix=\\\"]\\\"><choose><if type=\\\"paper-conference speech\\\" match=\\\"any\\\"><choose><if variable=\\\"collection-editor editor editorial-director issue page volume\\\" match=\\\"none\\\"><text macro=\\\"format\\\"/></if></choose></if><else-if type=\\\"book\\\" variable=\\\"version\\\" match=\\\"all\\\"><text macro=\\\"format\\\"/></else-if><else-if type=\\\"report\\\"><text macro=\\\"format\\\"/></else-if></choose></group></macro><macro name=\\\"secondary-contributors\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper post-weblog review review-book\\\" match=\\\"any\\\"><text macro=\\\"secondary-contributors-periodical\\\"/></if><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"collection-editor editor editorial-director\\\" match=\\\"any\\\"><text macro=\\\"secondary-contributors-booklike\\\"/></if><else><text macro=\\\"secondary-contributors-periodical\\\"/></else></choose></else-if><else><text macro=\\\"secondary-contributors-booklike\\\"/></else></choose></macro><macro name=\\\"secondary-contributors-periodical\\\"><group delimiter=\\\"; \\\"><choose><if variable=\\\"title\\\"><names variable=\\\"interviewer\\\" delimiter=\\\"; \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\", \\\" text-case=\\\"title\\\"/></names></if></choose><names variable=\\\"translator\\\" delimiter=\\\"; \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\", \\\" text-case=\\\"title\\\"/></names></group></macro><macro name=\\\"secondary-contributors-booklike\\\"><group delimiter=\\\"; \\\"><choose><if variable=\\\"title\\\"><names variable=\\\"interviewer\\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\", \\\" text-case=\\\"title\\\"/></names></if></choose><choose><if type=\\\"post webpage\\\" match=\\\"none\\\"><choose><if variable=\\\"container-title\\\" match=\\\"none\\\"><group delimiter=\\\"; \\\"><names variable=\\\"container-author\\\"><label form=\\\"verb-short\\\" suffix=\\\" \\\" text-case=\\\"title\\\"/><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names><names variable=\\\"editor translator\\\" delimiter=\\\"; \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\", \\\" text-case=\\\"title\\\"/></names></group></if></choose></if><else><group delimiter=\\\"; \\\"><names variable=\\\"container-author\\\"><label form=\\\"verb-short\\\" suffix=\\\" \\\" text-case=\\\"title\\\"/><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/></names><names variable=\\\"editor translator\\\" delimiter=\\\"; \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\", \\\" text-case=\\\"title\\\"/></names></group></else></choose></group></macro><macro name=\\\"database-location\\\"><choose><if variable=\\\"archive-place\\\" match=\\\"none\\\"><text variable=\\\"archive_location\\\"/></if></choose></macro><macro name=\\\"number\\\"><choose><if variable=\\\"number\\\"><group delimiter=\\\", \\\"><group delimiter=\\\" \\\"><text variable=\\\"genre\\\" text-case=\\\"title\\\"/><choose><if is-numeric=\\\"number\\\"><text term=\\\"issue\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"number\\\"/></if><else><text variable=\\\"number\\\"/></else></choose></group><choose><if type=\\\"thesis\\\"><choose><if variable=\\\"archive DOI URL\\\" match=\\\"any\\\"><text variable=\\\"publisher\\\"/></if></choose></if></choose></group></if></choose></macro><macro name=\\\"locators-booklike\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper broadcast interview patent post post-weblog review review-book speech webpage\\\" match=\\\"any\\\"/><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"collection-editor editor editorial-director\\\" match=\\\"any\\\"><group delimiter=\\\", \\\"><text macro=\\\"version\\\"/><text macro=\\\"edition\\\"/><text macro=\\\"volume-booklike\\\"/></group></if></choose></else-if><else><group delimiter=\\\", \\\"><text macro=\\\"version\\\"/><text macro=\\\"edition\\\"/><text macro=\\\"volume-booklike\\\"/></group></else></choose></macro><macro name=\\\"version\\\"><choose><if is-numeric=\\\"version\\\"><group delimiter=\\\" \\\"><text term=\\\"version\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"version\\\"/></group></if><else><text variable=\\\"version\\\"/></else></choose></macro><macro name=\\\"edition\\\"><choose><if is-numeric=\\\"edition\\\"><group delimiter=\\\" \\\"><number variable=\\\"edition\\\" form=\\\"ordinal\\\"/><label variable=\\\"edition\\\" form=\\\"short\\\"/></group></if><else><text variable=\\\"edition\\\"/></else></choose></macro><macro name=\\\"volume-booklike\\\"><group delimiter=\\\", \\\"><choose><if type=\\\"report\\\"><group delimiter=\\\" \\\"><text variable=\\\"collection-title\\\" text-case=\\\"title\\\"/><text variable=\\\"collection-number\\\"/></group></if></choose><choose><if variable=\\\"volume\\\" match=\\\"any\\\"><choose><if is-numeric=\\\"volume\\\" match=\\\"none\\\"/><else><group delimiter=\\\" \\\"><label variable=\\\"volume\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><number variable=\\\"volume\\\" form=\\\"numeric\\\"/></group></else></choose></if><else><group><text term=\\\"volume\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\" suffix=\\\" \\\"/><text term=\\\"page-range-delimiter\\\" prefix=\\\"1\\\"/><number variable=\\\"number-of-volumes\\\" form=\\\"numeric\\\"/></group></else></choose><group delimiter=\\\" \\\"><label variable=\\\"issue\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"issue\\\"/></group><group delimiter=\\\" \\\"><label variable=\\\"page\\\" form=\\\"short\\\" suffix=\\\" \\\"/><text variable=\\\"page\\\"/></group></group></macro><macro name=\\\"reviewed-title\\\"><choose><if variable=\\\"reviewed-title\\\"><text variable=\\\"reviewed-title\\\" font-style=\\\"italic\\\"/></if><else><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></else></choose></macro><macro name=\\\"reviewed-title-intext\\\"><choose><if variable=\\\"reviewed-title\\\"><text variable=\\\"reviewed-title\\\" form=\\\"short\\\" font-style=\\\"italic\\\" text-case=\\\"title\\\"/></if><else><text variable=\\\"title\\\" form=\\\"short\\\" font-style=\\\"italic\\\" text-case=\\\"title\\\"/></else></choose></macro><macro name=\\\"format\\\"><choose><if variable=\\\"genre medium\\\" match=\\\"any\\\"><group delimiter=\\\"; \\\"><choose><if variable=\\\"number\\\" match=\\\"none\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/></if></choose><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></group></if><else-if type=\\\"dataset\\\"><text value=\\\"Data set\\\"/></else-if><else-if type=\\\"book\\\" variable=\\\"version\\\" match=\\\"all\\\"><text value=\\\"Computer software\\\"/></else-if><else-if type=\\\"interview personal_communication\\\" match=\\\"any\\\"><choose><if variable=\\\"archive container-title DOI publisher URL\\\" match=\\\"none\\\"><text term=\\\"letter\\\" text-case=\\\"capitalize-first\\\"/></if><else-if type=\\\"interview\\\"><text term=\\\"interview\\\" text-case=\\\"capitalize-first\\\"/></else-if></choose></else-if><else-if type=\\\"map\\\"><text value=\\\"Map\\\"/></else-if></choose></macro><macro name=\\\"format-intext\\\"><choose><if variable=\\\"genre\\\" match=\\\"any\\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/></if><else-if variable=\\\"medium\\\"><text variable=\\\"medium\\\" text-case=\\\"capitalize-first\\\"/></else-if><else-if type=\\\"dataset\\\"><text value=\\\"Data set\\\"/></else-if><else-if type=\\\"book\\\" variable=\\\"version\\\" match=\\\"all\\\"><text value=\\\"Computer software\\\"/></else-if><else-if type=\\\"interview personal_communication\\\" match=\\\"any\\\"><choose><if variable=\\\"archive container-title DOI publisher URL\\\" match=\\\"none\\\"><text term=\\\"letter\\\" text-case=\\\"capitalize-first\\\"/></if><else-if type=\\\"interview\\\"><text term=\\\"interview\\\" text-case=\\\"capitalize-first\\\"/></else-if></choose></else-if><else-if type=\\\"map\\\"><text value=\\\"Map\\\"/></else-if></choose></macro><macro name=\\\"container\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper post-weblog review review-book\\\" match=\\\"any\\\"><text macro=\\\"container-periodical\\\"/></if><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"editor editorial-director collection-editor container-author\\\" match=\\\"any\\\"><text macro=\\\"container-booklike\\\"/></if><else><text macro=\\\"container-periodical\\\"/></else></choose></else-if><else-if type=\\\"post webpage\\\" match=\\\"none\\\"><text macro=\\\"container-booklike\\\"/></else-if></choose></macro><macro name=\\\"container-periodical\\\"><group delimiter=\\\". \\\"><group delimiter=\\\", \\\"><text variable=\\\"container-title\\\" font-style=\\\"italic\\\" text-case=\\\"title\\\"/><choose><if variable=\\\"volume\\\"><group><text variable=\\\"volume\\\" font-style=\\\"italic\\\"/><text variable=\\\"issue\\\" prefix=\\\"(\\\" suffix=\\\")\\\"/></group></if><else><text variable=\\\"issue\\\" font-style=\\\"italic\\\"/></else></choose><choose><if variable=\\\"page\\\"><text variable=\\\"page\\\"/></if><else><text variable=\\\"number\\\" prefix=\\\"Article \\\"/></else></choose></group><choose><if variable=\\\"issued\\\"><choose><if variable=\\\"issue page volume\\\" match=\\\"none\\\"><text variable=\\\"status\\\" text-case=\\\"capitalize-first\\\"/></if></choose></if></choose></group></macro><macro name=\\\"container-booklike\\\"><choose><if variable=\\\"container-title\\\" match=\\\"any\\\"><group delimiter=\\\" \\\"><text term=\\\"in\\\" text-case=\\\"capitalize-first\\\"/><group delimiter=\\\", \\\"><names variable=\\\"editor translator\\\" delimiter=\\\", &amp; \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" text-case=\\\"title\\\" prefix=\\\" (\\\" suffix=\\\")\\\"/><substitute><names variable=\\\"editorial-director\\\"/><names variable=\\\"collection-editor\\\"/><names variable=\\\"container-author\\\"/></substitute></names><group delimiter=\\\": \\\" font-style=\\\"italic\\\"><text variable=\\\"container-title\\\"/><choose><if is-numeric=\\\"volume\\\" match=\\\"none\\\"><group delimiter=\\\" \\\"><label variable=\\\"volume\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"volume\\\"/></group></if></choose></group></group><text macro=\\\"parenthetical-container\\\"/><text macro=\\\"bracketed-container\\\"/></group></if></choose></macro><macro name=\\\"publisher\\\"><group delimiter=\\\"; \\\"><choose><if type=\\\"thesis\\\"><choose><if variable=\\\"archive DOI URL\\\" match=\\\"none\\\"><text variable=\\\"publisher\\\"/></if></choose></if><else-if type=\\\"post webpage\\\"><group delimiter=\\\"; \\\"><text variable=\\\"container-title\\\" text-case=\\\"title\\\"/><text variable=\\\"publisher\\\"/></group></else-if><else-if type=\\\"paper-conference\\\"><choose><if variable=\\\"collection-editor editor editorial-director\\\" match=\\\"any\\\"><text variable=\\\"publisher\\\"/></if></choose></else-if><else-if type=\\\"article-journal article-magazine article-newspaper post-weblog\\\" match=\\\"none\\\"><text variable=\\\"publisher\\\"/></else-if></choose><group delimiter=\\\", \\\"><choose><if variable=\\\"archive-place\\\"><text variable=\\\"archive_location\\\"/></if></choose><text variable=\\\"archive\\\"/><text variable=\\\"archive-place\\\"/></group></group></macro><macro name=\\\"access\\\"><choose><if variable=\\\"DOI\\\" match=\\\"any\\\"><text variable=\\\"DOI\\\" prefix=\\\"https://doi.org/\\\"/></if><else-if variable=\\\"URL\\\"><group delimiter=\\\" \\\"><choose><if variable=\\\"issued status\\\" match=\\\"none\\\"><group delimiter=\\\" \\\"><text term=\\\"retrieved\\\" text-case=\\\"capitalize-first\\\"/><date variable=\\\"accessed\\\" form=\\\"text\\\" suffix=\\\",\\\"/><text term=\\\"from\\\"/></group></if></choose><text variable=\\\"URL\\\"/></group></else-if></choose></macro><macro name=\\\"event\\\"><choose><if variable=\\\"event\\\"><choose><if variable=\\\"collection-editor editor editorial-director issue page volume\\\" match=\\\"none\\\"><group delimiter=\\\", \\\"><text variable=\\\"event\\\"/><text variable=\\\"event-place\\\"/></group></if></choose></if></choose></macro><macro name=\\\"publication-history\\\"><choose><if type=\\\"patent\\\" match=\\\"none\\\"><group prefix=\\\"(\\\" suffix=\\\")\\\"><choose><if variable=\\\"references\\\"><text variable=\\\"references\\\"/></if><else><group delimiter=\\\" \\\"><text value=\\\"Original work published\\\"/><choose><if is-uncertain-date=\\\"original-date\\\"><text term=\\\"circa\\\" form=\\\"short\\\"/></if></choose><date variable=\\\"original-date\\\"><date-part name=\\\"year\\\"/></date></group></else></choose></group></if><else><text variable=\\\"references\\\" prefix=\\\"(\\\" suffix=\\\")\\\"/></else></choose></macro><macro name=\\\"legal-cites\\\"><choose><if type=\\\"legal_case\\\"><group delimiter=\\\". \\\"><group delimiter=\\\", \\\"><text variable=\\\"title\\\"/><group delimiter=\\\" \\\"><text macro=\\\"container-legal\\\"/><text macro=\\\"date-legal\\\"/></group><text variable=\\\"references\\\"/></group><text macro=\\\"access\\\"/></group></if><else-if type=\\\"bill\\\"><group delimiter=\\\". \\\"><group delimiter=\\\", \\\"><choose><if variable=\\\"number container-title\\\" match=\\\"none\\\"><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></if><else><text variable=\\\"title\\\"/></else></choose><group delimiter=\\\" \\\"><text macro=\\\"container-legal\\\"/><text macro=\\\"date-legal\\\"/><choose><if variable=\\\"number container-title\\\" match=\\\"none\\\"><names variable=\\\"author\\\" prefix=\\\"(testimony of \\\" suffix=\\\")\\\"><name and=\\\"symbol\\\" delimiter=\\\", \\\"/></names></if><else><text variable=\\\"status\\\" prefix=\\\"(\\\" suffix=\\\")\\\"/></else></choose></group><text variable=\\\"references\\\"/></group><text macro=\\\"access\\\"/></group></else-if><else-if type=\\\"legislation\\\"><group delimiter=\\\". \\\"><group delimiter=\\\", \\\"><text variable=\\\"title\\\"/><group delimiter=\\\" \\\"><text macro=\\\"container-legal\\\"/><text macro=\\\"date-legal\\\"/><text variable=\\\"status\\\" prefix=\\\"(\\\" suffix=\\\")\\\"/></group><text variable=\\\"references\\\"/></group><text macro=\\\"access\\\"/></group></else-if><else-if type=\\\"treaty\\\"><group delimiter=\\\", \\\"><text variable=\\\"title\\\" text-case=\\\"title\\\"/><names variable=\\\"author\\\"><name initialize-with=\\\".\\\" form=\\\"short\\\" delimiter=\\\"-\\\"/></names><text macro=\\\"date-legal\\\"/><text macro=\\\"container-legal\\\"/><text macro=\\\"access\\\"/></group></else-if></choose></macro><macro name=\\\"date-legal\\\"><choose><if type=\\\"legal_case\\\"><group prefix=\\\"(\\\" suffix=\\\")\\\" delimiter=\\\" \\\"><text variable=\\\"authority\\\"/><choose><if variable=\\\"container-title\\\" match=\\\"any\\\"><date variable=\\\"issued\\\" form=\\\"numeric\\\" date-parts=\\\"year\\\"/></if><else><date variable=\\\"issued\\\" form=\\\"text\\\"/></else></choose></group></if><else-if type=\\\"bill legislation\\\" match=\\\"any\\\"><group prefix=\\\"(\\\" suffix=\\\")\\\" delimiter=\\\" \\\"><group delimiter=\\\" \\\"><date variable=\\\"original-date\\\"><date-part name=\\\"year\\\"/></date><text term=\\\"and\\\" form=\\\"symbol\\\"/></group><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date></group></else-if><else-if type=\\\"treaty\\\"><date variable=\\\"issued\\\" form=\\\"text\\\"/></else-if></choose></macro><macro name=\\\"container-legal\\\"><choose><if type=\\\"legal_case\\\"><group delimiter=\\\" \\\"><choose><if variable=\\\"container-title\\\"><group delimiter=\\\" \\\"><text variable=\\\"volume\\\"/><text variable=\\\"container-title\\\"/><group delimiter=\\\" \\\"><text term=\\\"section\\\" form=\\\"symbol\\\"/><text variable=\\\"section\\\"/></group><choose><if variable=\\\"page page-first\\\" match=\\\"any\\\"><text variable=\\\"page-first\\\"/></if><else><text value=\\\"___\\\"/></else></choose></group></if><else><group delimiter=\\\" \\\"><choose><if is-numeric=\\\"number\\\"><text term=\\\"issue\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/></if></choose><text variable=\\\"number\\\"/></group></else></choose></group></if><else-if type=\\\"bill\\\"><group delimiter=\\\", \\\"><group delimiter=\\\" \\\"><text variable=\\\"genre\\\"/><group delimiter=\\\" \\\"><choose><if variable=\\\"chapter-number container-title\\\" match=\\\"none\\\"><text term=\\\"issue\\\" form=\\\"short\\\"/></if></choose><text variable=\\\"number\\\"/></group></group><text variable=\\\"authority\\\"/><text variable=\\\"chapter-number\\\"/><group delimiter=\\\" \\\"><text variable=\\\"volume\\\"/><text variable=\\\"container-title\\\"/><text variable=\\\"page-first\\\"/></group></group></else-if><else-if type=\\\"legislation\\\"><choose><if variable=\\\"number\\\"><group delimiter=\\\", \\\"><text variable=\\\"number\\\" prefix=\\\"Pub. L. No. \\\"/><group delimiter=\\\" \\\"><text variable=\\\"volume\\\"/><text variable=\\\"container-title\\\"/><text variable=\\\"page-first\\\"/></group></group></if><else><group delimiter=\\\" \\\"><text variable=\\\"volume\\\"/><text variable=\\\"container-title\\\"/><choose><if variable=\\\"section\\\"><group delimiter=\\\" \\\"><text term=\\\"section\\\" form=\\\"symbol\\\"/><text variable=\\\"section\\\"/></group></if><else><text variable=\\\"page-first\\\"/></else></choose></group></else></choose></else-if><else-if type=\\\"treaty\\\"><group delimiter=\\\" \\\"><number variable=\\\"volume\\\"/><text variable=\\\"container-title\\\"/><choose><if variable=\\\"page page-first\\\" match=\\\"any\\\"><text variable=\\\"page-first\\\"/></if><else><group delimiter=\\\" \\\"><text term=\\\"issue\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"number\\\"/></group></else></choose></group></else-if></choose></macro><macro name=\\\"citation-locator\\\"><group delimiter=\\\" \\\"><choose><if locator=\\\"chapter\\\"><label variable=\\\"locator\\\" text-case=\\\"capitalize-first\\\"/></if><else><label variable=\\\"locator\\\" form=\\\"short\\\"/></else></choose><text variable=\\\"locator\\\"/></group></macro><citation et-al-min=\\\"3\\\" et-al-use-first=\\\"1\\\" disambiguate-add-year-suffix=\\\"true\\\" disambiguate-add-names=\\\"true\\\" disambiguate-add-givenname=\\\"true\\\" collapse=\\\"year\\\" givenname-disambiguation-rule=\\\"primary-name\\\"><sort><key macro=\\\"author-bib\\\" names-min=\\\"3\\\" names-use-first=\\\"1\\\"/><key macro=\\\"date-sort-group\\\"/><key macro=\\\"date-sort-date\\\" sort=\\\"ascending\\\"/><key variable=\\\"status\\\"/></sort><layout prefix=\\\"(\\\" suffix=\\\")\\\" delimiter=\\\"; \\\"><group delimiter=\\\", \\\"><text macro=\\\"author-intext\\\"/><text macro=\\\"date-intext\\\"/><text macro=\\\"citation-locator\\\"/></group></layout></citation><bibliography hanging-indent=\\\"true\\\" et-al-min=\\\"21\\\" et-al-use-first=\\\"19\\\" et-al-use-last=\\\"true\\\" entry-spacing=\\\"0\\\" line-spacing=\\\"2\\\"><sort><key macro=\\\"author-bib\\\"/><key macro=\\\"date-sort-group\\\"/><key macro=\\\"date-sort-date\\\" sort=\\\"ascending\\\"/><key variable=\\\"status\\\"/><key macro=\\\"title\\\"/></sort><layout><choose><if type=\\\"bill legal_case legislation treaty\\\" match=\\\"any\\\"><choose><if variable=\\\"DOI URL\\\" match=\\\"any\\\"><text macro=\\\"legal-cites\\\"/></if><else><text macro=\\\"legal-cites\\\" suffix=\\\".\\\"/></else></choose></if><else><group delimiter=\\\" \\\"><group delimiter=\\\". \\\" suffix=\\\".\\\"><text macro=\\\"author-bib\\\"/><text macro=\\\"date-bib\\\"/><text macro=\\\"title-and-descriptions\\\"/><text macro=\\\"container\\\"/><text macro=\\\"event\\\"/><text macro=\\\"publisher\\\"/></group><text macro=\\\"access\\\"/><text macro=\\\"publication-history\\\"/></group></else></choose></layout></bibliography></style>\",\"vancouver\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><style xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" class=\\\"in-text\\\" version=\\\"1.0\\\" demote-non-dropping-particle=\\\"sort-only\\\" page-range-format=\\\"minimal\\\"><info><title>Vancouver</title><id>http://www.zotero.org/styles/vancouver</id><link href=\\\"http://www.zotero.org/styles/vancouver\\\" rel=\\\"self\\\"/><link href=\\\"http://www.nlm.nih.gov/bsd/uniform_requirements.html\\\" rel=\\\"documentation\\\"/><author><name>Michael Berkowitz</name><email>mberkowi@gmu.edu</email></author><contributor><name>Sean Takats</name><email>stakats@gmu.edu</email></contributor><contributor><name>Sebastian Karcher</name></contributor><category citation-format=\\\"numeric\\\"/><category field=\\\"medicine\\\"/><summary>Vancouver style as outlined by International Committee of Medical Journal Editors Uniform Requirements for Manuscripts Submitted to Biomedical Journals: Sample References</summary><updated>2014-09-06T16:03:01+00:00</updated><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><locale xml:lang=\\\"en\\\"><date form=\\\"text\\\" delimiter=\\\" \\\"><date-part name=\\\"year\\\"/><date-part name=\\\"month\\\" form=\\\"short\\\" strip-periods=\\\"true\\\"/><date-part name=\\\"day\\\"/></date><terms><term name=\\\"collection-editor\\\" form=\\\"long\\\"><single>editor</single><multiple>editors</multiple></term><term name=\\\"presented at\\\">presented at</term><term name=\\\"available at\\\">available from</term><term name=\\\"section\\\" form=\\\"short\\\">sect.</term></terms></locale><locale xml:lang=\\\"fr\\\"><date form=\\\"text\\\" delimiter=\\\" \\\"><date-part name=\\\"day\\\"/><date-part name=\\\"month\\\" form=\\\"short\\\" strip-periods=\\\"true\\\"/><date-part name=\\\"year\\\"/></date></locale><macro name=\\\"author\\\"><names variable=\\\"author\\\"><name sort-separator=\\\" \\\" initialize-with=\\\"\\\" name-as-sort-order=\\\"all\\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"long\\\" prefix=\\\", \\\"/><substitute><names variable=\\\"editor\\\"/></substitute></names></macro><macro name=\\\"editor\\\"><names variable=\\\"editor\\\" suffix=\\\".\\\"><name sort-separator=\\\" \\\" initialize-with=\\\"\\\" name-as-sort-order=\\\"all\\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"long\\\" prefix=\\\", \\\"/></names></macro><macro name=\\\"chapter-marker\\\"><choose><if type=\\\"chapter paper-conference entry-dictionary entry-encyclopedia\\\" match=\\\"any\\\"><text term=\\\"in\\\" text-case=\\\"capitalize-first\\\"/></if></choose></macro><macro name=\\\"publisher\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper\\\" match=\\\"none\\\"><group delimiter=\\\": \\\" suffix=\\\";\\\"><choose><if type=\\\"thesis\\\"><text variable=\\\"publisher-place\\\" prefix=\\\"[\\\" suffix=\\\"]\\\"/></if><else-if type=\\\"speech\\\"/><else><text variable=\\\"publisher-place\\\"/></else></choose><text variable=\\\"publisher\\\"/></group></if></choose></macro><macro name=\\\"access\\\"><choose><if variable=\\\"URL\\\"><group delimiter=\\\": \\\"><text term=\\\"available at\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"URL\\\"/></group></if></choose></macro><macro name=\\\"accessed-date\\\"><choose><if variable=\\\"URL\\\"><group prefix=\\\"[\\\" suffix=\\\"]\\\" delimiter=\\\" \\\"><text term=\\\"cited\\\" text-case=\\\"lowercase\\\"/><date variable=\\\"accessed\\\" form=\\\"text\\\"/></group></if></choose></macro><macro name=\\\"container-title\\\"><choose><if type=\\\"article-journal article-magazine chapter paper-conference article-newspaper review review-book entry-dictionary entry-encyclopedia\\\" match=\\\"any\\\"><group suffix=\\\".\\\" delimiter=\\\" \\\"><choose><if type=\\\"article-journal review review-book\\\" match=\\\"any\\\"><text variable=\\\"container-title\\\" form=\\\"short\\\" strip-periods=\\\"true\\\"/></if><else><text variable=\\\"container-title\\\" strip-periods=\\\"true\\\"/></else></choose><choose><if variable=\\\"URL\\\"><text term=\\\"internet\\\" prefix=\\\"[\\\" suffix=\\\"]\\\" text-case=\\\"capitalize-first\\\"/></if></choose></group><text macro=\\\"edition\\\" prefix=\\\" \\\"/></if><else-if type=\\\"bill legislation\\\" match=\\\"any\\\"><group delimiter=\\\", \\\"><group delimiter=\\\". \\\"><text variable=\\\"container-title\\\"/><group delimiter=\\\" \\\"><text term=\\\"section\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"section\\\"/></group></group><text variable=\\\"number\\\"/></group></else-if><else-if type=\\\"speech\\\">\\n<group delimiter=\\\": \\\" suffix=\\\";\\\"><group delimiter=\\\" \\\"><text variable=\\\"genre\\\" text-case=\\\"capitalize-first\\\"/><text term=\\\"presented at\\\"/></group><text variable=\\\"event\\\"/></group></else-if><else><group delimiter=\\\", \\\" suffix=\\\".\\\"><choose><if variable=\\\"collection-title\\\" match=\\\"none\\\"><group delimiter=\\\" \\\"><label variable=\\\"volume\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\"/><text variable=\\\"volume\\\"/></group></if></choose><text variable=\\\"container-title\\\"/></group></else></choose></macro><macro name=\\\"title\\\"><text variable=\\\"title\\\"/><choose><if type=\\\"article-journal article-magazine chapter paper-conference article-newspaper review review-book entry-dictionary entry-encyclopedia\\\" match=\\\"none\\\"><choose><if variable=\\\"URL\\\"><text term=\\\"internet\\\" prefix=\\\" [\\\" suffix=\\\"]\\\" text-case=\\\"capitalize-first\\\"/></if></choose><text macro=\\\"edition\\\" prefix=\\\". \\\"/></if></choose><choose><if type=\\\"thesis\\\"><text variable=\\\"genre\\\" prefix=\\\" [\\\" suffix=\\\"]\\\"/></if></choose></macro><macro name=\\\"edition\\\"><choose><if is-numeric=\\\"edition\\\"><group delimiter=\\\" \\\"><number variable=\\\"edition\\\" form=\\\"ordinal\\\"/><text term=\\\"edition\\\" form=\\\"short\\\"/></group></if><else><text variable=\\\"edition\\\" suffix=\\\".\\\"/></else></choose></macro><macro name=\\\"date\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper review review-book\\\" match=\\\"any\\\"><group suffix=\\\";\\\" delimiter=\\\" \\\"><date variable=\\\"issued\\\" form=\\\"text\\\"/><text macro=\\\"accessed-date\\\"/></group></if><else-if type=\\\"bill legislation\\\" match=\\\"any\\\"><group delimiter=\\\", \\\"><date variable=\\\"issued\\\" delimiter=\\\" \\\"><date-part name=\\\"month\\\" form=\\\"short\\\" strip-periods=\\\"true\\\"/><date-part name=\\\"day\\\"/></date><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date></group></else-if><else-if type=\\\"report\\\"><date variable=\\\"issued\\\" delimiter=\\\" \\\"><date-part name=\\\"year\\\"/><date-part name=\\\"month\\\" form=\\\"short\\\" strip-periods=\\\"true\\\"/></date><text macro=\\\"accessed-date\\\" prefix=\\\" \\\"/></else-if><else-if type=\\\"patent\\\"><group suffix=\\\".\\\"><group delimiter=\\\", \\\"><text variable=\\\"number\\\"/><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date></group><text macro=\\\"accessed-date\\\" prefix=\\\" \\\"/></group></else-if><else-if type=\\\"speech\\\"><group delimiter=\\\"; \\\"><group delimiter=\\\" \\\"><date variable=\\\"issued\\\" delimiter=\\\" \\\"><date-part name=\\\"year\\\"/><date-part name=\\\"month\\\" form=\\\"short\\\" strip-periods=\\\"true\\\"/><date-part name=\\\"day\\\"/></date><text macro=\\\"accessed-date\\\"/></group><text variable=\\\"event-place\\\"/></group></else-if><else><group suffix=\\\".\\\"><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date><text macro=\\\"accessed-date\\\" prefix=\\\" \\\"/></group></else></choose></macro><macro name=\\\"pages\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper review review-book\\\" match=\\\"any\\\"><text variable=\\\"page\\\" prefix=\\\":\\\"/></if><else-if type=\\\"book\\\" match=\\\"any\\\"><text variable=\\\"number-of-pages\\\" prefix=\\\" \\\"/><choose><if is-numeric=\\\"number-of-pages\\\"><label variable=\\\"number-of-pages\\\" form=\\\"short\\\" prefix=\\\" \\\" plural=\\\"never\\\"/></if></choose></else-if><else><group prefix=\\\" \\\" delimiter=\\\" \\\"><label variable=\\\"page\\\" form=\\\"short\\\" plural=\\\"never\\\"/><text variable=\\\"page\\\"/></group></else></choose></macro><macro name=\\\"journal-location\\\"><choose><if type=\\\"article-journal article-magazine review review-book\\\" match=\\\"any\\\"><text variable=\\\"volume\\\"/><text variable=\\\"issue\\\" prefix=\\\"(\\\" suffix=\\\")\\\"/></if></choose></macro><macro name=\\\"collection-details\\\"><choose><if type=\\\"article-journal article-magazine article-newspaper review review-book\\\" match=\\\"none\\\"><choose><if variable=\\\"collection-title\\\"><group delimiter=\\\" \\\" prefix=\\\"(\\\" suffix=\\\")\\\"><names variable=\\\"collection-editor\\\" suffix=\\\".\\\"><name sort-separator=\\\" \\\" initialize-with=\\\"\\\" name-as-sort-order=\\\"all\\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"always\\\"/><label form=\\\"long\\\" prefix=\\\", \\\"/></names><group delimiter=\\\"; \\\"><text variable=\\\"collection-title\\\"/><group delimiter=\\\" \\\"><label variable=\\\"volume\\\" form=\\\"short\\\"/><text variable=\\\"volume\\\"/></group></group></group></if></choose></if></choose></macro><macro name=\\\"report-details\\\"><choose><if type=\\\"report\\\"><text variable=\\\"number\\\" prefix=\\\"Report No.: \\\"/></if></choose></macro><citation collapse=\\\"citation-number\\\">\\n<sort><key variable=\\\"citation-number\\\"/></sort><layout prefix=\\\"(\\\" suffix=\\\")\\\" delimiter=\\\",\\\"><text variable=\\\"citation-number\\\"/></layout></citation><bibliography et-al-min=\\\"7\\\" et-al-use-first=\\\"6\\\" second-field-align=\\\"flush\\\"><layout><text variable=\\\"citation-number\\\" suffix=\\\". \\\"/><group delimiter=\\\". \\\" suffix=\\\". \\\"><text macro=\\\"author\\\"/><text macro=\\\"title\\\"/></group><group delimiter=\\\" \\\" suffix=\\\". \\\"><group delimiter=\\\": \\\"><text macro=\\\"chapter-marker\\\"/><group delimiter=\\\" \\\"><text macro=\\\"editor\\\"/><text macro=\\\"container-title\\\"/></group></group><text macro=\\\"publisher\\\"/><group><text macro=\\\"date\\\"/><text macro=\\\"journal-location\\\"/><text macro=\\\"pages\\\"/></group></group><text macro=\\\"collection-details\\\" suffix=\\\". \\\"/><text macro=\\\"report-details\\\" suffix=\\\". \\\"/><text macro=\\\"access\\\"/></layout></bibliography></style>\",\"harvard1\":\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><style xmlns=\\\"http://purl.org/net/xbiblio/csl\\\" class=\\\"in-text\\\" version=\\\"1.0\\\" demote-non-dropping-particle=\\\"sort-only\\\"><info><title>Harvard Reference format 1 (author-date)</title><id>http://www.zotero.org/styles/harvard1</id><link href=\\\"http://www.zotero.org/styles/harvard1\\\" rel=\\\"self\\\"/><link href=\\\"http://libweb.anglia.ac.uk/referencing/harvard.htm\\\" rel=\\\"documentation\\\"/><author><name>Julian Onions</name><email>julian.onions@gmail.com</email></author><category citation-format=\\\"author-date\\\"/><category field=\\\"generic-base\\\"/><summary>The Harvard author-date style</summary><updated>2012-09-27T22:06:38+00:00</updated><rights license=\\\"http://creativecommons.org/licenses/by-sa/3.0/\\\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights></info><macro name=\\\"editor\\\"><names variable=\\\"editor\\\" delimiter=\\\", \\\"><name and=\\\"symbol\\\" initialize-with=\\\". \\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\", \\\" text-case=\\\"lowercase\\\"/></names></macro><macro name=\\\"anon\\\"><text term=\\\"anonymous\\\" form=\\\"short\\\" text-case=\\\"capitalize-first\\\" strip-periods=\\\"true\\\"/></macro><macro name=\\\"author\\\"><names variable=\\\"author\\\"><name name-as-sort-order=\\\"all\\\" and=\\\"symbol\\\" sort-separator=\\\", \\\" initialize-with=\\\".\\\" delimiter-precedes-last=\\\"never\\\" delimiter=\\\", \\\"/><label form=\\\"short\\\" prefix=\\\" \\\" text-case=\\\"lowercase\\\"/><substitute><names variable=\\\"editor\\\"/><text macro=\\\"anon\\\"/></substitute></names></macro><macro name=\\\"author-short\\\"><names variable=\\\"author\\\"><name form=\\\"short\\\" and=\\\"symbol\\\" delimiter=\\\", \\\" delimiter-precedes-last=\\\"never\\\" initialize-with=\\\". \\\"/><substitute><names variable=\\\"editor\\\"/><names variable=\\\"translator\\\"/><text macro=\\\"anon\\\"/></substitute></names></macro><macro name=\\\"access\\\"><choose><if variable=\\\"URL\\\"><text value=\\\"Available at:\\\" suffix=\\\" \\\"/><text variable=\\\"URL\\\"/><group prefix=\\\" [\\\" suffix=\\\"]\\\"><text term=\\\"accessed\\\" text-case=\\\"capitalize-first\\\" suffix=\\\" \\\"/><date variable=\\\"accessed\\\"><date-part name=\\\"month\\\" suffix=\\\" \\\"/><date-part name=\\\"day\\\" suffix=\\\", \\\"/><date-part name=\\\"year\\\"/></date></group></if></choose></macro><macro name=\\\"title\\\"><choose><if type=\\\"bill book graphic legal_case legislation motion_picture report song thesis\\\" match=\\\"any\\\"><text variable=\\\"title\\\" font-style=\\\"italic\\\"/></if><else><text variable=\\\"title\\\"/></else></choose></macro><macro name=\\\"publisher\\\"><group delimiter=\\\": \\\"><text variable=\\\"publisher-place\\\"/><text variable=\\\"publisher\\\"/></group></macro><macro name=\\\"year-date\\\"><choose><if variable=\\\"issued\\\"><date variable=\\\"issued\\\"><date-part name=\\\"year\\\"/></date></if><else><text term=\\\"no date\\\" form=\\\"short\\\"/></else></choose></macro><macro name=\\\"edition\\\"><choose><if is-numeric=\\\"edition\\\"><group delimiter=\\\" \\\"><number variable=\\\"edition\\\" form=\\\"ordinal\\\"/><text term=\\\"edition\\\" form=\\\"short\\\"/></group></if><else><text variable=\\\"edition\\\" suffix=\\\".\\\"/></else></choose></macro><macro name=\\\"pages\\\"><group><label variable=\\\"page\\\" form=\\\"short\\\" suffix=\\\" \\\"/><text variable=\\\"page\\\"/></group></macro><citation et-al-min=\\\"3\\\" et-al-use-first=\\\"1\\\" disambiguate-add-year-suffix=\\\"true\\\" disambiguate-add-names=\\\"true\\\" disambiguate-add-givenname=\\\"true\\\"><layout prefix=\\\"(\\\" suffix=\\\")\\\" delimiter=\\\"; \\\"><group delimiter=\\\", \\\"><group delimiter=\\\" \\\"><text macro=\\\"author-short\\\"/><text macro=\\\"year-date\\\"/></group><group><label variable=\\\"locator\\\" form=\\\"short\\\"/><text variable=\\\"locator\\\"/></group></group></layout></citation><bibliography hanging-indent=\\\"true\\\" et-al-min=\\\"4\\\" et-al-use-first=\\\"1\\\"><sort><key macro=\\\"author\\\"/><key variable=\\\"title\\\"/></sort><layout><text macro=\\\"author\\\" suffix=\\\",\\\"/><date variable=\\\"issued\\\" prefix=\\\" \\\" suffix=\\\".\\\"><date-part name=\\\"year\\\"/></date><choose><if type=\\\"bill book graphic legal_case legislation motion_picture report song\\\" match=\\\"any\\\"><group prefix=\\\" \\\" delimiter=\\\" \\\" suffix=\\\",\\\"><text macro=\\\"title\\\"/><text macro=\\\"edition\\\"/><text macro=\\\"editor\\\"/></group><text prefix=\\\" \\\" suffix=\\\".\\\" macro=\\\"publisher\\\"/></if><else-if type=\\\"chapter paper-conference\\\" match=\\\"any\\\"><text macro=\\\"title\\\" prefix=\\\" \\\" suffix=\\\".\\\"/><group prefix=\\\" \\\" delimiter=\\\" \\\"><text term=\\\"in\\\" text-case=\\\"capitalize-first\\\"/>\\n<text macro=\\\"editor\\\"/><text variable=\\\"container-title\\\" font-style=\\\"italic\\\" suffix=\\\".\\\"/><text variable=\\\"collection-title\\\" suffix=\\\".\\\"/><text variable=\\\"event\\\" suffix=\\\".\\\"/><group suffix=\\\".\\\" delimiter=\\\", \\\"><text macro=\\\"publisher\\\" prefix=\\\" \\\"/><text macro=\\\"pages\\\"/></group></group></else-if><else-if type=\\\"thesis\\\"><group prefix=\\\" \\\" suffix=\\\".\\\" delimiter=\\\". \\\"><text macro=\\\"title\\\"/><text variable=\\\"genre\\\"/><text macro=\\\"publisher\\\"/></group></else-if><else><group suffix=\\\".\\\"><text macro=\\\"title\\\" prefix=\\\" \\\"/><text macro=\\\"editor\\\" prefix=\\\" \\\"/></group><group prefix=\\\" \\\" suffix=\\\".\\\"><text variable=\\\"container-title\\\" font-style=\\\"italic\\\"/><group prefix=\\\", \\\"><text variable=\\\"volume\\\"/><text variable=\\\"issue\\\" prefix=\\\"(\\\" suffix=\\\")\\\"/></group><group prefix=\\\", \\\"><label variable=\\\"page\\\" form=\\\"short\\\"/><text variable=\\\"page\\\"/></group></group></else></choose><text prefix=\\\" \\\" macro=\\\"access\\\" suffix=\\\".\\\"/></layout></bibliography></style>\"}");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function () {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = debounce;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(71);


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

var bind = __webpack_require__(26);

var Axios = __webpack_require__(43);

var mergeConfig = __webpack_require__(32);

var defaults = __webpack_require__(29);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(33);
axios.CancelToken = __webpack_require__(56);
axios.isCancel = __webpack_require__(28); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(57); // Expose isAxiosError

axios.isAxiosError = __webpack_require__(58);
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports.default = axios;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

var buildURL = __webpack_require__(27);

var InterceptorManager = __webpack_require__(44);

var dispatchRequest = __webpack_require__(45);

var mergeConfig = __webpack_require__(32);
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

var transformData = __webpack_require__(46);

var isCancel = __webpack_require__(28);

var defaults = __webpack_require__(29);
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(31);
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(52);

var combineURLs = __webpack_require__(53);
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(5);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(33);
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */

module.exports = function isAxiosError(payload) {
  return typeof payload === 'object' && payload.isAxiosError === true;
};

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(61); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11), __webpack_require__(18)))

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiDrag", function() { return MultiDragPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sortable", function() { return Sortable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Swap", function() { return SwapPlugin; });
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var version = "1.10.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    if (lastChild(sortable)) return;
    var rect = getRect(sortable),
        threshold = sortable[expando].options.emptyInsertThreshold,
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (threshold && insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // assign target only if condition is true


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;
var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)

      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (sortable.options.supportPointer) {
      on(document, 'pointerup', this._deselectMultiDrag);
    } else {
      on(document, 'mouseup', this._deselectMultiDrag);
      on(document, 'touchend', this._deselectMultiDrag);
    }

    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      var sortable = _ref5.sortable,
          cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvt: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
                currentIndex = index(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
/* harmony default export */ __webpack_exports__["default"] = (Sortable);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.parse = exports.types = exports.scope = void 0;

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

const punctutationMatcher = string => string.replace(/$|( )|(?!^)(?=[A-Z])/g, '\\.?$1');

const getListMatcher = list => `(?:${list.join('|')})\\b`;

const getSplittingRegex = (matcher, flags) => new RegExp(`(?:^| )(${matcher}$)`, flags);

const titles = ['mr', 'mrs', 'ms', 'miss', 'dr', 'herr', 'monsieur', 'hr', 'frau', 'a v m', 'admiraal', 'admiral', 'air cdre', 'air commodore', 'air marshal', 'air vice marshal', 'alderman', 'alhaji', 'ambassador', 'baron', 'barones', 'brig', 'brig gen', 'brig general', 'brigadier', 'brigadier general', 'brother', 'canon', 'capt', 'captain', 'cardinal', 'cdr', 'chief', 'cik', 'cmdr', 'coach', 'col', 'col dr', 'colonel', 'commandant', 'commander', 'commissioner', 'commodore', 'comte', 'comtessa', 'congressman', 'conseiller', 'consul', 'conte', 'contessa', 'corporal', 'councillor', 'count', 'countess', 'crown prince', 'crown princess', 'dame', 'datin', 'dato', 'datuk', 'datuk seri', 'deacon', 'deaconess', 'dean', 'dhr', 'dipl ing', 'doctor', 'dott', 'dott sa', 'dr', 'dr ing', 'dra', 'drs', 'embajador', 'embajadora', 'en', 'encik', 'eng', 'eur ing', 'exma sra', 'exmo sr', 'f o', 'father', 'first lieutient', 'first officer', 'flt lieut', 'flying officer', 'fr', 'frau', 'fraulein', 'fru', 'gen', 'generaal', 'general', 'governor', 'graaf', 'gravin', 'group captain', 'grp capt', 'h e dr', 'h h', 'h m', 'h r h', 'hajah', 'haji', 'hajim', 'her highness', 'her majesty', 'herr', 'high chief', 'his highness', 'his holiness', 'his majesty', 'hon', 'hr', 'hra', 'ing', 'ir', 'jonkheer', 'judge', 'justice', 'khun ying', 'kolonel', 'lady', 'lcda', 'lic', 'lieut', 'lieut cdr', 'lieut col', 'lieut gen', 'lord', 'm', 'm l', 'm r', 'madame', 'mademoiselle', 'maj gen', 'major', 'master', 'mevrouw', 'miss', 'mlle', 'mme', 'monsieur', 'monsignor', 'mr', 'mrs', 'ms', 'mstr', 'nti', 'pastor', 'president', 'prince', 'princess', 'princesse', 'prinses', 'prof', 'prof dr', 'prof sir', 'professor', 'puan', 'puan sri', 'rabbi', 'rear admiral', 'rev', 'rev canon', 'rev dr', 'rev mother', 'reverend', 'rva', 'senator', 'sergeant', 'sheikh', 'sheikha', 'sig', 'sig na', 'sig ra', 'sir', 'sister', 'sqn ldr', 'sr', 'sr d', 'sra', 'srta', 'sultan', 'tan sri', 'tan sri dato', 'tengku', 'teuku', 'than puying', 'the hon dr', 'the hon justice', 'the hon miss', 'the hon mr', 'the hon mrs', 'the hon ms', 'the hon sir', 'the very rev', 'toh puan', 'tun', 'vice admiral', 'viscount', 'viscountess', 'wg cdr'];
const suffixes = ['I', 'II', 'III', 'IV', 'V', 'Senior', 'Junior', 'Jr', 'Sr', 'PhD', 'Ph\\.D', 'APR', 'RPh', 'PE', 'MD', 'MA', 'DMD', 'CME', 'BVM', 'CFRE', 'CLU', 'CPA', 'CSC', 'CSJ', 'DC', 'DD', 'DDS', 'DO', 'DVM', 'EdD', 'Esq', 'JD', 'LLD', 'OD', 'OSB', 'PC', 'Ret', 'RGS', 'RN', 'RNC', 'SHCJ', 'SJ', 'SNJM', 'SSMO', 'USA', 'USAF', 'USAFR', 'USAR', 'USCG', 'USMC', 'USMCR', 'USN', 'USNR'];
const particles = ['Vere', 'Von', 'Van', 'De', 'Del', 'Della', 'Di', 'Da', 'Pietro', 'Vanden', 'Du', 'St.', 'St', 'La', 'Lo', 'Ter', 'O', 'O\'', 'Mac', 'Fitz'];
const titleMatcher = getListMatcher(titles.map(punctutationMatcher));
const suffixMatcher = getListMatcher(suffixes.map(punctutationMatcher));
const particleMatcher = getListMatcher(particles);
const titleSplitter = new RegExp(`^((?:${titleMatcher} )*)(.*)$`, 'i');
const suffixSplitter = getSplittingRegex(`(?:${suffixMatcher}, )*(?:${suffixMatcher})`, 'i');
const particleSplitter = getSplittingRegex(`${/(?:[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89])/.source}.*`);
const endSplitter = getSplittingRegex(`(?:${/(?:[a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/.source}.*|${particleMatcher}.*|\\S*)`);

const parseName = function parseName(name = '') {
  if (typeof name !== 'string') {
    name = name + '';
  }

  let start = '';
  let mid = '';
  let end = '';

  if (/[^.], /.test(name)) {
    const parts = name.split(', ');
    end = parts.shift();
    const suffixMatch = RegExp(suffixMatcher).exec(parts.join(', '));
    start = parts.splice(suffixMatch && suffixMatch.index !== 0 ? 0 : -1, 1)[0];
    mid = parts.join(', ');
  } else {
    const parts = name.split(suffixSplitter, 2);
    const main = parts.shift().split(endSplitter, 2);
    start = main[0];
    end = main[1];
    mid = parts.pop();
  }

  const _start$match = start.match(titleSplitter),
        _start$match2 = _slicedToArray(_start$match, 3),
        droppingParticle = _start$match2[1],
        given = _start$match2[2];

  const suffix = mid;

  const _end$split$reverse = end.split(particleSplitter, 2).reverse(),
        _end$split$reverse2 = _slicedToArray(_end$split$reverse, 2),
        family = _end$split$reverse2[0],
        nonDroppingParticle = _end$split$reverse2[1];

  if (!given && family) {
    return family.includes(' ') ? {
      literal: family
    } : {
      family
    };
  } else if (family) {
    const nameObject = {
      'dropping-particle': droppingParticle,
      given,
      suffix,
      'non-dropping-particle': nonDroppingParticle,
      family
    };
    Object.keys(nameObject).forEach(key => {
      if (!nameObject[key]) {
        delete nameObject[key];
      }
    });
    return nameObject;
  } else {
    return {
      literal: name
    };
  }
};

exports.default = exports.parse = parseName;
const scope = '@name';
exports.scope = scope;
const types = '@name';
exports.types = types;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const startParts = ['dropping-particle', 'given'];
const suffixParts = ['suffix'];
const endParts = ['non-dropping-particle', 'family'];

const getName = function getName(name, reversed = false) {
  const get = parts => parts.map(entry => name[entry] || '').filter(Boolean).join(' ');

  if (name.literal) {
    return name.literal;
  } else if (reversed) {
    const suffixPart = get(suffixParts) ? `, ${get(suffixParts)}` : '';
    const startPart = get(startParts) ? `, ${get(startParts)}` : '';
    return get(endParts) + suffixPart + startPart;
  } else {
    return `${get([...startParts, ...suffixParts, ...endParts])}`;
  }
};

var _default = getName;
exports.default = _default;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(66);

var ieee754 = __webpack_require__(67);

var isArray = __webpack_require__(68);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 67 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 68 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(70);

module.exports = self.fetch.bind(self);

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var global = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || typeof global !== 'undefined' && global;
var support = {
  searchParams: 'URLSearchParams' in global,
  iterable: 'Symbol' in global && 'iterator' in Symbol,
  blob: 'FileReader' in global && 'Blob' in global && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in global,
  arrayBuffer: 'ArrayBuffer' in global
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }

  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }

  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }

  return value;
} // Build a destructive iterator for the value list


function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }

  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };

    reader.onerror = function () {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }

  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;

    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);

      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);

        if (isConsumed) {
          return isConsumed;
        }

        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);

    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse);
  };

  return this;
} // HTTP methods whose capitalization should be normalized


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }

  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }

    this.url = input.url;
    this.credentials = input.credentials;

    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }

    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;

    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';

  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }

  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }

  this._initBody(body);

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/;

      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}

Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};

function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2

  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' '); // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751

  preProcessedHeaders.split('\r').map(function (header) {
    return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
  }).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();

    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }

  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || '';

  this._initBody(bodyInit);
}
Body.call(Response.prototype);

Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response.error = function () {
  var response = new Response(null, {
    status: 0,
    statusText: ''
  });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response(null, {
    status: status,
    headers: {
      location: url
    }
  });
};

var DOMException = global.DOMException;

try {
  new DOMException();
} catch (err) {
  DOMException = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };

  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function () {
        resolve(new Response(body, options));
      }, 0);
    };

    xhr.onerror = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.ontimeout = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.onabort = function () {
      setTimeout(function () {
        reject(new DOMException('Aborted', 'AbortError'));
      }, 0);
    };

    function fixUrl(url) {
      try {
        return url === '' && global.location.href ? global.location.href : url;
      } catch (e) {
        return url;
      }
    }

    xhr.open(request.method, fixUrl(request.url), true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (support.arrayBuffer && request.headers.get('Content-Type') && request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1) {
        xhr.responseType = 'arraybuffer';
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init.headers).forEach(function (name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
    } else {
      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch.polyfill = true;

if (!global.fetch) {
  global.fetch = fetch;
  global.Headers = Headers;
  global.Request = Request;
  global.Response = Response;
}

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm.js
var vue_esm = __webpack_require__(2);

// EXTERNAL MODULE: ./src/store/main.js
var main = __webpack_require__(22);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=template&id=7ba5bd90&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _c("CitationPreview"),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "cited-contributors" },
        [
          _c(
            "draggable",
            {
              attrs: { group: "citationOrder", handle: ".citation-ordering" },
              model: {
                value: _vm.citedContributors,
                callback: function($$v) {
                  _vm.citedContributors = $$v
                },
                expression: "citedContributors"
              }
            },
            _vm._l(_vm.citedContributors, function(contributor) {
              return _c("ContributionBlock", {
                key: contributor.id,
                attrs: { "contributor-id": contributor.id }
              })
            }),
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "other-contributors" },
        [
          _c(
            "draggable",
            {
              attrs: { group: "citationOrder", handle: ".citation-ordering" },
              model: {
                value: _vm.otherContributors,
                callback: function($$v) {
                  _vm.otherContributors = $$v
                },
                expression: "otherContributors"
              }
            },
            _vm._l(_vm.otherContributors, function(contributor) {
              return _c("ContributionBlock", {
                key: contributor.id,
                attrs: { "contributor-id": contributor.id }
              })
            }),
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _c("AgentSearch"),
      _vm._v(" "),
      _c("input", {
        attrs: {
          type: "hidden",
          id: "contributor-content",
          name: "attribution"
        },
        domProps: { value: _vm.serialisedContent }
      })
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


// CONCATENATED MODULE: ./src/App.vue?vue&type=template&id=7ba5bd90&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ContributionBlock.vue?vue&type=template&id=985c5846&
var ContributionBlockvue_type_template_id_985c5846_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "contribution-block",
      class: { cited: _vm.contributor.citeable }
    },
    [
      _c(
        "div",
        { staticClass: "citation-ordering" },
        [
          _vm.contributor.citeable
            ? [
                _c("i", {
                  staticClass: "fas fa-angle-up fa-lg btn-1",
                  class: {
                    "btn-disabled": _vm.contributor.citation.order === 1
                  },
                  on: {
                    click: function($event) {
                      return _vm.moveCitation(-1)
                    }
                  }
                }),
                _vm._v(" "),
                _c(
                  "span",
                  { staticClass: "btn-2", attrs: { title: "Cited author" } },
                  [_vm._v(_vm._s(_vm.contributor.citation.order))]
                ),
                _vm._v(" "),
                _c("i", {
                  staticClass: "fas fa-angle-down fa-lg btn-3",
                  class: { "btn-disabled": _vm.lastCited },
                  on: {
                    click: function($event) {
                      return _vm.moveCitation(1)
                    }
                  }
                }),
                _vm._v(" "),
                _c("i", {
                  staticClass: "fas fa-minus btn-4",
                  attrs: { title: "Remove from citation" },
                  on: { click: _vm.toggleCitation }
                })
              ]
            : _vm._e(),
          _vm._v(" "),
          !_vm.contributor.citeable
            ? [
                _c("i", {
                  staticClass: "fas fa-plus btn-2",
                  attrs: { title: "Include in citation" },
                  on: { click: _vm.toggleCitation }
                })
              ]
            : _vm._e()
        ],
        2
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          !_vm.contributor.meta.is_editing
            ? _c("ShowAgent", {
                attrs: { "contributor-id": _vm.contributorId },
                on: { "toggle-edit": _vm.toggleAgentEdit }
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.contributor.meta.is_editing
            ? _c("EditAgent", {
                attrs: { "contributor-id": _vm.contributorId },
                on: { "toggle-edit": _vm.toggleAgentEdit }
              })
            : _vm._e(),
          _vm._v(" "),
          _c(
            "div",
            { staticClass: "agent-activities" },
            [
              _vm._l(_vm.contributor.activities, function(activity) {
                return _c("ShowActivity", {
                  key: activity.id,
                  attrs: { "activity-id": activity.id },
                  on: {
                    "toggle-edit": function($event) {
                      return _vm.toggleActivityEdit(activity.id)
                    }
                  }
                })
              }),
              _vm._v(" "),
              _c(
                "span",
                { staticClass: "icon-btn", on: { click: _vm.newActivity } },
                [
                  _c("i", {
                    staticClass: "fas fa-lg",
                    class: _vm.activityCreating
                      ? "fa-times-circle"
                      : "fa-plus-circle"
                  })
                ]
              )
            ],
            2
          ),
          _vm._v(" "),
          _vm.activityEditing
            ? _c("EditActivity", {
                attrs: { "activity-id": _vm.activityEditing },
                on: { "toggle-edit": _vm.saveActivityEdit }
              })
            : _vm._e()
        ],
        1
      )
    ]
  )
}
var ContributionBlockvue_type_template_id_985c5846_staticRenderFns = []
ContributionBlockvue_type_template_id_985c5846_render._withStripped = true


// CONCATENATED MODULE: ./src/components/ContributionBlock.vue?vue&type=template&id=985c5846&

// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js
var vuex_esm = __webpack_require__(3);

// EXTERNAL MODULE: ./src/components/Common.vue + 5 modules
var Common = __webpack_require__(25);

// EXTERNAL MODULE: ./src/models/main.js
var models_main = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ContributionBlock.vue?vue&type=script&lang=js&
function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function _objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var ShowAgent=function(){return __webpack_require__.e(/* import() | show-agent */ 4).then(__webpack_require__.bind(null, 75))},ShowActivity=function(){return __webpack_require__.e(/* import() | show-activity */ 3).then(__webpack_require__.bind(null, 76))},EditAgent=function(){return __webpack_require__.e(/* import() | edit-agent */ 1).then(__webpack_require__.bind(null, 73))},EditActivity=function(){return __webpack_require__.e(/* import() | edit-activity */ 0).then(__webpack_require__.bind(null, 74))};/* harmony default export */ var ContributionBlockvue_type_script_lang_js_ = ({name:"ContributionBlock",extends:Common["a" /* default */],components:{EditAgent:EditAgent,EditActivity:EditActivity,ShowActivity:ShowActivity,ShowAgent:ShowAgent},data:function data(){return{activityEditing:null}},computed:_objectSpread(_objectSpread({},Object(vuex_esm["e" /* mapState */])(["packageId","controlledLists"])),{},{activityCreating:function activityCreating(){return!!this.activityEditing&&models_main["a" /* Activity */].query()["with"]("meta").find(this.activityEditing).meta.is_new},lastCited:function lastCited(){if(this.contributor.citeable)return models_main["c" /* Agent */].query().where("isActive",!0).where("citeable",!0).count()===this.contributor.citation.order}}),methods:{toggleAgentEdit:function toggleAgentEdit(){models_main["c" /* Agent */].updateMeta(this.contributorId,{is_editing:!this.contributor.meta.is_editing})},toggleActivityEdit:function toggleActivityEdit(a){this.activityEditing=a&&this.activityEditing!==a?a:null},saveActivityEdit:function saveActivityEdit(){this.activityEditing=null},newActivity:function newActivity(){var a=this;this.activityCreating?(models_main["a" /* Activity */]["delete"](this.activityEditing),this.activityEditing=null):models_main["a" /* Activity */].insert({data:{agent_id:this.contributorId,package_id:this.packageId,meta:{is_new:!0}}}).then(function(b){a.activityEditing=b.activities[0].id})},moveCitation:function moveCitation(a){var b=this,c=this.contributor.citation.order,d=c+a;1>d||this.lastCited&&1===a||models_main["d" /* Citation */].update({where:function where(a){return a.order===d},data:{order:c}}).then(function(){models_main["d" /* Citation */].update({where:b.contributor.citation.id,data:{order:d}})})},toggleCitation:function toggleCitation(){if(this.contributor.citeable)models_main["d" /* Citation */].updateMeta(this.contributor.citation.id,{to_delete:!0});else{var a=models_main["c" /* Agent */].query().where("isActive",!0).where("citeable",!0).count();this.contributor.citation?(models_main["d" /* Citation */].update({where:this.contributor.citation.id,data:{order:a+1}}),models_main["d" /* Citation */].updateMeta(this.contributor.citation.id,{to_delete:!1})):models_main["d" /* Citation */].insert({data:{activity:"[citation]",scheme:"internal",agent_id:this.contributorId,package_id:this.packageId,order:a+1,meta:{is_new:!0}}})}}},watch:{activityEditing:function activityEditing(a,b){b&&models_main["a" /* Activity */].updateMeta(b,{is_editing:!1})["catch"](function(){}),a&&models_main["a" /* Activity */].updateMeta(a,{is_editing:!0})["catch"](function(){})}}});
// CONCATENATED MODULE: ./src/components/ContributionBlock.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ContributionBlockvue_type_script_lang_js_ = (ContributionBlockvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1);

// CONCATENATED MODULE: ./src/components/ContributionBlock.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_ContributionBlockvue_type_script_lang_js_,
  ContributionBlockvue_type_template_id_985c5846_render,
  ContributionBlockvue_type_template_id_985c5846_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/ContributionBlock.vue"
/* harmony default export */ var ContributionBlock = (component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/AgentSearch.vue?vue&type=template&id=0abf6c8d&
var AgentSearchvue_type_template_id_0abf6c8d_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "contribution-block-new" },
    [
      _c(
        "div",
        { staticClass: "new-contribution-header" },
        [
          _vm._m(0),
          _vm._v(" "),
          _c("div", { staticClass: "toggle-wrapper" }, [
            _c("span", { staticClass: "toggle-label" }, [
              _vm._v("Include external results?")
            ]),
            _vm._v(" "),
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.useExternalSearch,
                  expression: "useExternalSearch"
                }
              ],
              staticClass: "toggle-switch",
              attrs: { id: "external-search-toggle", type: "checkbox" },
              domProps: {
                checked: Array.isArray(_vm.useExternalSearch)
                  ? _vm._i(_vm.useExternalSearch, null) > -1
                  : _vm.useExternalSearch
              },
              on: {
                change: [
                  function($event) {
                    var $$a = _vm.useExternalSearch,
                      $$el = $event.target,
                      $$c = $$el.checked ? true : false
                    if (Array.isArray($$a)) {
                      var $$v = null,
                        $$i = _vm._i($$a, $$v)
                      if ($$el.checked) {
                        $$i < 0 && (_vm.useExternalSearch = $$a.concat([$$v]))
                      } else {
                        $$i > -1 &&
                          (_vm.useExternalSearch = $$a
                            .slice(0, $$i)
                            .concat($$a.slice($$i + 1)))
                      }
                    } else {
                      _vm.useExternalSearch = $$c
                    }
                  },
                  _vm.redoSearch
                ]
              }
            }),
            _vm._v(" "),
            _c("label", { attrs: { for: "external-search-toggle" } }),
            _vm._v(" "),
            _vm._m(1)
          ]),
          _vm._v(" "),
          _c("autocomplete-field", {
            attrs: {
              options: _vm.agentOptions,
              "item-id": "new-agent",
              delay: 1000,
              loading: _vm.searchLoading,
              failed: _vm.searchFailed
            },
            on: { typing: _vm.updateAgentOptions, input: _vm.setAgent },
            model: {
              value: _vm.newAgent,
              callback: function($$v) {
                _vm.newAgent = $$v
              },
              expression: "newAgent"
            }
          })
        ],
        1
      ),
      _vm._v(" "),
      _vm.newAgent && _vm.newAgent.id
        ? _c("ShowAgent", { attrs: { "contributor-id": _vm.newAgent.id } })
        : _vm._e(),
      _vm._v(" "),
      _vm.activity
        ? _c("EditActivity", {
            attrs: { "activity-id": _vm.activity.id },
            on: { "toggle-edit": _vm.finish }
          })
        : _vm._e()
    ],
    1
  )
}
var AgentSearchvue_type_template_id_0abf6c8d_staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", [_c("b", [_vm._v("Add new contributor:")])])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "help-icon" }, [
      _c("i", { staticClass: "fas fa-question-circle" }),
      _vm._v(" "),
      _c("div", { staticClass: "help-tooltip", attrs: { role: "tooltip" } }, [
        _vm._v(
          "\n                    Search external APIs (e.g. ORCID and ROR) for contributors that have not yet\n                    been imported. This may take several seconds.\n                "
        )
      ])
    ])
  }
]
AgentSearchvue_type_template_id_0abf6c8d_render._withStripped = true


// CONCATENATED MODULE: ./src/components/AgentSearch.vue?vue&type=template&id=0abf6c8d&

// EXTERNAL MODULE: ./src/api.js
var src_api = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/axios/index.js
var axios = __webpack_require__(14);
var axios_default = /*#__PURE__*/__webpack_require__.n(axios);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/AgentSearch.vue?vue&type=script&lang=js&
function AgentSearchvue_type_script_lang_js_ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function AgentSearchvue_type_script_lang_js_objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?AgentSearchvue_type_script_lang_js_ownKeys(Object(b),!0).forEach(function(c){AgentSearchvue_type_script_lang_js_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):AgentSearchvue_type_script_lang_js_ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function AgentSearchvue_type_script_lang_js_defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var AgentSearchvue_type_script_lang_js_ShowAgent=function(){return __webpack_require__.e(/* import() | show-agent */ 4).then(__webpack_require__.bind(null, 75))};var AgentSearchvue_type_script_lang_js_EditActivity=function(){return __webpack_require__.e(/* import() | edit-activity */ 0).then(__webpack_require__.bind(null, 74))};/* harmony default export */ var AgentSearchvue_type_script_lang_js_ = ({name:"AgentSearch",components:{EditActivity:AgentSearchvue_type_script_lang_js_EditActivity,ShowAgent:AgentSearchvue_type_script_lang_js_ShowAgent},data:function data(){return{newAgent:null,agentOptions:{},optionSearchInput:null,searchFailed:null,useExternalSearch:!1,queuedSearches:0// handles cancelled/overwritten requests
}},computed:AgentSearchvue_type_script_lang_js_objectSpread(AgentSearchvue_type_script_lang_js_objectSpread({},Object(vuex_esm["e" /* mapState */])(["controlledLists","packageId"])),{},{searchLoading:function searchLoading(){return 0<this.queuedSearches},activity:function activity(){return this.newAgent&&this.newAgent.activities?this.newAgent.activities.slice(-1)[0]:null}}),methods:{updateAgentOptions:function updateAgentOptions(a){var b=this;return""===a||null===a?(this.optionSearchInput=null,void(this.agentOptions=[])):void(a===this.optionSearchInput||(this.optionSearchInput=a,this.agentOptions={},this.searchFailed=null,this.queuedSearches++,Object(src_api["b" /* get */])("agent_list?q="+a,"internalSearch").then(function(a){b.$set(b.agentOptions,"default",a.map(function(a){var b=a.display_name;return a.external_id&&(b+=" (".concat(a.external_id,")")),{label:b,value:a}}).filter(function(a){return!models_main["c" /* Agent */].query().whereHas("meta",function(a){a.where("is_hidden",!1)}).where("id",a.value.id).exists()}))})["catch"](function(a){axios_default.a.isCancel(a)||(Object(src_api["a" /* cancelAll */])(),b.searchFailed=a)})["finally"](function(){b.queuedSearches--}),this.useExternalSearch&&(this.queuedSearches++,Object(src_api["b" /* get */])("agent_external_search?q="+a,"externalSearch").then(function(a){a&&Object.entries(a).forEach(function(a){var c=b.controlledLists.agentIdSchemes[a[0]];b.$set(b.agentOptions,c.label,a[1].records.map(function(a){var b=a.name;return a.family_name&&(b=a.family_name+", "+a.given_names),{label:b,value:a}}))})})["catch"](function(a){axios_default.a.isCancel(a)||(Object(src_api["a" /* cancelAll */])(),b.searchFailed=a)})["finally"](function(){b.queuedSearches--}))))},redoSearch:function redoSearch(){var a=this.optionSearchInput;this.optionSearchInput=null,this.updateAgentOptions(a)},finish:function finish(){models_main["c" /* Agent */].updateMeta(this.newAgent.id,{is_hidden:!1}),this.newAgent=null,this.optionSearchInput=null},setAgent:function setAgent(a){var b=this;if(!a)return void(this.newAgent=null);var c=null,d=null;a.id?c=models_main["c" /* Agent */].query().where("id",a.id).get():a.external_id&&(c=models_main["c" /* Agent */].query().where("external_id",a.external_id).where("external_id_scheme",a.external_id_scheme).get());var e;c&&0<c.length?(d=c[0].id,e=function(){return models_main["c" /* Agent */].updateMeta(d,{is_hidden:!0,to_delete:!1,is_new:!0})}):(a.meta={is_hidden:!0,to_delete:!1,is_new:!0},e=function(){return models_main["c" /* Agent */].insert({data:a}).then(function(a){d=a.agents[0].id})}),e().then(function(){models_main["a" /* Activity */].insert({data:{agent_id:d,package_id:b.packageId,meta:{is_new:!0,is_editing:!0}}}).then(function(){var a=models_main["c" /* Agent */].query().where("isActive",!0).where("citeable",!0).count();return models_main["d" /* Citation */].insert({data:{agent_id:d,package_id:b.packageId,order:a+1,meta:{is_new:!0}}})}).then(function(){b.newAgent=models_main["c" /* Agent */].find(d)})})}}});
// CONCATENATED MODULE: ./src/components/AgentSearch.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_AgentSearchvue_type_script_lang_js_ = (AgentSearchvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/AgentSearch.vue





/* normalize component */

var AgentSearch_component = Object(componentNormalizer["a" /* default */])(
  components_AgentSearchvue_type_script_lang_js_,
  AgentSearchvue_type_template_id_0abf6c8d_render,
  AgentSearchvue_type_template_id_0abf6c8d_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var AgentSearch_api; }
AgentSearch_component.options.__file = "src/components/AgentSearch.vue"
/* harmony default export */ var AgentSearch = (AgentSearch_component.exports);
// EXTERNAL MODULE: ./node_modules/vuedraggable/dist/vuedraggable.umd.js
var vuedraggable_umd = __webpack_require__(37);
var vuedraggable_umd_default = /*#__PURE__*/__webpack_require__.n(vuedraggable_umd);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CitationPreview.vue?vue&type=template&id=4faea061&
var CitationPreviewvue_type_template_id_4faea061_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "citation-preview" }, [
    _c(
      "div",
      { staticClass: "citation-preview-header" },
      [
        _c("span", { staticClass: "citation-preview-title" }, [
          _vm._v("Citation preview")
        ]),
        _vm._v(" "),
        _c("help-tooltip", [
          _vm._v(
            "\n            This is a rough guide to help visualise how changes made to the contributors below will affect the\n            citation output.\n            "
          ),
          _c("br"),
          _vm._v(
            "\n            Only numbered contributors are counted as citeable authors. Click the plus icon to make\n            a contributor citeable.\n        "
          )
        ])
      ],
      1
    ),
    _vm._v(" "),
    _c("div", { staticClass: "citation-preview-body" }, [
      _c(
        "div",
        { staticClass: "scroll-select", style: { width: _vm.selectWidth } },
        [
          _c("i", {
            staticClass: "fas fa-angle-left fa-lg",
            on: {
              click: function($event) {
                return _vm.scrollFormat(-1)
              }
            }
          }),
          _vm._v(" "),
          _c("span", [
            _vm._v(_vm._s(_vm.availableFormats[_vm.citationFormat]))
          ]),
          _vm._v(" "),
          _c("i", {
            staticClass: "fas fa-angle-right fa-lg",
            on: {
              click: function($event) {
                return _vm.scrollFormat(1)
              }
            }
          })
        ]
      ),
      _vm._v(" "),
      _c("div", { staticClass: "citation-string" }, [
        _vm._v(_vm._s(_vm.citation))
      ])
    ])
  ])
}
var CitationPreviewvue_type_template_id_4faea061_staticRenderFns = []
CitationPreviewvue_type_template_id_4faea061_render._withStripped = true


// CONCATENATED MODULE: ./src/components/CitationPreview.vue?vue&type=template&id=4faea061&

// EXTERNAL MODULE: ./node_modules/@citation-js/core/lib-mjs/index.js + 39 modules
var lib_mjs = __webpack_require__(9);

// CONCATENATED MODULE: ./vendor/ieee.csl
/* harmony default export */ var ieee = ("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<style xmlns=\"http://purl.org/net/xbiblio/csl\" class=\"in-text\" version=\"1.0\" demote-non-dropping-particle=\"sort-only\">\n  <info>\n    <title>IEEE</title>\n    <id>http://www.zotero.org/styles/ieee</id>\n    <link href=\"http://www.zotero.org/styles/ieee\" rel=\"self\"/>\n    <link href=\"https://ieeeauthorcenter.ieee.org/wp-content/uploads/IEEE-Reference-Guide.pdf\" rel=\"documentation\"/>\n    <link href=\"https://journals.ieeeauthorcenter.ieee.org/your-role-in-article-production/ieee-editorial-style-manual/\" rel=\"documentation\"/>\n    <author>\n      <name>Michael Berkowitz</name>\n      <email>mberkowi@gmu.edu</email>\n    </author>\n    <contributor>\n      <name>Julian Onions</name>\n      <email>julian.onions@gmail.com</email>\n    </contributor>\n    <contributor>\n      <name>Rintze Zelle</name>\n      <uri>http://twitter.com/rintzezelle</uri>\n    </contributor>\n    <contributor>\n      <name>Stephen Frank</name>\n      <uri>http://www.zotero.org/sfrank</uri>\n    </contributor>\n    <contributor>\n      <name>Sebastian Karcher</name>\n    </contributor>\n    <contributor>\n      <name>Giuseppe Silano</name>\n      <email>g.silano89@gmail.com</email>\n      <uri>http://giuseppesilano.net</uri>\n    </contributor>\n    <contributor>\n      <name>Patrick O'Brien</name>\n    </contributor>\n    <contributor>\n      <name>Brenton M. Wiernik</name>\n    </contributor>\n    <category citation-format=\"numeric\"/>\n    <category field=\"engineering\"/>\n    <category field=\"generic-base\"/>\n    <summary>IEEE style as per the 2018 guidelines, V 11.12.2018.</summary>\n    <updated>2019-12-20T09:14:19+00:00</updated>\n    <rights license=\"http://creativecommons.org/licenses/by-sa/3.0/\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights>\n  </info>\n  <locale xml:lang=\"en\">\n    <terms>\n      <term name=\"chapter\" form=\"short\">ch.</term>\n      <term name=\"presented at\">presented at the</term>\n      <term name=\"available at\">available</term>\n    </terms>\n  </locale>\n  <!-- Macros -->\n  <macro name=\"status\">\n    <choose>\n      <if variable=\"page issue volume\" match=\"none\">\n        <text variable=\"status\" text-case=\"capitalize-first\" suffix=\"\" font-weight=\"bold\"/>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"edition\">\n    <choose>\n      <if type=\"bill book chapter graphic legal_case legislation motion_picture paper-conference report song\" match=\"any\">\n        <choose>\n          <if is-numeric=\"edition\">\n            <group delimiter=\" \">\n              <number variable=\"edition\" form=\"ordinal\"/>\n              <text term=\"edition\" form=\"short\"/>\n            </group>\n          </if>\n          <else>\n            <text variable=\"edition\" text-case=\"capitalize-first\" suffix=\".\"/>\n          </else>\n        </choose>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"issued\">\n    <choose>\n      <if type=\"article-journal report\" match=\"any\">\n        <date variable=\"issued\">\n          <date-part name=\"month\" form=\"short\" suffix=\" \"/>\n          <date-part name=\"year\" form=\"long\"/>\n        </date>\n      </if>\n      <else-if type=\"bill book chapter graphic legal_case legislation motion_picture song thesis\" match=\"any\">\n        <date variable=\"issued\">\n          <date-part name=\"year\" form=\"long\"/>\n        </date>\n      </else-if>\n      <else-if type=\"paper-conference\" match=\"any\">\n        <date variable=\"issued\">\n          <date-part name=\"month\" form=\"short\"/>\n          <date-part name=\"year\" prefix=\" \"/>\n        </date>\n      </else-if>\n      <else>\n        <date variable=\"issued\">\n          <date-part name=\"month\" form=\"short\" suffix=\" \"/>\n          <date-part name=\"day\" form=\"numeric-leading-zeros\" suffix=\", \"/>\n          <date-part name=\"year\"/>\n        </date>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"author\">\n    <names variable=\"author\">\n      <name and=\"text\" et-al-min=\"7\" et-al-use-first=\"1\" initialize-with=\". \"/>\n      <label form=\"short\" prefix=\", \" text-case=\"capitalize-first\"/>\n      <et-al font-style=\"italic\"/>\n      <substitute>\n        <names variable=\"editor\"/>\n        <names variable=\"translator\"/>\n      </substitute>\n    </names>\n  </macro>\n  <macro name=\"editor\">\n    <names variable=\"editor\">\n      <name initialize-with=\". \" delimiter=\", \" and=\"text\"/>\n      <label form=\"short\" prefix=\", \" text-case=\"capitalize-first\"/>\n    </names>\n  </macro>\n  <macro name=\"locators\">\n    <group delimiter=\", \">\n      <text macro=\"edition\"/>\n      <group delimiter=\" \">\n        <text term=\"volume\" form=\"short\"/>\n        <number variable=\"volume\" form=\"numeric\"/>\n      </group>\n      <group delimiter=\" \">\n        <number variable=\"number-of-volumes\" form=\"numeric\"/>\n        <text term=\"volume\" form=\"short\" plural=\"true\"/>\n      </group>\n      <group delimiter=\" \">\n        <text term=\"issue\" form=\"short\"/>\n        <number variable=\"issue\" form=\"numeric\"/>\n      </group>\n    </group>\n  </macro>\n  <macro name=\"title\">\n    <choose>\n      <if type=\"bill book graphic legal_case legislation motion_picture song\" match=\"any\">\n        <text variable=\"title\" font-style=\"italic\"/>\n      </if>\n      <else>\n        <text variable=\"title\" quotes=\"true\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"publisher\">\n    <choose>\n      <if type=\"bill book chapter graphic legal_case legislation motion_picture paper-conference song\" match=\"any\">\n        <group delimiter=\": \">\n          <text variable=\"publisher-place\"/>\n          <text variable=\"publisher\"/>\n        </group>\n      </if>\n      <else>\n        <group delimiter=\", \">\n          <text variable=\"publisher\"/>\n          <text variable=\"publisher-place\"/>\n        </group>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"event\">\n    <choose>\n      <if type=\"paper-conference speech\" match=\"any\">\n        <choose>\n          <!-- Published Conference Paper -->\n          <if variable=\"collection-editor editor editorial-director issue page volume\" match=\"any\">\n            <group delimiter=\", \">\n              <group delimiter=\" \">\n                <text term=\"in\"/>\n                <text variable=\"container-title\" font-style=\"italic\"/>\n              </group>\n              <text variable=\"event-place\"/>\n            </group>\n          </if>\n          <!-- Unpublished Conference Paper -->\n          <else>\n            <group delimiter=\", \">\n              <group delimiter=\" \">\n                <text term=\"presented at\"/>\n                <text variable=\"event\"/>\n              </group>\n              <text variable=\"event-place\"/>\n            </group>\n          </else>\n        </choose>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"access\">\n    <choose>\n      <if type=\"webpage post post-weblog\" match=\"any\">\n        <choose>\n          <if variable=\"URL\">\n            <group delimiter=\" \">\n              <text variable=\"URL\"/>\n              <group delimiter=\" \" prefix=\"(\" suffix=\")\">\n                <text term=\"accessed\"/>\n                <date variable=\"accessed\">\n                  <date-part name=\"month\" form=\"short\" strip-periods=\"false\"/>\n                  <date-part name=\"day\" form=\"numeric-leading-zeros\" prefix=\" \" suffix=\", \"/>\n                  <date-part name=\"year\" form=\"long\"/>\n                </date>\n              </group>\n            </group>\n          </if>\n        </choose>\n      </if>\n      <else-if match=\"any\" variable=\"DOI\">\n        <text variable=\"DOI\" prefix=\"doi: \"/>\n      </else-if>\n      <else>\n        <group delimiter=\". \">\n          <group delimiter=\": \">\n            <text term=\"accessed\" text-case=\"capitalize-first\"/>\n            <date variable=\"accessed\">\n              <date-part name=\"month\" form=\"short\" suffix=\" \"/>\n              <date-part name=\"day\" form=\"numeric-leading-zeros\" suffix=\", \"/>\n              <date-part name=\"year\"/>\n            </date>\n          </group>\n          <text term=\"online\" prefix=\"[\" suffix=\"]\" text-case=\"capitalize-first\"/>\n          <group delimiter=\": \">\n            <text term=\"available at\" text-case=\"capitalize-first\"/>\n            <text variable=\"URL\"/>\n          </group>\n        </group>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"page\">\n    <choose>\n      <if type=\"article-journal\" variable=\"number\" match=\"all\">\n        <group delimiter=\" \">\n          <text value=\"Art.\"/>\n          <text term=\"issue\" form=\"short\"/>\n          <text variable=\"number\"/>\n        </group>\n      </if>\n      <else>\n        <group delimiter=\" \">\n          <label variable=\"page\" form=\"short\"/>\n          <text variable=\"page\"/>\n        </group>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"citation-locator\">\n    <group delimiter=\" \">\n      <choose>\n        <if locator=\"page\">\n          <label variable=\"locator\" form=\"short\"/>\n        </if>\n        <else>\n          <label variable=\"locator\" form=\"short\" text-case=\"capitalize-first\"/>\n        </else>\n      </choose>\n      <text variable=\"locator\"/>\n    </group>\n  </macro>\n  <!-- Citation -->\n  <citation collapse=\"citation-number\">\n    <sort>\n      <key variable=\"citation-number\"/>\n    </sort>\n    <layout delimiter=\", \">\n      <group prefix=\"[\" suffix=\"]\" delimiter=\", \">\n        <text variable=\"citation-number\"/>\n        <text macro=\"citation-locator\"/>\n      </group>\n    </layout>\n  </citation>\n  <!-- Bibliography -->\n  <bibliography entry-spacing=\"0\" second-field-align=\"flush\">\n    <layout suffix=\".\">\n      <!-- Citation Number -->\n      <text variable=\"citation-number\" prefix=\"[\" suffix=\"]\"/>\n      <!-- Author(s) -->\n      <text macro=\"author\" suffix=\", \"/>\n      <!-- Rest of Citation -->\n      <choose>\n        <!-- Specific Formats -->\n        <if type=\"article-journal\">\n          <group delimiter=\", \">\n            <text macro=\"title\"/>\n            <text variable=\"container-title\" font-style=\"italic\" form=\"short\"/>\n            <text macro=\"locators\"/>\n            <text macro=\"page\"/>\n            <text macro=\"issued\"/>\n            <text macro=\"status\"/>\n            <text macro=\"access\"/>\n          </group>\n        </if>\n        <else-if type=\"paper-conference speech\" match=\"any\">\n          <group delimiter=\", \">\n            <text macro=\"title\"/>\n            <text macro=\"event\"/>\n            <text macro=\"issued\"/>\n            <text macro=\"locators\"/>\n            <text macro=\"page\"/>\n            <text macro=\"status\"/>\n            <text macro=\"access\"/>\n          </group>\n        </else-if>\n        <else-if type=\"report\">\n          <group delimiter=\". \">\n            <group delimiter=\", \">\n              <text macro=\"title\"/>\n              <text macro=\"publisher\"/>\n              <group delimiter=\" \">\n                <text variable=\"genre\"/>\n                <text variable=\"number\"/>\n              </group>\n              <text macro=\"issued\"/>\n            </group>\n            <text macro=\"access\"/>\n          </group>\n        </else-if>\n        <else-if type=\"thesis\">\n          <group delimiter=\", \">\n            <text macro=\"title\"/>\n            <text variable=\"genre\"/>\n            <text macro=\"publisher\"/>\n            <text macro=\"issued\"/>\n          </group>\n        </else-if>\n        <else-if type=\"webpage post-weblog post\" match=\"any\">\n          <group delimiter=\", \" suffix=\". \">\n            <text macro=\"title\"/>\n            <text variable=\"container-title\" font-style=\"italic\"/>\n            <text macro=\"issued\"/>\n          </group>\n          <text macro=\"access\"/>\n        </else-if>\n        <else-if type=\"patent\">\n          <group delimiter=\", \">\n            <text macro=\"title\"/>\n            <text variable=\"number\"/>\n            <text macro=\"issued\"/>\n          </group>\n        </else-if>\n        <!-- Generic/Fallback Formats -->\n        <else-if type=\"bill book graphic legal_case legislation motion_picture report song\" match=\"any\">\n          <group delimiter=\", \" suffix=\". \">\n            <text macro=\"title\"/>\n            <text macro=\"locators\"/>\n          </group>\n          <group delimiter=\", \">\n            <text macro=\"publisher\"/>\n            <text macro=\"issued\"/>\n            <text macro=\"page\"/>\n          </group>\n        </else-if>\n        <else-if type=\"article-magazine article-newspaper broadcast interview manuscript map patent personal_communication song speech thesis webpage\" match=\"any\">\n          <group delimiter=\", \">\n            <text macro=\"title\"/>\n            <text variable=\"container-title\" font-style=\"italic\"/>\n            <text macro=\"locators\"/>\n            <text macro=\"publisher\"/>\n            <text macro=\"page\"/>\n            <text macro=\"issued\"/>\n          </group>\n        </else-if>\n        <else-if type=\"chapter paper-conference\" match=\"any\">\n          <group delimiter=\", \" suffix=\", \">\n            <text macro=\"title\"/>\n            <group delimiter=\" \">\n              <text term=\"in\"/>\n              <text variable=\"container-title\" font-style=\"italic\"/>\n            </group>\n            <text macro=\"locators\"/>\n          </group>\n          <text macro=\"editor\" suffix=\" \"/>\n          <group delimiter=\", \">\n            <text macro=\"publisher\"/>\n            <text macro=\"issued\"/>\n            <text macro=\"page\"/>\n          </group>\n        </else-if>\n        <else>\n          <group delimiter=\", \" suffix=\". \">\n            <text macro=\"title\"/>\n            <text variable=\"container-title\" font-style=\"italic\"/>\n            <text macro=\"locators\"/>\n          </group>\n          <group delimiter=\", \">\n            <text macro=\"publisher\"/>\n            <text macro=\"page\"/>\n            <text macro=\"issued\"/>\n            <text macro=\"access\"/>\n          </group>\n        </else>\n      </choose>\n    </layout>\n  </bibliography>\n</style>\n");
// CONCATENATED MODULE: ./vendor/chicago-author-date.csl
/* harmony default export */ var chicago_author_date = ("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<style xmlns=\"http://purl.org/net/xbiblio/csl\" class=\"in-text\" version=\"1.0\" demote-non-dropping-particle=\"display-and-sort\" page-range-format=\"chicago\">\n  <info>\n    <title>Chicago Manual of Style 17th edition (author-date)</title>\n    <id>http://www.zotero.org/styles/chicago-author-date</id>\n    <link href=\"http://www.zotero.org/styles/chicago-author-date\" rel=\"self\"/>\n    <link href=\"http://www.chicagomanualofstyle.org/tools_citationguide.html\" rel=\"documentation\"/>\n    <author>\n      <name>Julian Onions</name>\n      <email>julian.onions@gmail.com</email>\n    </author>\n    <contributor>\n      <name>Sebastian Karcher</name>\n    </contributor>\n    <contributor>\n      <name>Richard Karnesky</name>\n      <email>karnesky+zotero@gmail.com</email>\n      <uri>http://arc.nucapt.northwestern.edu/Richard_Karnesky</uri>\n    </contributor>\n    <contributor>\n      <name>Andrew Dunning</name>\n      <email>andrew.dunning@utoronto.ca</email>\n      <uri>https://orcid.org/0000-0003-0464-5036</uri>\n    </contributor>\n    <contributor>\n      <name>Matthew Roth</name>\n      <email>matthew.g.roth@yale.edu</email>\n      <uri> https://orcid.org/0000-0001-7902-6331</uri>\n    </contributor>\n    <contributor>\n      <name>Brenton M. Wiernik</name>\n    </contributor>\n    <category citation-format=\"author-date\"/>\n    <category field=\"generic-base\"/>\n    <summary>The author-date variant of the Chicago style</summary>\n    <updated>2018-01-24T12:00:00+00:00</updated>\n    <rights license=\"http://creativecommons.org/licenses/by-sa/3.0/\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights>\n  </info>\n  <locale xml:lang=\"en\">\n    <terms>\n      <term name=\"editor\" form=\"verb-short\">ed.</term>\n      <term name=\"container-author\" form=\"verb\">by</term>\n      <term name=\"translator\" form=\"verb-short\">trans.</term>\n      <term name=\"editortranslator\" form=\"verb\">edited and translated by</term>\n      <term name=\"translator\" form=\"short\">trans.</term>\n    </terms>\n  </locale>\n  <macro name=\"secondary-contributors\">\n    <choose>\n      <if type=\"chapter entry-dictionary entry-encyclopedia paper-conference\" match=\"none\">\n        <group delimiter=\". \">\n          <names variable=\"editor translator\" delimiter=\". \">\n            <label form=\"verb\" text-case=\"capitalize-first\" suffix=\" \"/>\n            <name and=\"text\" delimiter=\", \"/>\n          </names>\n          <names variable=\"director\" delimiter=\". \">\n            <label form=\"verb\" text-case=\"capitalize-first\" suffix=\" \"/>\n            <name and=\"text\" delimiter=\", \"/>\n          </names>\n        </group>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"container-contributors\">\n    <choose>\n      <if type=\"chapter entry-dictionary entry-encyclopedia paper-conference\" match=\"any\">\n        <group prefix=\", \" delimiter=\", \">\n          <names variable=\"container-author\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \"/>\n            <name and=\"text\" delimiter=\", \"/>\n          </names>\n          <names variable=\"editor translator\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \"/>\n            <name and=\"text\" delimiter=\", \"/>\n          </names>\n        </group>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"editor\">\n    <names variable=\"editor\">\n      <name name-as-sort-order=\"first\" and=\"text\" sort-separator=\", \" delimiter=\", \" delimiter-precedes-last=\"always\"/>\n      <label form=\"short\" prefix=\", \"/>\n    </names>\n  </macro>\n  <macro name=\"translator\">\n    <names variable=\"translator\">\n      <name name-as-sort-order=\"first\" and=\"text\" sort-separator=\", \" delimiter=\", \" delimiter-precedes-last=\"always\"/>\n      <label form=\"short\" prefix=\", \"/>\n    </names>\n  </macro>\n  <macro name=\"recipient\">\n    <choose>\n      <if type=\"personal_communication\">\n        <choose>\n          <if variable=\"genre\">\n            <text variable=\"genre\" text-case=\"capitalize-first\"/>\n          </if>\n          <else>\n            <text term=\"letter\" text-case=\"capitalize-first\"/>\n          </else>\n        </choose>\n      </if>\n    </choose>\n    <names variable=\"recipient\" delimiter=\", \">\n      <label form=\"verb\" prefix=\" \" text-case=\"lowercase\" suffix=\" \"/>\n      <name and=\"text\" delimiter=\", \"/>\n    </names>\n  </macro>\n  <macro name=\"substitute-title\">\n    <choose>\n      <if type=\"article-magazine article-newspaper review review-book\" match=\"any\">\n        <text macro=\"container-title\"/>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"contributors\">\n    <group delimiter=\". \">\n      <names variable=\"author\">\n        <name and=\"text\" name-as-sort-order=\"first\" sort-separator=\", \" delimiter=\", \" delimiter-precedes-last=\"always\"/>\n        <label form=\"short\" prefix=\", \"/>\n        <substitute>\n          <names variable=\"editor\"/>\n          <names variable=\"translator\"/>\n          <names variable=\"director\"/>\n          <text macro=\"substitute-title\"/>\n          <text macro=\"title\"/>\n        </substitute>\n      </names>\n      <text macro=\"recipient\"/>\n    </group>\n  </macro>\n  <macro name=\"contributors-short\">\n    <names variable=\"author\">\n      <name form=\"short\" and=\"text\" delimiter=\", \" initialize-with=\". \"/>\n      <substitute>\n        <names variable=\"editor\"/>\n        <names variable=\"translator\"/>\n        <names variable=\"director\"/>\n        <text macro=\"substitute-title\"/>\n        <text macro=\"title\"/>\n      </substitute>\n    </names>\n  </macro>\n  <macro name=\"interviewer\">\n    <names variable=\"interviewer\" delimiter=\", \">\n      <label form=\"verb\" prefix=\" \" text-case=\"capitalize-first\" suffix=\" \"/>\n      <name and=\"text\" delimiter=\", \"/>\n    </names>\n  </macro>\n  <macro name=\"archive\">\n    <group delimiter=\". \">\n      <text variable=\"archive_location\" text-case=\"capitalize-first\"/>\n      <text variable=\"archive\"/>\n      <text variable=\"archive-place\"/>\n    </group>\n  </macro>\n  <macro name=\"access\">\n    <group delimiter=\". \">\n      <choose>\n        <if type=\"graphic report\" match=\"any\">\n          <text macro=\"archive\"/>\n        </if>\n        <else-if type=\"article-journal bill book chapter legal_case legislation motion_picture paper-conference\" match=\"none\">\n          <text macro=\"archive\"/>\n        </else-if>\n      </choose>\n      <choose>\n        <if type=\"webpage post-weblog\" match=\"any\">\n          <date variable=\"issued\" form=\"text\"/>\n        </if>\n      </choose>\n      <choose>\n        <if variable=\"issued\" match=\"none\">\n          <group delimiter=\" \">\n            <text term=\"accessed\" text-case=\"capitalize-first\"/>\n            <date variable=\"accessed\" form=\"text\"/>\n          </group>\n        </if>\n      </choose>\n      <choose>\n        <if type=\"legal_case\" match=\"none\">\n          <choose>\n            <if variable=\"DOI\">\n              <text variable=\"DOI\" prefix=\"https://doi.org/\"/>\n            </if>\n            <else>\n              <text variable=\"URL\"/>\n            </else>\n          </choose>\n        </if>\n      </choose>\n    </group>\n  </macro>\n  <macro name=\"title\">\n    <choose>\n      <if variable=\"title\" match=\"none\">\n        <choose>\n          <if type=\"personal_communication\" match=\"none\">\n            <text variable=\"genre\" text-case=\"capitalize-first\"/>\n          </if>\n        </choose>\n      </if>\n      <else-if type=\"bill book graphic legislation motion_picture song\" match=\"any\">\n        <text variable=\"title\" text-case=\"title\" font-style=\"italic\"/>\n        <group prefix=\" (\" suffix=\")\" delimiter=\" \">\n          <text term=\"version\"/>\n          <text variable=\"version\"/>\n        </group>\n      </else-if>\n      <else-if variable=\"reviewed-author\">\n        <choose>\n          <if variable=\"reviewed-title\">\n            <group delimiter=\". \">\n              <text variable=\"title\" text-case=\"title\" quotes=\"true\"/>\n              <group delimiter=\", \">\n                <text variable=\"reviewed-title\" text-case=\"title\" font-style=\"italic\" prefix=\"Review of \"/>\n                <names variable=\"reviewed-author\">\n                  <label form=\"verb-short\" text-case=\"lowercase\" suffix=\" \"/>\n                  <name and=\"text\" delimiter=\", \"/>\n                </names>\n              </group>\n            </group>\n          </if>\n          <else>\n            <group delimiter=\", \">\n              <text variable=\"title\" text-case=\"title\" font-style=\"italic\" prefix=\"Review of \"/>\n              <names variable=\"reviewed-author\">\n                <label form=\"verb-short\" text-case=\"lowercase\" suffix=\" \"/>\n                <name and=\"text\" delimiter=\", \"/>\n              </names>\n            </group>\n          </else>\n        </choose>\n      </else-if>\n      <else-if type=\"legal_case interview patent\" match=\"any\">\n        <text variable=\"title\"/>\n      </else-if>\n      <else>\n        <text variable=\"title\" text-case=\"title\" quotes=\"true\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"edition\">\n    <choose>\n      <if type=\"bill book graphic legal_case legislation motion_picture report song\" match=\"any\">\n        <choose>\n          <if is-numeric=\"edition\">\n            <group delimiter=\" \" prefix=\". \">\n              <number variable=\"edition\" form=\"ordinal\"/>\n              <text term=\"edition\" form=\"short\" strip-periods=\"true\"/>\n            </group>\n          </if>\n          <else>\n            <text variable=\"edition\" text-case=\"capitalize-first\" prefix=\". \"/>\n          </else>\n        </choose>\n      </if>\n      <else-if type=\"chapter entry-dictionary entry-encyclopedia paper-conference\" match=\"any\">\n        <choose>\n          <if is-numeric=\"edition\">\n            <group delimiter=\" \" prefix=\", \">\n              <number variable=\"edition\" form=\"ordinal\"/>\n              <text term=\"edition\" form=\"short\"/>\n            </group>\n          </if>\n          <else>\n            <text variable=\"edition\" prefix=\", \"/>\n          </else>\n        </choose>\n      </else-if>\n    </choose>\n  </macro>\n  <macro name=\"locators\">\n    <choose>\n      <if type=\"article-journal\">\n        <choose>\n          <if variable=\"volume\">\n            <text variable=\"volume\" prefix=\" \"/>\n            <group prefix=\" (\" suffix=\")\">\n              <choose>\n                <if variable=\"issue\">\n                  <text variable=\"issue\"/>\n                </if>\n                <else>\n                  <date variable=\"issued\">\n                    <date-part name=\"month\"/>\n                  </date>\n                </else>\n              </choose>\n            </group>\n          </if>\n          <else-if variable=\"issue\">\n            <group delimiter=\" \" prefix=\", \">\n              <text term=\"issue\" form=\"short\"/>\n              <text variable=\"issue\"/>\n              <date variable=\"issued\" prefix=\"(\" suffix=\")\">\n                <date-part name=\"month\"/>\n              </date>\n            </group>\n          </else-if>\n          <else>\n            <date variable=\"issued\" prefix=\", \">\n              <date-part name=\"month\"/>\n            </date>\n          </else>\n        </choose>\n      </if>\n      <else-if type=\"legal_case\">\n        <text variable=\"volume\" prefix=\", \"/>\n        <text variable=\"container-title\" prefix=\" \"/>\n        <text variable=\"page\" prefix=\" \"/>\n      </else-if>\n      <else-if type=\"bill book graphic legal_case legislation motion_picture report song\" match=\"any\">\n        <group prefix=\". \" delimiter=\". \">\n          <group>\n            <text term=\"volume\" form=\"short\" text-case=\"capitalize-first\" suffix=\" \"/>\n            <number variable=\"volume\" form=\"numeric\"/>\n          </group>\n          <group>\n            <number variable=\"number-of-volumes\" form=\"numeric\"/>\n            <text term=\"volume\" form=\"short\" prefix=\" \" plural=\"true\"/>\n          </group>\n        </group>\n      </else-if>\n      <else-if type=\"chapter entry-dictionary entry-encyclopedia paper-conference\" match=\"any\">\n        <choose>\n          <if variable=\"page\" match=\"none\">\n            <group prefix=\". \">\n              <text term=\"volume\" form=\"short\" text-case=\"capitalize-first\" suffix=\" \"/>\n              <number variable=\"volume\" form=\"numeric\"/>\n            </group>\n          </if>\n        </choose>\n      </else-if>\n    </choose>\n  </macro>\n  <macro name=\"locators-chapter\">\n    <choose>\n      <if type=\"chapter entry-dictionary entry-encyclopedia paper-conference\" match=\"any\">\n        <choose>\n          <if variable=\"page\">\n            <group prefix=\", \">\n              <text variable=\"volume\" suffix=\":\"/>\n              <text variable=\"page\"/>\n            </group>\n          </if>\n        </choose>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"locators-article\">\n    <choose>\n      <if type=\"article-newspaper\">\n        <group prefix=\", \" delimiter=\", \">\n          <group delimiter=\" \">\n            <text variable=\"edition\"/>\n            <text term=\"edition\"/>\n          </group>\n          <group>\n            <text term=\"section\" form=\"short\" suffix=\" \"/>\n            <text variable=\"section\"/>\n          </group>\n        </group>\n      </if>\n      <else-if type=\"article-journal\">\n        <choose>\n          <if variable=\"volume issue\" match=\"any\">\n            <text variable=\"page\" prefix=\": \"/>\n          </if>\n          <else>\n            <text variable=\"page\" prefix=\", \"/>\n          </else>\n        </choose>\n      </else-if>\n    </choose>\n  </macro>\n  <macro name=\"point-locators\">\n    <choose>\n      <if variable=\"locator\">\n        <choose>\n          <if locator=\"page\" match=\"none\">\n            <choose>\n              <if type=\"bill book graphic legal_case legislation motion_picture report song\" match=\"any\">\n                <choose>\n                  <if variable=\"volume\">\n                    <group>\n                      <text term=\"volume\" form=\"short\" suffix=\" \"/>\n                      <number variable=\"volume\" form=\"numeric\"/>\n                      <label variable=\"locator\" form=\"short\" prefix=\", \" suffix=\" \"/>\n                    </group>\n                  </if>\n                  <else>\n                    <label variable=\"locator\" form=\"short\" suffix=\" \"/>\n                  </else>\n                </choose>\n              </if>\n              <else>\n                <label variable=\"locator\" form=\"short\" suffix=\" \"/>\n              </else>\n            </choose>\n          </if>\n          <else-if type=\"bill book graphic legal_case legislation motion_picture report song\" match=\"any\">\n            <number variable=\"volume\" form=\"numeric\" suffix=\":\"/>\n          </else-if>\n        </choose>\n        <text variable=\"locator\"/>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"container-prefix\">\n    <text term=\"in\" text-case=\"capitalize-first\"/>\n  </macro>\n  <macro name=\"container-title\">\n    <choose>\n      <if type=\"chapter entry-dictionary entry-encyclopedia paper-conference\" match=\"any\">\n        <text macro=\"container-prefix\" suffix=\" \"/>\n      </if>\n    </choose>\n    <choose>\n      <if type=\"webpage\">\n        <text variable=\"container-title\" text-case=\"title\"/>\n      </if>\n      <else-if type=\"legal_case\" match=\"none\">\n        <group delimiter=\" \">\n          <text variable=\"container-title\" text-case=\"title\" font-style=\"italic\"/>\n          <choose>\n            <if type=\"post-weblog\">\n              <text value=\"(blog)\"/>\n            </if>\n          </choose>\n        </group>\n      </else-if>\n    </choose>\n  </macro>\n  <macro name=\"publisher\">\n    <group delimiter=\": \">\n      <text variable=\"publisher-place\"/>\n      <text variable=\"publisher\"/>\n    </group>\n  </macro>\n  <macro name=\"date\">\n    <choose>\n      <if variable=\"issued\">\n        <group delimiter=\" \">\n          <date variable=\"original-date\" form=\"text\" date-parts=\"year\" prefix=\"(\" suffix=\")\"/>\n          <date variable=\"issued\">\n            <date-part name=\"year\"/>\n          </date>\n        </group>\n      </if>\n      <else-if variable=\"status\">\n        <text variable=\"status\" text-case=\"capitalize-first\"/>\n      </else-if>\n      <else>\n        <text term=\"no date\" form=\"short\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"date-in-text\">\n    <choose>\n      <if variable=\"issued\">\n        <group delimiter=\" \">\n          <date variable=\"original-date\" form=\"text\" date-parts=\"year\" prefix=\"[\" suffix=\"]\"/>\n          <date variable=\"issued\">\n            <date-part name=\"year\"/>\n          </date>\n        </group>\n      </if>\n      <else-if variable=\"status\">\n        <text variable=\"status\"/>\n      </else-if>\n      <else>\n        <text term=\"no date\" form=\"short\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"day-month\">\n    <date variable=\"issued\">\n      <date-part name=\"month\"/>\n      <date-part name=\"day\" prefix=\" \"/>\n    </date>\n  </macro>\n  <macro name=\"collection-title\">\n    <choose>\n      <if match=\"none\" type=\"article-journal\">\n        <choose>\n          <if match=\"none\" is-numeric=\"collection-number\">\n            <group delimiter=\", \">\n              <text variable=\"collection-title\" text-case=\"title\"/>\n              <text variable=\"collection-number\"/>\n            </group>\n          </if>\n          <else>\n            <group delimiter=\" \">\n              <text variable=\"collection-title\" text-case=\"title\"/>\n              <text variable=\"collection-number\"/>\n            </group>\n          </else>\n        </choose>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"collection-title-journal\">\n    <choose>\n      <if type=\"article-journal\">\n        <group delimiter=\" \">\n          <text variable=\"collection-title\"/>\n          <text variable=\"collection-number\"/>\n        </group>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"event\">\n    <group delimiter=\" \">\n      <choose>\n        <if variable=\"genre\">\n          <text term=\"presented at\"/>\n        </if>\n        <else>\n          <text term=\"presented at\" text-case=\"capitalize-first\"/>\n        </else>\n      </choose>\n      <text variable=\"event\"/>\n    </group>\n  </macro>\n  <macro name=\"description\">\n    <choose>\n      <if type=\"interview\">\n        <group delimiter=\". \">\n          <text macro=\"interviewer\"/>\n          <text variable=\"medium\" text-case=\"capitalize-first\"/>\n        </group>\n      </if>\n      <else-if type=\"patent\">\n        <group delimiter=\" \" prefix=\". \">\n          <text variable=\"authority\"/>\n          <text variable=\"number\"/>\n        </group>\n      </else-if>\n      <else>\n        <text variable=\"medium\" text-case=\"capitalize-first\" prefix=\". \"/>\n      </else>\n    </choose>\n    <choose>\n      <if variable=\"title\" match=\"none\"/>\n      <else-if type=\"thesis personal_communication speech\" match=\"any\"/>\n      <else>\n        <group delimiter=\" \" prefix=\". \">\n          <text variable=\"genre\" text-case=\"capitalize-first\"/>\n          <choose>\n            <if type=\"report\">\n              <text variable=\"number\"/>\n            </if>\n          </choose>\n        </group>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"issue\">\n    <choose>\n      <if type=\"legal_case\">\n        <text variable=\"authority\" prefix=\". \"/>\n      </if>\n      <else-if type=\"speech\">\n        <group prefix=\". \" delimiter=\", \">\n          <group delimiter=\" \">\n            <text variable=\"genre\" text-case=\"capitalize-first\"/>\n            <text macro=\"event\"/>\n          </group>\n          <text variable=\"event-place\"/>\n          <text macro=\"day-month\"/>\n        </group>\n      </else-if>\n      <else-if type=\"article-newspaper article-magazine personal_communication\" match=\"any\">\n        <date variable=\"issued\" form=\"text\" prefix=\", \"/>\n      </else-if>\n      <else-if type=\"patent\">\n        <group delimiter=\", \" prefix=\", \">\n          <group delimiter=\" \">\n            <!--Needs Localization-->\n            <text value=\"filed\"/>\n            <date variable=\"submitted\" form=\"text\"/>\n          </group>\n          <group delimiter=\" \">\n            <choose>\n              <if variable=\"issued submitted\" match=\"all\">\n                <text term=\"and\"/>\n              </if>\n            </choose>\n            <!--Needs Localization-->\n            <text value=\"issued\"/>\n            <date variable=\"issued\" form=\"text\"/>\n          </group>\n        </group>\n      </else-if>\n      <else-if type=\"article-journal\" match=\"any\"/>\n      <else>\n        <group prefix=\". \" delimiter=\", \">\n          <choose>\n            <if type=\"thesis\">\n              <text variable=\"genre\" text-case=\"capitalize-first\"/>\n            </if>\n          </choose>\n          <text macro=\"publisher\"/>\n        </group>\n      </else>\n    </choose>\n  </macro>\n  <citation et-al-min=\"4\" et-al-use-first=\"1\" disambiguate-add-year-suffix=\"true\" disambiguate-add-names=\"true\" disambiguate-add-givenname=\"true\" givenname-disambiguation-rule=\"primary-name\" collapse=\"year\" after-collapse-delimiter=\"; \">\n    <layout prefix=\"(\" suffix=\")\" delimiter=\"; \">\n      <group delimiter=\", \">\n        <choose>\n          <if variable=\"issued accessed\" match=\"any\">\n            <group delimiter=\" \">\n              <text macro=\"contributors-short\"/>\n              <text macro=\"date-in-text\"/>\n            </group>\n          </if>\n          <!---comma before forthcoming and n.d.-->\n          <else>\n            <group delimiter=\", \">\n              <text macro=\"contributors-short\"/>\n              <text macro=\"date-in-text\"/>\n            </group>\n          </else>\n        </choose>\n        <text macro=\"point-locators\"/>\n      </group>\n    </layout>\n  </citation>\n  <bibliography hanging-indent=\"true\" et-al-min=\"11\" et-al-use-first=\"7\" subsequent-author-substitute=\"&#8212;&#8212;&#8212;\" entry-spacing=\"0\">\n    <sort>\n      <key macro=\"contributors\"/>\n      <key variable=\"issued\"/>\n      <key variable=\"title\"/>\n    </sort>\n    <layout suffix=\".\">\n      <group delimiter=\". \">\n        <text macro=\"contributors\"/>\n        <text macro=\"date\"/>\n        <text macro=\"title\"/>\n      </group>\n      <text macro=\"description\"/>\n      <text macro=\"secondary-contributors\" prefix=\". \"/>\n      <text macro=\"container-title\" prefix=\". \"/>\n      <text macro=\"container-contributors\"/>\n      <text macro=\"edition\"/>\n      <text macro=\"locators-chapter\"/>\n      <text macro=\"collection-title-journal\" prefix=\", \" suffix=\", \"/>\n      <text macro=\"locators\"/>\n      <text macro=\"collection-title\" prefix=\". \"/>\n      <text macro=\"issue\"/>\n      <text macro=\"locators-article\"/>\n      <text macro=\"access\" prefix=\". \"/>\n    </layout>\n  </bibliography>\n</style>\n");
// CONCATENATED MODULE: ./vendor/modern-language-association.csl
/* harmony default export */ var modern_language_association = ("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<style xmlns=\"http://purl.org/net/xbiblio/csl\" class=\"in-text\" version=\"1.0\" demote-non-dropping-particle=\"never\" page-range-format=\"minimal-two\">\n  <info>\n    <title>Modern Language Association 8th edition</title>\n    <title-short>MLA</title-short>\n    <id>http://www.zotero.org/styles/modern-language-association</id>\n    <link href=\"http://www.zotero.org/styles/modern-language-association\" rel=\"self\"/>\n    <link href=\"http://style.mla.org\" rel=\"documentation\"/>\n    <author>\n      <name>Sebastian Karcher</name>\n    </author>\n    <category citation-format=\"author\"/>\n    <category field=\"generic-base\"/>\n    <summary>This style adheres to the MLA 8th edition handbook. Follows the structure of references as outlined in the MLA Manual closely</summary>\n    <updated>2018-12-13T20:05:10+00:00</updated>\n    <rights license=\"http://creativecommons.org/licenses/by-sa/3.0/\">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights>\n  </info>\n  <locale xml:lang=\"en\">\n    <date form=\"text\">\n      <date-part name=\"day\" suffix=\" \"/>\n      <date-part name=\"month\" suffix=\" \" form=\"short\"/>\n      <date-part name=\"year\"/>\n    </date>\n    <terms>\n      <term name=\"month-01\" form=\"short\">Jan.</term>\n      <term name=\"month-02\" form=\"short\">Feb.</term>\n      <term name=\"month-03\" form=\"short\">Mar.</term>\n      <term name=\"month-04\" form=\"short\">Apr.</term>\n      <term name=\"month-05\" form=\"short\">May</term>\n      <term name=\"month-06\" form=\"short\">June</term>\n      <term name=\"month-07\" form=\"short\">July</term>\n      <term name=\"month-08\" form=\"short\">Aug.</term>\n      <term name=\"month-09\" form=\"short\">Sept.</term>\n      <term name=\"month-10\" form=\"short\">Oct.</term>\n      <term name=\"month-11\" form=\"short\">Nov.</term>\n      <term name=\"month-12\" form=\"short\">Dec.</term>\n      <term name=\"translator\" form=\"short\">trans.</term>\n    </terms>\n  </locale>\n  <macro name=\"author\">\n    <names variable=\"author\">\n      <name name-as-sort-order=\"first\" and=\"text\" delimiter-precedes-last=\"always\" delimiter-precedes-et-al=\"always\" initialize=\"false\" initialize-with=\". \"/>\n      <label form=\"long\" prefix=\", \"/>\n      <substitute>\n        <names variable=\"editor\"/>\n        <names variable=\"translator\"/>\n        <text macro=\"title\"/>\n      </substitute>\n    </names>\n  </macro>\n  <macro name=\"author-short\">\n    <group delimiter=\", \">\n      <names variable=\"author\">\n        <name form=\"short\" initialize-with=\". \" and=\"text\"/>\n        <substitute>\n          <names variable=\"editor\"/>\n          <names variable=\"translator\"/>\n          <text macro=\"title-short\"/>\n        </substitute>\n      </names>\n      <choose>\n        <if disambiguate=\"true\">\n          <text macro=\"title-short\"/>\n        </if>\n      </choose>\n    </group>\n  </macro>\n  <macro name=\"title\">\n    <choose>\n      <if variable=\"container-title\" match=\"any\">\n        <text variable=\"title\" quotes=\"true\" text-case=\"title\"/>\n      </if>\n      <else>\n        <text variable=\"title\" font-style=\"italic\" text-case=\"title\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"title-short\">\n    <choose>\n      <if variable=\"container-title\" match=\"any\">\n        <text variable=\"title\" form=\"short\" quotes=\"true\" text-case=\"title\"/>\n      </if>\n      <else>\n        <text variable=\"title\" form=\"short\" font-style=\"italic\" text-case=\"title\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"container-title\">\n    <text variable=\"container-title\" font-style=\"italic\" text-case=\"title\"/>\n  </macro>\n  <macro name=\"other-contributors\">\n    <choose>\n      <if variable=\"container-title\" match=\"any\">\n        <group delimiter=\", \">\n          <names variable=\"container-author\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \"/>\n            <name and=\"text\"/>\n          </names>\n          <names variable=\"editor translator\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \"/>\n            <name and=\"text\"/>\n          </names>\n          <names variable=\"director illustrator interviewer\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \"/>\n            <name and=\"text\"/>\n          </names>\n        </group>\n      </if>\n      <else>\n        <group delimiter=\", \">\n          <names variable=\"container-author\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \" text-case=\"capitalize-first\"/>\n            <name and=\"text\"/>\n          </names>\n          <names variable=\"editor translator\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \" text-case=\"capitalize-first\"/>\n            <name and=\"text\"/>\n          </names>\n          <names variable=\"director illustrator interviewer\" delimiter=\", \">\n            <label form=\"verb\" suffix=\" \" text-case=\"capitalize-first\"/>\n            <name and=\"text\"/>\n          </names>\n        </group>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"version\">\n    <group delimiter=\", \">\n      <choose>\n        <if is-numeric=\"edition\">\n          <group delimiter=\" \">\n            <number variable=\"edition\" form=\"ordinal\"/>\n            <text term=\"edition\" form=\"short\"/>\n          </group>\n        </if>\n        <else>\n          <text variable=\"edition\" text-case=\"capitalize-first\"/>\n        </else>\n      </choose>\n      <text variable=\"version\"/>\n    </group>\n  </macro>\n  <macro name=\"volume-lowercase\">\n    <group delimiter=\" \">\n      <text term=\"volume\" form=\"short\"/>\n      <text variable=\"volume\"/>\n    </group>\n  </macro>\n  <macro name=\"number\">\n    <group delimiter=\", \">\n      <group>\n        <choose>\n          <!--lowercase if we have a preceding element-->\n          <if variable=\"edition container-title\" match=\"any\">\n            <text macro=\"volume-lowercase\"/>\n          </if>\n          <!--other contributors preceding the volume-->\n          <else-if variable=\"author\" match=\"all\">\n            <choose>\n              <if variable=\"editor translator container-author illustrator interviewer director\" match=\"any\">\n                <text macro=\"volume-lowercase\"/>\n              </if>\n            </choose>\n          </else-if>\n          <else-if variable=\"editor\" match=\"all\">\n            <choose>\n              <if variable=\"translator container-author illustrator interviewer director\" match=\"any\">\n                <text macro=\"volume-lowercase\"/>\n              </if>\n            </choose>\n          </else-if>\n          <else-if variable=\"container-author illustrator interviewer director\" match=\"any\">\n            <text macro=\"volume-lowercase\"/>\n          </else-if>\n          <else>\n            <group delimiter=\" \">\n              <text term=\"volume\" form=\"short\" text-case=\"capitalize-first\"/>\n              <text variable=\"volume\"/>\n            </group>\n          </else>\n        </choose>\n      </group>\n      <group delimiter=\" \">\n        <text term=\"issue\" form=\"short\"/>\n        <text variable=\"issue\"/>\n      </group>\n      <choose>\n        <if type=\"report\">\n          <text variable=\"genre\"/>\n        </if>\n      </choose>\n      <text variable=\"number\"/>\n    </group>\n  </macro>\n  <macro name=\"publisher\">\n    <text variable=\"publisher\"/>\n  </macro>\n  <macro name=\"publication-date\">\n    <choose>\n      <if type=\"book chapter paper-conference motion_picture\" match=\"any\">\n        <date variable=\"issued\" form=\"numeric\" date-parts=\"year\"/>\n      </if>\n      <else-if type=\"article-journal article-magazine\" match=\"any\">\n        <date variable=\"issued\" form=\"text\" date-parts=\"year-month\"/>\n      </else-if>\n      <else-if type=\"speech\" match=\"none\">\n        <date variable=\"issued\" form=\"text\"/>\n      </else-if>\n    </choose>\n  </macro>\n  <macro name=\"location\">\n    <group delimiter=\", \">\n      <group delimiter=\" \">\n        <label variable=\"page\" form=\"short\"/>\n        <text variable=\"page\"/>\n      </group>\n      <choose>\n        <if variable=\"source\" match=\"none\">\n          <text macro=\"URI\"/>\n        </if>\n      </choose>\n    </group>\n  </macro>\n  <macro name=\"container2-title\">\n    <group delimiter=\", \">\n      <choose>\n        <if type=\"speech\">\n          <text variable=\"event\"/>\n          <date variable=\"event-date\" form=\"text\"/>\n          <text variable=\"event-place\"/>\n        </if>\n      </choose>\n      <text variable=\"archive\"/>\n      <text variable=\"archive-place\"/>\n      <text variable=\"archive_location\"/>\n    </group>\n  </macro>\n  <macro name=\"container2-location\">\n    <choose>\n      <if variable=\"source\">\n        <choose>\n          <if variable=\"DOI URL\" match=\"any\">\n            <group delimiter=\", \">\n              <text variable=\"source\" font-style=\"italic\"/>\n              <text macro=\"URI\"/>\n            </group>\n          </if>\n        </choose>\n      </if>\n    </choose>\n  </macro>\n  <macro name=\"URI\">\n    <choose>\n      <if variable=\"DOI\">\n        <text variable=\"DOI\" prefix=\"doi:\"/>\n      </if>\n      <else>\n        <text variable=\"URL\"/>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"accessed\">\n    <!--using accessed where we don't have an issued date; follows recommendation on p. 53 -->\n    <choose>\n      <if variable=\"issued\" match=\"none\">\n        <group delimiter=\" \">\n          <text term=\"accessed\" text-case=\"capitalize-first\"/>\n          <date variable=\"accessed\" form=\"text\"/>\n        </group>\n      </if>\n    </choose>\n  </macro>\n  <citation et-al-min=\"3\" et-al-use-first=\"1\" disambiguate-add-names=\"true\" disambiguate-add-givenname=\"true\">\n    <layout prefix=\"(\" suffix=\")\" delimiter=\"; \">\n      <choose>\n        <if locator=\"page line\" match=\"any\">\n          <group delimiter=\" \">\n            <text macro=\"author-short\"/>\n            <text variable=\"locator\"/>\n          </group>\n        </if>\n        <else>\n          <group delimiter=\", \">\n            <text macro=\"author-short\"/>\n            <group>\n              <label variable=\"locator\" form=\"short\"/>\n              <text variable=\"locator\"/>\n            </group>\n          </group>\n        </else>\n      </choose>\n    </layout>\n  </citation>\n  <bibliography hanging-indent=\"true\" et-al-min=\"3\" et-al-use-first=\"1\" line-spacing=\"2\" entry-spacing=\"0\" subsequent-author-substitute=\"---\">\n    <sort>\n      <key macro=\"author\"/>\n      <key variable=\"title\"/>\n    </sort>\n    <layout suffix=\".\">\n      <group delimiter=\". \">\n        <text macro=\"author\"/>\n        <text macro=\"title\"/>\n        <date variable=\"original-date\" form=\"numeric\" date-parts=\"year\"/>\n        <group delimiter=\", \">\n          <!---This group corresponds to MLA's \"Container 1\"-->\n          <text macro=\"container-title\"/>\n          <text macro=\"other-contributors\"/>\n          <text macro=\"version\"/>\n          <text macro=\"number\"/>\n          <text macro=\"publisher\"/>\n          <text macro=\"publication-date\"/>\n          <text macro=\"location\"/>\n        </group>\n        <group delimiter=\", \">\n          <!---This group corresponds to MLA's \"Container 2\"-->\n          <!--currently just using this one for archival info-->\n          <text macro=\"container2-title\"/>\n          <text macro=\"container2-location\"/>\n        </group>\n        <text macro=\"accessed\"/>\n      </group>\n    </layout>\n  </bibliography>\n</style>\n");
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CitationPreview.vue?vue&type=script&lang=js&
function CitationPreviewvue_type_script_lang_js_ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function CitationPreviewvue_type_script_lang_js_objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?CitationPreviewvue_type_script_lang_js_ownKeys(Object(b),!0).forEach(function(c){CitationPreviewvue_type_script_lang_js_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):CitationPreviewvue_type_script_lang_js_ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function CitationPreviewvue_type_script_lang_js_defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
__webpack_require__(72);/* harmony default export */ var CitationPreviewvue_type_script_lang_js_ = ({name:"CitationPreview",data:function data(){return{etal:!1,citationFormat:"apa",availableFormats:{apa:"APA",vancouver:"Vancouver",harvard1:"Harvard",mla:"MLA",chicago:"Chicago",ieee:"IEEE"}}},computed:CitationPreviewvue_type_script_lang_js_objectSpread(CitationPreviewvue_type_script_lang_js_objectSpread({},Object(vuex_esm["e" /* mapState */])(["packageDetail"])),{},{citedContributors:function citedContributors(){return models_main["c" /* Agent */].query()["with"]("meta").where("isActive",!0).where("citeable",!0).get().sort(function(c,a){// .orderBy doesn't seem to update automatically but this does
return c.citation.order-a.citation.order})},citation:function citation(){var a=this.citedContributors.map(function(a){return"person"===a.agent_type?{family:a.family_name,given:a.given_names}:{literal:a.name}}),b=new lib_mjs["a" /* Cite */]({type:"dataset",title:this.packageDetail?this.packageDetail.title:"Dataset Title",author:a,issued:{"date-parts":[[new Date().getFullYear()]]}});return b.format("bibliography",{template:this.citationFormat})},selectWidth:function selectWidth(){// this is a very rough estimate
var a=Object.values(this.availableFormats).sort(function(c,a){return a.length-c.length})[0];return 10*a.length+20+"px"}}),methods:{scrollFormat:function scrollFormat(a){var b=Object.keys(this.availableFormats),c=b.indexOf(this.citationFormat);-1===c&&(c=0);var d=c+a;0>d?d=b.length-1:d===b.length&&(d=0),this.citationFormat=b[d]}},created:function created(){var a=lib_mjs["b" /* plugins */].config.get("@csl");a.templates.add("ieee",ieee),a.templates.add("chicago",chicago_author_date),a.templates.add("mla",modern_language_association)}});
// CONCATENATED MODULE: ./src/components/CitationPreview.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_CitationPreviewvue_type_script_lang_js_ = (CitationPreviewvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/CitationPreview.vue





/* normalize component */

var CitationPreview_component = Object(componentNormalizer["a" /* default */])(
  components_CitationPreviewvue_type_script_lang_js_,
  CitationPreviewvue_type_template_id_4faea061_render,
  CitationPreviewvue_type_template_id_4faea061_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CitationPreview_api; }
CitationPreview_component.options.__file = "src/components/CitationPreview.vue"
/* harmony default export */ var CitationPreview = (CitationPreview_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=script&lang=js&
function Appvue_type_script_lang_js_ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function Appvue_type_script_lang_js_objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?Appvue_type_script_lang_js_ownKeys(Object(b),!0).forEach(function(c){Appvue_type_script_lang_js_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):Appvue_type_script_lang_js_ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function Appvue_type_script_lang_js_defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var Appvue_type_script_lang_js_ = ({name:"App",components:{CitationPreview:CitationPreview,ContributionBlock:ContributionBlock,AgentSearch:AgentSearch,draggable:vuedraggable_umd_default.a},props:["packageId","canEdit"],data:function data(){return{sortedAgents:[],cl:console.log}},computed:Appvue_type_script_lang_js_objectSpread(Appvue_type_script_lang_js_objectSpread({},Object(vuex_esm["c" /* mapGetters */])(["serialisedContent"])),{},{citedContributors:{get:function get(){return models_main["c" /* Agent */].query()["with"]("meta").where("isActive",!0).where("citeable",!0).get().sort(function(c,a){// .orderBy doesn't seem to update automatically but this does
return c.citation.order-a.citation.order})},set:function set(a){a.forEach(function(a,b){var c=[];a.citation?!a.citeable&&c.push(models_main["d" /* Citation */].updateMeta(a.citation.id,{to_delete:!1})):c.push(models_main["d" /* Citation */].insert({data:{activity:"[citation]",scheme:"internal",agent_id:a.id,order:b+1,meta:{is_new:!0}}})),Promise.all(c).then(function(){a.citation.order!==b+1&&(models_main["d" /* Citation */].update({where:a.citation.id,data:{order:b+1}}),models_main["d" /* Citation */].updateMeta(a.citation.id,{is_dirty:!0}))})})}},otherContributors:{get:function get(){return models_main["c" /* Agent */].query()["with"]("meta").where("isActive",!0).where("citeable",!1).orderBy("agent_type","desc").orderBy("standardisedName").get()},set:function set(a){a.forEach(function(a){a.citation&&models_main["d" /* Citation */].updateMeta(a.citation.id,{to_delete:!0})})}}}),methods:Appvue_type_script_lang_js_objectSpread(Appvue_type_script_lang_js_objectSpread({},Object(vuex_esm["b" /* mapActions */])(["initialise","getPackage"])),Object(vuex_esm["d" /* mapMutations */])(["setEditPermission"])),created:function created(){this.getPackage(this.packageId),this.setEditPermission("True"===this.canEdit),this.initialise()}});
// CONCATENATED MODULE: ./src/App.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_Appvue_type_script_lang_js_ = (Appvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/App.vue





/* normalize component */

var App_component = Object(componentNormalizer["a" /* default */])(
  src_Appvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var App_api; }
App_component.options.__file = "src/App.vue"
/* harmony default export */ var App = (App_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/Help.vue?vue&type=template&id=2940d8d2&
var Helpvue_type_template_id_2940d8d2_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "help-icon" }, [
    _c("i", { staticClass: "fas fa-question-circle" }),
    _vm._v(" "),
    _c(
      "div",
      { staticClass: "help-tooltip", attrs: { role: "tooltip" } },
      [_vm._t("default")],
      2
    )
  ])
}
var Helpvue_type_template_id_2940d8d2_staticRenderFns = []
Helpvue_type_template_id_2940d8d2_render._withStripped = true


// CONCATENATED MODULE: ./src/components/fields/Help.vue?vue&type=template&id=2940d8d2&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/Help.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
/* harmony default export */ var Helpvue_type_script_lang_js_ = ({name:"Help"});
// CONCATENATED MODULE: ./src/components/fields/Help.vue?vue&type=script&lang=js&
 /* harmony default export */ var fields_Helpvue_type_script_lang_js_ = (Helpvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/fields/Help.vue





/* normalize component */

var Help_component = Object(componentNormalizer["a" /* default */])(
  fields_Helpvue_type_script_lang_js_,
  Helpvue_type_template_id_2940d8d2_render,
  Helpvue_type_template_id_2940d8d2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Help_api; }
Help_component.options.__file = "src/components/fields/Help.vue"
/* harmony default export */ var Help = (Help_component.exports);
// EXTERNAL MODULE: ./src/components/fields/Field.vue + 4 modules
var Field = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/TextField.vue?vue&type=template&id=e1987f32&
var TextFieldvue_type_template_id_e1987f32_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { class: _vm.classes }, [
    _c("label", { attrs: { for: _vm.fieldId } }, [_vm._t("default")], 2),
    _vm._v(" "),
    _c("input", {
      attrs: { type: "text", id: _vm.fieldId, placeholder: _vm.placeholder },
      domProps: { value: _vm.value },
      on: { change: _vm.setValue }
    })
  ])
}
var TextFieldvue_type_template_id_e1987f32_staticRenderFns = []
TextFieldvue_type_template_id_e1987f32_render._withStripped = true


// CONCATENATED MODULE: ./src/components/fields/TextField.vue?vue&type=template&id=e1987f32&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/TextField.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
/* harmony default export */ var TextFieldvue_type_script_lang_js_ = ({name:"TextField",extends:Field["a" /* default */],props:["placeholder"]});
// CONCATENATED MODULE: ./src/components/fields/TextField.vue?vue&type=script&lang=js&
 /* harmony default export */ var fields_TextFieldvue_type_script_lang_js_ = (TextFieldvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/fields/TextField.vue





/* normalize component */

var TextField_component = Object(componentNormalizer["a" /* default */])(
  fields_TextFieldvue_type_script_lang_js_,
  TextFieldvue_type_template_id_e1987f32_render,
  TextFieldvue_type_template_id_e1987f32_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TextField_api; }
TextField_component.options.__file = "src/components/fields/TextField.vue"
/* harmony default export */ var TextField = (TextField_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/SelectField.vue?vue&type=template&id=649510f8&
var SelectFieldvue_type_template_id_649510f8_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { class: _vm.classes }, [
    _c("label", { attrs: { for: _vm.fieldId } }, [_vm._t("default")], 2),
    _vm._v(" "),
    _c(
      "select",
      {
        attrs: { id: _vm.fieldId },
        domProps: { value: _vm.value },
        on: { change: _vm.setValue }
      },
      _vm._l(_vm.options, function(opt) {
        return _c("option", { domProps: { value: _vm.optValue(opt) } }, [
          _vm._v(_vm._s(_vm.optLabel(opt)))
        ])
      }),
      0
    )
  ])
}
var SelectFieldvue_type_template_id_649510f8_staticRenderFns = []
SelectFieldvue_type_template_id_649510f8_render._withStripped = true


// CONCATENATED MODULE: ./src/components/fields/SelectField.vue?vue&type=template&id=649510f8&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/SelectField.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var SelectFieldvue_type_script_lang_js_ = ({name:"SelectField",extends:Field["a" /* default */],props:{options:{},optValue:{default:function _default(){return function(a){return a}}},optLabel:{default:function _default(){return function(a){return a}}}}});
// CONCATENATED MODULE: ./src/components/fields/SelectField.vue?vue&type=script&lang=js&
 /* harmony default export */ var fields_SelectFieldvue_type_script_lang_js_ = (SelectFieldvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/fields/SelectField.vue





/* normalize component */

var SelectField_component = Object(componentNormalizer["a" /* default */])(
  fields_SelectFieldvue_type_script_lang_js_,
  SelectFieldvue_type_template_id_649510f8_render,
  SelectFieldvue_type_template_id_649510f8_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SelectField_api; }
SelectField_component.options.__file = "src/components/fields/SelectField.vue"
/* harmony default export */ var SelectField = (SelectField_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/Autocomplete.vue?vue&type=template&id=2f36eabe&
var Autocompletevue_type_template_id_2f36eabe_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "autocomplete",
      class: _vm.hasLabel ? "autocomplete-label" : "autocomplete-no-label"
    },
    [
      _vm.hasLabel
        ? _c("label", { attrs: { for: "autocomplete-text-" + _vm.itemId } }, [
            _vm._v(_vm._s(_vm.label))
          ])
        : _vm._e(),
      _vm._v(" "),
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.textInput,
            expression: "textInput"
          }
        ],
        staticClass: "autocomplete-text",
        attrs: {
          type: "text",
          id: "autocomplete-text-" + _vm.itemId,
          autocomplete: "off",
          placeholder: "Type to search"
        },
        domProps: { value: _vm.textInput },
        on: {
          input: [
            function($event) {
              if ($event.target.composing) {
                return
              }
              _vm.textInput = $event.target.value
            },
            _vm.debounced
          ],
          focusin: _vm.showOptions
        }
      }),
      _vm._v(" "),
      _vm.optionsShown && _vm.optionCount > 0
        ? _c(
            "div",
            {
              staticClass: "autocomplete-options",
              attrs: { id: "autocomplete-list-" + _vm.itemId }
            },
            [
              _vm._l(_vm.optionBlocks, function(optBlock, optTitle) {
                return [
                  optBlock.length > 0 && optTitle !== "default"
                    ? _c(
                        "div",
                        {
                          staticClass:
                            "autocomplete-option autocomplete-block-title"
                        },
                        [
                          _vm._v(
                            "\n                " +
                              _vm._s(optTitle) +
                              "\n            "
                          )
                        ]
                      )
                    : _vm._e(),
                  _vm._v(" "),
                  _vm._l(optBlock, function(opt) {
                    return _c(
                      "div",
                      {
                        staticClass: "autocomplete-option",
                        on: {
                          click: function($event) {
                            return _vm.optionChange(opt)
                          }
                        }
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(opt.label) +
                            "\n            "
                        )
                      ]
                    )
                  })
                ]
              }),
              _vm._v(" "),
              _vm._t("default"),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "autocomplete-option null-option",
                  on: {
                    click: function($event) {
                      return _vm.optionChange({ label: null, value: null })
                    }
                  }
                },
                [_vm._v("\n            -- none --\n        ")]
              )
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.optionsShown && _vm.optionCount > 0
        ? _c(
            "span",
            { staticClass: "expand-bar", on: { click: _vm.hideOptions } },
            [_c("i", { staticClass: "fas fa-caret-up" })]
          )
        : _vm._e(),
      _vm._v(" "),
      _c("i", {
        staticClass: "fas",
        class: _vm.boxIcon,
        attrs: { title: _vm.failed }
      })
    ]
  )
}
var Autocompletevue_type_template_id_2f36eabe_staticRenderFns = []
Autocompletevue_type_template_id_2f36eabe_render._withStripped = true


// CONCATENATED MODULE: ./src/components/fields/Autocomplete.vue?vue&type=template&id=2f36eabe&

// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__(40);
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/Autocomplete.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var Autocompletevue_type_script_lang_js_ = ({name:"Autocomplete",props:{options:[Array,Object],value:[String,Object],itemId:String,label:String,delay:{type:Number,default:200},loading:Boolean,failed:[Error,Object]},data:function data(){return{textInput:null,optionsShown:!1,typing:!1}},computed:{hasLabel:function hasLabel(){return this.label&&""!==this.label},optionBlocks:function optionBlocks(){if(Array.isArray(this.options))return{default:this.options};var b={};return Object.entries(this.options).sort(function(c,a){return"default"===c[0]?-1:"default"===a[0]?1:0}).forEach(function(c){b[c[0]]=c[1]}),b},optionCount:function optionCount(){var a=Object.values(this.optionBlocks).reduce(function(a,b){return a+b.length},0);return a+=this.$slots["default"]?1:0,a},boxIcon:function boxIcon(){return this.failed?"fa-times":this.loading?"fa-spinner fa-spin":this.typing?"fa-xs fa-ellipsis-h":"fa-check"}},methods:{showOptions:function showOptions(){this.textChange(),this.optionsShown=!0},hideOptions:function hideOptions(){var a=this;setTimeout(function(){a.optionsShown=!1},200)},textChange:function textChange(){this.$emit("typing",this.textInput),this.typing=!1},optionChange:function optionChange(a){this.optionsShown=!1,this.textInput=a.label,this.$emit("input",a.value)},debounced:function debounced(){this.typing=!0,this._debounced()}},created:function created(){var a=this;if(this._debounced=lodash_debounce_default()(this.textChange,this.delay),this.value){var b=this.options.filter(function(b){return b.value===a.value});0<b.length&&(this.textInput=b[0].label)}this.$parent.$on("custom-option",this.optionChange)},watch:{value:function value(){this.value||(this.textInput=null)}}});
// CONCATENATED MODULE: ./src/components/fields/Autocomplete.vue?vue&type=script&lang=js&
 /* harmony default export */ var fields_Autocompletevue_type_script_lang_js_ = (Autocompletevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/fields/Autocomplete.vue





/* normalize component */

var Autocomplete_component = Object(componentNormalizer["a" /* default */])(
  fields_Autocompletevue_type_script_lang_js_,
  Autocompletevue_type_template_id_2f36eabe_render,
  Autocompletevue_type_template_id_2f36eabe_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Autocomplete_api; }
Autocomplete_component.options.__file = "src/components/fields/Autocomplete.vue"
/* harmony default export */ var Autocomplete = (Autocomplete_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/AutocompleteList.vue?vue&type=template&id=0a59fd7c&scoped=true&
var AutocompleteListvue_type_template_id_0a59fd7c_scoped_true_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "autocomplete",
      class: _vm.hasLabel ? "autocomplete-label" : "autocomplete-no-label"
    },
    [
      _vm.hasLabel
        ? _c(
            "label",
            { attrs: { for: "autocomplete-text-list-" + _vm.itemId } },
            [_vm._v(_vm._s(_vm.label))]
          )
        : _vm._e(),
      _vm._v(" "),
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.textInput,
            expression: "textInput"
          }
        ],
        staticClass: "autocomplete-text",
        attrs: {
          type: "text",
          id: "autocomplete-text-list-" + _vm.itemId,
          autocomplete: "off",
          placeholder: "Type to search"
        },
        domProps: { value: _vm.textInput },
        on: {
          input: [
            function($event) {
              if ($event.target.composing) {
                return
              }
              _vm.textInput = $event.target.value
            },
            _vm.debounced
          ],
          focusin: _vm.showOptions
        }
      }),
      _vm._v(" "),
      _vm.optionsShown && _vm.optionCount > 0
        ? _c(
            "div",
            {
              staticClass: "autocomplete-options",
              attrs: { id: "autocomplete-list-" + _vm.itemId }
            },
            [
              _vm._l(_vm.optionBlocks, function(optBlock, optTitle) {
                return [
                  optBlock.length > 0 && optTitle !== "default"
                    ? _c(
                        "div",
                        {
                          staticClass:
                            "autocomplete-option autocomplete-block-title"
                        },
                        [
                          _vm._v(
                            "\n                " +
                              _vm._s(optTitle) +
                              "\n            "
                          )
                        ]
                      )
                    : _vm._e(),
                  _vm._v(" "),
                  _vm._l(optBlock, function(opt) {
                    return _c(
                      "div",
                      {
                        staticClass: "autocomplete-option",
                        on: {
                          click: function($event) {
                            return _vm.optionChange(opt)
                          }
                        }
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(opt.label) +
                            "\n            "
                        )
                      ]
                    )
                  })
                ]
              }),
              _vm._v(" "),
              _vm._t("default"),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "autocomplete-option null-option",
                  on: {
                    click: function($event) {
                      return _vm.optionChange({ label: null, value: null })
                    }
                  }
                },
                [_vm._v("\n            -- none --\n        ")]
              )
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.optionsShown && _vm.optionCount > 0
        ? _c(
            "span",
            { staticClass: "expand-bar", on: { click: _vm.hideOptions } },
            [_c("i", { staticClass: "fas fa-caret-up" })]
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "autocomplete-list-items" },
        _vm._l(_vm.valueList, function(item) {
          return _c("div", [
            _c("span", [_vm._v(_vm._s(item.label))]),
            _vm._v(" "),
            _c("i", {
              staticClass: "fas fa-times",
              on: {
                click: function($event) {
                  return _vm.removeItem(item)
                }
              }
            })
          ])
        }),
        0
      ),
      _vm._v(" "),
      _c("i", {
        staticClass: "fas",
        class: _vm.loading ? "fa-spinner fa-spin" : "fa-check"
      })
    ]
  )
}
var AutocompleteListvue_type_template_id_0a59fd7c_scoped_true_staticRenderFns = []
AutocompleteListvue_type_template_id_0a59fd7c_scoped_true_render._withStripped = true


// CONCATENATED MODULE: ./src/components/fields/AutocompleteList.vue?vue&type=template&id=0a59fd7c&scoped=true&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/fields/AutocompleteList.vue?vue&type=script&lang=js&
function _toConsumableArray(a){return _arrayWithoutHoles(a)||_iterableToArray(a)||_unsupportedIterableToArray(a)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(a,b){if(a){if("string"==typeof a)return _arrayLikeToArray(a,b);var c=Object.prototype.toString.call(a).slice(8,-1);return"Object"===c&&a.constructor&&(c=a.constructor.name),"Map"===c||"Set"===c?Array.from(a):"Arguments"===c||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)?_arrayLikeToArray(a,b):void 0}}function _iterableToArray(a){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(a))return Array.from(a)}function _arrayWithoutHoles(a){if(Array.isArray(a))return _arrayLikeToArray(a)}function _arrayLikeToArray(a,b){(null==b||b>a.length)&&(b=a.length);for(var c=0,d=Array(b);c<b;c++)d[c]=a[c];return d}//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var AutocompleteListvue_type_script_lang_js_ = ({name:"AutocompleteList",extends:Autocomplete,props:{value:Array},data:function data(){return{valueList:[]}},methods:{optionChange:function optionChange(a){this.optionsShown=!1,this.textInput=null;a.value&&(this.valueList.push(a),this.$emit("input",this.valueList))},removeItem:function removeItem(a){this.valueList=this.valueList.filter(function(b){return b.value!==a.value}),this.$emit("input",this.valueList)}},created:function created(){this.valueList=_toConsumableArray(this.value)}});
// CONCATENATED MODULE: ./src/components/fields/AutocompleteList.vue?vue&type=script&lang=js&
 /* harmony default export */ var fields_AutocompleteListvue_type_script_lang_js_ = (AutocompleteListvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/fields/AutocompleteList.vue





/* normalize component */

var AutocompleteList_component = Object(componentNormalizer["a" /* default */])(
  fields_AutocompleteListvue_type_script_lang_js_,
  AutocompleteListvue_type_template_id_0a59fd7c_scoped_true_render,
  AutocompleteListvue_type_template_id_0a59fd7c_scoped_true_staticRenderFns,
  false,
  null,
  "0a59fd7c",
  null
  
)

/* hot reload */
if (false) { var AutocompleteList_api; }
AutocompleteList_component.options.__file = "src/components/fields/AutocompleteList.vue"
/* harmony default export */ var AutocompleteList = (AutocompleteList_component.exports);
// CONCATENATED MODULE: ./src/app.js
// app
vue_esm["a" /* default */].component("app",App),vue_esm["a" /* default */].component("help-tooltip",Help),vue_esm["a" /* default */].component("input-field",Field["a" /* default */]),vue_esm["a" /* default */].component("text-field",TextField),vue_esm["a" /* default */].component("select-field",SelectField),vue_esm["a" /* default */].component("autocomplete-field",Autocomplete),vue_esm["a" /* default */].component("autocomplete-list",AutocompleteList),new vue_esm["a" /* default */]({el:"#contributors",store:main["a" /* default */]});

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@citation-js/core/lib-mjs/index.js + 39 modules
var lib_mjs = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/locales.json
var locales = __webpack_require__(38);

// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/locales.js


const locales_locales = new lib_mjs["c" /* util */].Register(locales);

const fetchLocale = lang => {
  if (locales_locales.has(lang)) {
    return locales_locales.get(lang);
  } else {
    return locales_locales.get('en-US');
  }
};

/* harmony default export */ var lib_mjs_locales = (fetchLocale);

// EXTERNAL MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/styles.json
var styles = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/styles.js


const templates = new lib_mjs["c" /* util */].Register(styles);

const fetchStyle = style => {
  if (templates.has(style)) {
    return templates.get(style);
  } else {
    return templates.get('apa');
  }
};

/* harmony default export */ var lib_mjs_styles = (fetchStyle);

// EXTERNAL MODULE: ./node_modules/citeproc/citeproc_commonjs.js
var citeproc_commonjs = __webpack_require__(17);
var citeproc_commonjs_default = /*#__PURE__*/__webpack_require__.n(citeproc_commonjs);

// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/engines.js



const proxied = Symbol.for('proxied');

const getWrapperProxy = function (original) {
  const proxy = function (state, entry) {
    if (state.sys.wrapBibliographyEntry) {
      const [prefix, postfix] = state.sys.wrapBibliographyEntry(this.system_id);
      entry = [prefix, entry, postfix].join('');
    }

    return original.call(this, state, entry);
  };

  proxy[proxied] = true;
  return proxy;
};

for (const format in citeproc_commonjs_default.a.Output.Formats) {
  const original = citeproc_commonjs_default.a.Output.Formats[format]['@bibliography/entry'];

  if (!original || original[proxied]) {
    continue;
  }

  citeproc_commonjs_default.a.Output.Formats[format]['@bibliography/entry'] = getWrapperProxy(original);
}

const engines = {};

const fetchEngine = function (style, lang, template, retrieveItem, retrieveLocale) {
  const engineHash = `${style}|${lang}`;
  let engine;

  if (engines[engineHash] instanceof citeproc_commonjs_default.a.Engine) {
    engine = engines[engineHash];
    engine.sys.retrieveItem = retrieveItem;
    engine.updateItems([]);
  } else {
    engine = engines[engineHash] = new citeproc_commonjs_default.a.Engine({
      retrieveLocale,
      retrieveItem
    }, template, lang, true);
  }

  return engine;
};

const prepareEngine = function (data, templateName, language, format) {
  const items = data.reduce((store, entry) => {
    store[entry.id] = entry;
    return store;
  }, {});
  const template = templates.get(templates.has(templateName) ? templateName : 'apa');
  language = locales_locales.has(language) ? language : 'en-US';
  const engine = fetchEngine(templateName, language, template, key => items[key], locales_locales.get.bind(locales_locales));
  engine.setOutputFormat(format);
  return engine;
};

/* harmony default export */ var lib_mjs_engines = (prepareEngine);

// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/attr.js
const getAttributedEntry = (string, name, value) => string.replace(/^\s*<[a-z]+/i, `$& data-${name}="${value}"`);

const getPrefixedEntry = (value, id) => getAttributedEntry(value, 'csl-entry-id', id);


// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/bibliography.js



const getAffix = (source, affix) => typeof affix === 'function' ? affix(source) : affix || '';

function bibliography_bibliography(data, options = {}) {
  const {
    template = 'apa',
    lang = 'en-US',
    format = 'text',
    nosort = false
  } = options;
  const ids = options.entry ? [].concat(options.entry) : data.map(({
    id
  }) => id);
  const citeproc = lib_mjs_engines(data, template, lang, format);
  const sortedIds = citeproc.updateItems(ids, nosort);

  if (options.append || options.prepend) {
    const items = data.reduce((items, entry) => {
      items[entry.id] = entry;
      return items;
    }, {});

    citeproc.sys.wrapBibliographyEntry = function (id) {
      const entry = items[id];
      return [getAffix(entry, options.prepend), getAffix(entry, options.append)];
    };
  } else {
    citeproc.sys.wrapBibliographyEntry = () => ['', ''];
  }

  const bibliography = citeproc.makeBibliography();
  const [{
    bibstart,
    bibend
  }, bibBody] = bibliography;
  const entries = bibBody.map((element, index) => getPrefixedEntry(element, sortedIds[index]));

  if (options.asEntryArray) {
    return entries.map((element, index) => [sortedIds[index], element]);
  }

  return bibstart + entries.join('') + bibend;
}
// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/citation.js

function citation_citation(data, options = {}) {
  const {
    template = 'apa',
    lang = 'en-US',
    format = 'text'
  } = options;
  const ids = data.map(({
    id
  }) => id);
  const entries = options.entry ? [].concat(options.entry) : ids;
  const citeproc = lib_mjs_engines(data, template, lang, format);
  citeproc.updateItems(ids);
  const citation = citeproc.previewCitationCluster({
    citationItems: entries.map(id => ({
      id
    })),
    properties: {
      noteIndex: 0
    }
  }, [], [], format);
  return citation;
}
// CONCATENATED MODULE: ./node_modules/@citation-js/plugin-csl/lib-mjs/index.js






lib_mjs["b" /* plugins */].add('@csl', {
  output: {
    bibliography: bibliography_bibliography,
    citation: citation_citation
  },
  config: {
    engine: lib_mjs_engines,
    locales: locales_locales,
    templates: templates
  }
});

/***/ })
/******/ ]);
});